
.. _ch47_00:

Некоторые общие параметры конфигурации
======================================

В этой главе обсуждаются некоторые настройки конфигурации, которые кажутся наиболее общими. Дополнительные примеры и обсуждения могут быть найдены в книге о Exim.

.. _ch47_01:

Отсылка почты на “умный” хост
-----------------------------

Если вы хотите отсылать всю почту для нелокальных доменов на “умный хост” (“smart host”), вы должны заменить маршрутизатор по умолчанию **dnslookup**, на маршрутизатор явно задающий маршрут::

    send_to_smart_host:
      driver = manualroute
      route_list = !+local_domains smart.host.name
      transport = remote_smtp

Если необходимо, вы можете использовать IP адрес умного хоста, вместо имени. Если вы используете Exim лишь для передачи сообщений на умный хост, а не для получения входящих сообщений, вы должны принять меры для синхронизации подачи, путём установки параметра **mua_wrapper** (смотрите главу :ref:`48 <ch48_00>`).

.. _ch47_02:

Использование Exim для обработки списков рассылки
-------------------------------------------------

Exim может быть использован для запуска простого списка рассылки, но для больших и/или сложных требований, рекомендуется использование дополнительного ПО для управления списками рассылки, типа Majordomo или Mailman.

Маршрутизатор **redirect** может быть использован для обработки списков рассылки, где каждый список поддерживается в отдельном файле, который, поэтому, может управляться независмыми диспетчерами. Параметр **domains** маршрутизатора может использоваться для запуска этих списков в отдельных доменах, от нормальной почты. Например::

    lists:
      driver = redirect
      domains = lists.example
      file = /usr/lists/$local_part
      forbid_pipe
      forbid_file
      errors_to = $local_part-request@lists.example
      no_more

Этот маршрутизатор пропущен для доменов, иных нежели *lists.example*. Для адресов в этих доменах, он ищет файл, совпадающий с локальной частью. Если файла нет, маршрутизация не выполняется, но, поскольку установлена **no_more**, последующие маршрутизаторы не проверяются, и вся доставка заканчивается неудачей.

Параметры **forbid_pipe** и **forbid_file** предотвращают раскрытие локальной части в доставку в трубу или файл, которая, обычно, неуместна в списках рассылки.

Параметр **errors_to** задаёт, что любые ошибки доставки, вызванные адресами взятыми из списка рассылки, должны быть отосланы на заданный адрес, а не оригинальному отправителю сообщения. Однако, до этого действия, Exim проверяет ошибочный адрес, и игнорирует, если его проверка неудачна.

Например, используя конфигурацию выше, почта посланная на *dicts@lists.example* - передаётся на адреса содержащиеся в */usr/lists/dicts*, с направлением сообщений о ошибках на  *dicts-request@lists.example*, при условии, что этот адрес может быть проверен. Также возможно, что тут мог бы быть файл с именем */usr/lists/dicts-request*, содержащий адрес(а) деспетчер(a|ов) данного специфического списка, но иным подходом, типа установки более раннего маршрутизатора (возможно, использующего параметры **local_part_prefix** или **local_part_suffix**) для обработки адресов в форме owner-xxx или xxx-request.

.. _ch47_03:

Синтаксические ошибки в списках рассылки
----------------------------------------

Если вхождение в данных перенаправления содержит синтаксическую ошибку, Exim, обычно, задерживает доставку оригинального адреса. Это означает, что ошибка синтаксиса, в списке рассылки, задержит все доставки на этот список. Это может быть неподходящим, когда список обслуживается автоматически, из данных предоставленных пользователями, и адреса не проверены строго.

Если установлен параметр **skip_syntax_errors**, маршрутизатор **redirect** просто пропускает вхождения, которые не может разобрать, отмечая инцидент в логах. Если, дополнительно, **syntax_errors_to** установлена в адрес который можно проверить, сообщение посылается на него при каждом пропуске битого адреса. Обычно, **syntax_errors_to** устанавливается в тот же адрес, что и **errors_to**.

.. _ch47_04:

Повторное раскрытие списков рассылки
------------------------------------

Exim запоминает каждый индивидуальный адрес, на который было доставлено сообщение, для избежания дублирования, но, обычно, он сохраняет лишь оригинальный адрес получателя, сообщения. Если все доставки на список рассылки не могут быть завершены в первую попытку, список рассылки раскрывается повторно, когда происходит следующая попытка доставки. Это означает, что изменения списка примаются во внимание при каждой попытке доставки, таким образом, адреса, которые были добавлены к списку с того времени как пришло сообщение, также получат копию сообщения, несмотря на то, что оно предшествовало их подписке.

Если такое поведение - нежелательно, в маршрутизаторе **redirect** может быть установлен параметр **one_time**. Если это сделано, любые созданные маршрутизатором адреса, которые не удалось доставить при первой попытке, добавляются к сообщению как “верхний уровень” (“top level”) адресов, и, создавший их родительский адрес, помечается как “доставленный” (“delivered”). Таким образом, раскрытие списков рассылки не происходит заново, в последующие попытки доставки. Неудобство этого, в том, что если любой неудачный адрес - некорректен, его исправление в файле не имеет эффекта для предыдущих сообщений.

Оригинальный адрес высшего уровня запоминается с каждым созданным адресом, и выводится в логах. Однако, любые промежуточные родительские адреса - не записываются. Это делает различие для логов лишь если установлен селектор **all_parents**, но, так или иначе, для списков рассылки обычен лишь один уровень раскрытия.

.. _ch47_05:

Закрытые списки рассылки
------------------------

Примеры, пока, предполагали открытые списки рассылки, в которые любой может послать почту. Также возможно настроить закрытые списки, где почта принимается лишь от специфических отправителей. Это производится путём использования общего параметра **senders**, для ограничения маршрутизатора обрабатывающего список.

Следующий пример использует один и тот же файл как список получателей, и как список разрешённых отправителей. Он требует трёх маршрутизаторов::

    lists_request:
      driver = redirect
      domains = lists.example
      local_part_suffix = -request
      file = /usr/lists/$local_part$local_part_suffix
      no_more
      
    lists_post:
      driver = redirect
      domains = lists.example
      senders = ${if exists {/usr/lists/$local_part}\
                 {lsearch;/usr/lists/$local_part}{*}}
      file = /usr/lists/$local_part
      forbid_pipe
      forbid_file
      errors_to = $local_part-request@lists.example
      no_more

    lists_closed:
      driver = redirect
      domains = lists.example
      allow_fail
      data = :fail: $local_part@lists.example is a closed mailing list

Все три маршрутизатора имеют одну и ту же установку **domains**, таким образом, для любых других доменов, они пропущены. Первый маршрутизатор запускается лишь если локальная часть завершается на “-request”. Он обрабатывает сообщения к диспетчер(у|ам) списка, путём открытого списка рассылки.

Второй маршрутизатор запускается лишь если удовлетворено предварительное условие **senders**. Он проверяет существование списка соответствующего локальной части, и, затем, с помощью линейного поиска проверяет, что отправитель находится в списке. До попытки поиска по файлу, необходимо проверить его существование, поскольку иначе Exim подумает, что произошла конфигурационная ошибка. Если файл не существует, раскрытие **senders** приводит к “*”, что соответствует всем отправителям. Это означает, что маршрутизатор работает, но, поскольку нет списка, от него отказываются, и **no_more** гарантирует, что дальнейшие маршрутизаторы  не запускаются. Адрес неудачен с ошибкой “unrouteable address”.

Третий маршрутизатор запускается лишь если второй маршрутизатор пропущен, что происходит когда список рассылки существует, но отправитель не в нём. Этот маршрутизатор принудительно создаёт неудачу адреса, давая подходящее сообщение о ошибке.

.. _ch47_06:

Переменные пути возврата конверта (VERP)
----------------------------------------

Variable Envelope Return Paths – смотрите http://cr.yp.to/proto/verp.txt - являются способом помочь администраторам списков рассылок обнаружить, какой адрес подписки является причиной специфической неудачи доставки. Идея - в кодировании оригинального получателя адреса в исходящем адресе отправителя конверта, таким образом, если сообщение форвардится путём другого хоста, и, впоследствии, создаётся рикошет, оригинальный получатель может быть извлечён из адреса получателя рикошета.

Адрес отправителя конверта может быть модифицирован Exim`ом используя два различных средства: параметр **errors_to** в маршрутизаторе (как показано в предыдущих примерах списков рассылки), или транспортный параметр **return_path**. Второй из них эффективен лишь если сообщение успешно доставлено не иной хост; она не используется, для ошибок детектируемых на локальном хосте (смотрите описание **return_path** в главе :ref:`24 <ch24_00>`). Вот - пример использования **return_path** для осуществления VERP в транспорте **smtp**::

    verp_smtp:
    driver = smtp
    max_rcpt = 1
    return_path = \
      ${if match {$return_path}{^(.+?)-request@your.dom.example\$}\
      {$1-request+$local_part=$domain@your.dom.example}fail}
                      
Он имеет эффект перезаписи обратного пути (отправителя конверта) в исходящих SMTP сообщениях, если локальная часть оригинального получателя завершается на “-request”, и домен - *your.dom.example*. Перезапись вставляет локальную часть и домен получателя в путь возврата. Предположим, например, что сообщение, чей путь возврата установлен в *somelist-request@your.dom.example* - посылается на *subscriber@other.dom.example*. В транспорте, путь возврата переписывается как::

    somelist-request+subscriber=other.dom.example@your.dom.example


Чтобы это работало, вы должны сказать Exim'y посылать несколько копий сообщений имеющих более одного получателя, чтобы каждая копия имела лишь одного получателя. Это достигается путём установки **max_rcpt** в 1. Без этого, одна копия сообщения может быть послана нескольким различным получателям в одном домене, когда $local_part недоступна в транспорте, поскольку она не уникальна.

Если ваш хост не только производит доставки списков рассылки, вы, вероятно, должны использовать отдельный транспорт для доставок VERP, чтобы не использовать дополнительные ресурсы для создания копий, по одной на получателя.. Это легко может быть сделано путём раскрытия параметра **transport** в маршрутизаторе::

    dnslookup:
      driver = dnslookup
      domains = ! +local_domains
      transport = \
        ${if match {$return_path}{^(.+?)-request@your.dom.example\$}\
                   {verp_smtp}{remote_smtp}}
      no_more

Если вы хотите изменить путь возврата используя **errors_to** в маршрутизаторе, вместо использования **return_path** в транспорте, вам необходимо установить **errors_to** во всех маршрутизаторах которые обрабатывают адреса списков рассылок. Это будет гарантировать, что все ошибки доставки, включая детектируемые на локальном хосте, посылаются на адреса VERP.

На хосте, который не делает локальных доставок, и не имеет ручной маршрутизации, в изменении нуждается лишь маршрутизатор **dnslookup**. Для доставки SMTP не нужен специальный транспорт. Каждый получатель списка рассылки имеет свой собственный путь возврата, и, таким образом, Exim должен передать их транспорту по одному. Вот - пример маршрутизатора **dnslookup**, который осуществляет VERP::

    verp_dnslookup:
      driver = dnslookup
      domains = ! +local_domains
      transport = remote_smtp
      errors_to = \
      ${if match {$return_path}{^(.+?)-request@your.dom.example\$}}
        {$1-request+$local_part=$domain@your.dom.example}fail}
      no_more

До того, как вы начнёте рассылать сообщения с VERP путём возврата, вы, также, должны настроить Exim на приём рикошетов, которые возвращаются с таким путём. Обычно, это производится путём установки параметра **local_part_suffix** для маршрутизатора, и использования этого для маршрутизации сообщения туда, где вы его хотели бы обработать.

Накладные расходы, при использовании VERP, очень сильно зависят от размера сообщения, числа получателей адресов, которые резольвятся на один и тот же удалённый хост, и скорости соединения, через которое посылается сообщение. Если много адресов резольвятся на один и тот же хост, и соединение медленное, посылка отдельной копии сообщения для каждого адреса может быть существенно дольше, чем посылка одной копии сообщения с многими получателями (что не может быть использоваться с VERP).

.. _ch47_07:

Виртуальные домены
------------------

Фраза “virtual domain”, к сожалению, используется для двух различных смыслов:

* Домен, для которого нет реальных почтовых ящиков; все действительные локальные части - синонимы для других почтовых адресов. Общие примеры - организационные домены верхнего уровня, и “тщеславные” (“vanity”) домены.

* Один из множества независимых доменов, которые обрабатываются одним и тем же хостом, с почтовыми ящиками на этом хосте, но, где владельцы почтовых ящиков не обязательно обладают учетной записью на этом хосте.

Первое использование, вероятно, наиболее часто, и действительно, кажется более “виртуальным” чем второе. Этот вид доменов может быть обработан Exim`ом прямой маршрутизацией синонимов. Один подход состоит в создании отдельного файла синонимов для каждого виртуального домена. Exim может проверять существование файла синонимов, для определения - существует ли домен. Тут полезен тип поиска **dsearch**, приводя к маршрутизатору такой формы::

    virtual:
      driver = redirect
      domains = dsearch;/etc/mail/virtual
      data = ${lookup{$local_part}lsearch{/etc/mail/virtual/$domain}}
      no_more

Параметр **domains** определяет, что маршрутизатор будет пропущен, если нет файла в директории */etc/mail/virtual*, чьё имя такое же, как и обрабатываемый домен Когда маршрутизатор работает, он ищет локальную часть в файле, для нахождения нового адреса (или списка адресов). Установка **no_more** обеспечивает, что если поиск неудачен (приводит к **data**, являющейся пустой строкой), Exim оставляет адрес, не пробуя последующие маршрутизаторы.

Этот маршрутизатор может обрабатывать все виртуальные домены, поскольку имена файлов синонимов следуют за фиксированным шаблоном. Разрешения могут быть розданы так, чтобы соответствующие люди могли редактировать различные файлы синонимов. Успешная операция подстановки синонима приводит к новому адресу получателя конверта, который, затем, маршрутизируется с начала.

Другой вид “виртуальных” доменов, также может быть обработан прямым методом. Один подход состоит в создании файла для каждого домена, содержащего список действительных локальных частей, и используется в маршрутизаторе типа такого::

    my_domains:
      driver = accept
      domains = dsearch;/etc/mail/domains
      local_parts = lsearch;/etc/mail/domains/$domain
      transport = my_mailboxes

Адрес принимается если есть файл для домена, и локальная часть может быть найдена в файле. Параметр **domains** используется для проверки на существование файла, поскольку **domains** проверяется до параметра **local_parts** (смотрите раздел :ref:`3.12 <ch03_12>`). Вы не можете использовать **require_files**, поскольку этот параметр проверяется после **local_parts**. Транспорт - таков::

    my_mailboxes:
      driver = appendfile
      file = /var/mail/$domain/$local_part
      user = mail

Он использует директорию почтовых ящиков для каждого домена. Установка **user** - требуется, для задания какой uid будет использоваться для записи в почтовые ящики.

Конфигурация показанная здесь - лишь один пример, как вы можете поддерживать это требование. Есть много других путей, которыми может быть настроен этот вид конфигурации, например, путём использования ВД вместо раздельных файлов, для хранения всей информации о доменах.

.. _ch47_08:

Многочисленные пользовательские почтовые ящики
----------------------------------------------

Большие пользователи почты часто хотят работать с многими почтовыми ящиками, в которых входящая почта сортируется автоматически. Популярный способ обработать это - разрешить пользователям использовать несколько адресов отправителя, таким образом, ответы могут быть легко идентифицированы. Для этой цели, пользователям разрешают добавлять префиксы или суффиксы к их локальным частям. Для этой цели могут быть использованы средства групповых символов общих параметров маршрутизатора - **local_part_prefix** и **local_part_suffix**. Например, рассмотрите такой маршрутизатор::

    userforward:
      driver = redirect
      check_local_user
      file = $home/.forward
      local_part_suffix = -*
      local_part_suffix_optional
      allow_filter

Он запускает пользовательский файл *.forward* для всех локальных частей формы *username-**. В пределах файла фильтра, пользователь может различать различные случаи путём проверки переменной $local_part_suffix. Например::

    if $local_part_suffix contains -special then
       save /home/$local_part/Mail/special
    endif
    
Если файл фильтра не существует, или не имеет дело с такими адресами, они передаются следующим маршрутизаторам, и, предполагая, что далее не используется параметр **local_part_suffix**, они, по видимому, будут неудачны. Таким образом, пользователь может контролировать, какие суффиксы являются действительными.

Альтернативно, суффикс может использоваться для вызова другого файла *.forward* - который является способом воплощения подобного средства в другом MTA::

    userforward:
      driver = redirect
      check_local_user
      file = $home/.forward$local_part_suffix
      local_part_suffix = -*
      local_part_suffix_optional
      allow_filter

Если нет никакого суффикса, используется *.forward*; если суффикс - **-special**, например, используется *.forward-special*. Ешё раз, если соответствующий файл не существует, или не имеет дела с адресом, он передаётся последующим маршрутизаторам, которые, если требуется, ищут неполный файл *.forward* и использовуют его по умолчанию.

.. _ch47_09:

Упрощённая обработка отпуска (vacation)
---------------------------------------

Традиционный способ запуска программы *vacation* для пользователей - установить команду трубы в файле *.forward* (для деталей синтаксиса, смотрите раздел :ref:`26.6 <ch26_06>`). Это распространённая ошибка у неопытных пользователей. Есть две особенности Exim`a, которые могут быть использованы для упрощения этого процесса для пользователей:

* Преффикс локальной части, типа “vacation-”, может быть задан в маршрутизаторе, который используется для непосредственной доставки сообщений к программе *vacation*, или, альтернативно, может использоваться транспорт Exim`a **autoreply**. Тогда, содержимое пользовательского файла *vacation*, намного более простое. Например:

  ::
  
      spqr, vacation-spqr

* Общий параметр маршрутизаторов, **require_files**, может использоваться для вызова доставки отпуска [#]_, путём проверки существования определённого файла в домашнем каталоге пользователя. Также должна использоваться общий параметр **unseen**, для гарантии, что произойдёт оригинальная доставка. В этом случае, все использующие это пользователи, должны создать файл, называемый, скажем “.vacation”, содержащий сообщение о отпуске.

Другое преимущество обоих этих методов состоит в том, что они оба работают даже когда пользователям запрещено использование произвольных труб.

.. _ch47_10:

Отбор копий сообщений
---------------------

Некоторые инсталляции требуют, чтобы была сделана полная архивная копия всех сообщений. Одна копия каждого сообщения может быть легко взята путём соответствующей команды в системном фильтре, который мог бы, например, использовать для каждого дня разные файлы.

Также, есть теневой транспортный механизм, который может использоваться для отбора копий сообщения, которые успешно доставлены локальными транспортами, одна копия на доставку. Это может использоваться, кроме прочего, для осуществления автоматического уведомления о доставке, сайтам [#]_ которые наставивают на таких вещах.

.. _ch47_11:

Периодически подключенные хосты
-------------------------------

Для хостов, стало весьма обычным (опскольку дешевле), подключаться к интернету периодически, а не всё время быть подключенными. Обычная настройка для таких хостов - что поста для них накапливается на системе постоянно соединённой с интернетом.

Exim был разработан для использования на постоянно подключенных хостах, и, таким образом, не особенно подходит для использования на периодически подключаемых хостах. Однако, есть особенности, которые могут использоваться.

.. _ch47_12:

Exim на вышестоящих серверных хостах
------------------------------------

Exim принимает меры, чтобы входящая почта для периодически подключаемых хостов оставалася в очереди Exim`a, пока клиент не подключится. Однако, этот подход не очень хорошо масштабируется. Два различных вида ожидания сообщения смешиваются в одной очереди - те, которые нельзя доставить из-за каких-то вреемнных проблем, и тех, которые ждут соединения их хоста предназначения. Это делает тяжёлым управление очередью, так же как и растрату ресурсов, поскольку каждый обработчик очереди сканирует всю очередь.

Лучший подход состоит в отделении тех сообщений, которые ждут временно подключаемых хостов. Это может быть сделано путём доставки этих сообщений в локальные файлы пакетного SMTP, “mailstore”, или иной формат сохраняющий конверт, из которого они передаются путём иного программного обеспечения к их месту назначения. Это облегчает сборку всей почты для одного хоста в одной директории, и применения правил локального таймаута на основании сообщений, если требуется.

Для очень небольшого масштаба, можно сделать чтобы Exim оставлял почту в очереди. Если вы это делаете, вы должны сконфигурировать Exim с длинным периодом повтора для временно подключенных хостов. Например::

    cheshire.wonderland.fict.example    *   F,5d,24h

Этим останавливается множество неудачных попыток доставки, но Exim запоминает какие сообщения находились в очереди для этого хоста. Как только непостоянный хост появляется в сети, принудительная доставка одного сообщения (или используя параметры **-M** или **-R**, или путём использования команды ETRN SMTP (смотрите раздел :ref:`45.8 <ch45_08>`)) вызывает доставку всех находящихся в очереди сообщений, часто - по одному соединению. Когда хост остаётся на связи, любые новые сообщения доставляются немедленно.

Если подключающиеся хосты не имеют фиксированного IP-адреса, т.е. хост появляется каждый раз с различным IP-адресом, механизмы повтора на хосте-владельце [#]_ запутываются, поскольку IP-адрес, обычно, используется как часть ключевой строки для информации повторов. Этого можно избежать, путём сброса **retry_include_ip_address** в **smtp** транспорте. Так как это неудобно для хостов постоянно связанных с интернет, для периодически связанных хостов лучше организовать отдельный транспорт.

.. _ch47_13:

Exim на периодически подключаемом клиентском хосте
--------------------------------------------------

Значение **smtp_accept_queue_per_connection**, вероятно, должно быть увеличено, или даже установлено в  ноль (т.е. отключено) на периодически подключаемых хостах, для того, чтобы все входящие сообщения немедленно отсылались по одному соединению.

Почта ожидающая отсылки с периодически подключаемого хоста, вероятно, не будет маршрутизироватся, поскольку без соединения с DNS, поиски невозможны. Это означает, что нормальная обработка очереди завершается за время соединения, каждое сообщение, вероятно, будет отправлено в отдельной SMTP-сессии. Этого можно избежать, путём запуска обработки очереди с параметров командной строки начинающихся с **-qq** вместо **-q**. В этом случае, очередь сканируется дважды. В первый проход, завершается маршрутизация, но доставки не происходит. Во второй проход - нормальная обработка очереди; так как все сообщения предварительно были смаршрутизированы, то предназначенные для одного и того же хоста, вероятно, будут отосланы в одном SMTP соединении.

.. [#] :) - прим. lissyara
.. [#] серверам - прим. lissyara
.. [#] почты - прим. lissyara
