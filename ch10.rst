
.. _ch10_00:

====================================================================
Списки доменов, узлов, адресов и локальных частей [почтового] адреса
====================================================================

Многие конфигурационные параметры Exim содержат списки доменов, узлов, email адресов, или локальных частей [почтового] адреса. Например, параметр **hold_domains** содержит список доменов, для которых доставка на данный момент временно приостановлена. Эти списки также используются как данные в списках управления доступом (см. главу :ref:`40 <ch40_00>`), и как параметры к условиям раскрытия, типа **match_domain**.

Каждый элемент в одном из этих списков - шаблон, проверяемый на соответствие домену, узлу, email адресу, или локальной части [почтового] адреса, соответственно. В секциях ниже описаны различные типы шаблонов для каждого случая, но сначала мы затронем некоторые общие средства, которые применяются для всех четырех типов списков.

.. _ch10_01:

-----------------
Раскрытие списков
-----------------

Каждый список раскрывается как одиночная строка перед использованием. Результатом раскрытия должен быть список, возможно, содержащий пустые элементы, разделённый на отдельные элементы для совпадения. По-умолчанию, символ-разделитель - двоеточие, но в случае необходимости он может быть изменён. Смотрите разделы :ref:`6.19 <ch06_19>` и :ref:`6.21 <ch06_21>` для деталей о синтаксисе списка; по второму линку обсуждается способ определения пустых элементов списка.

При неудачном раскрытии строки, Exim ведет себя так будто бы тестируемый элемент (домен, узел, адрес, или локальная часть [почтового] адреса) не в списке. Другие отказы раскрытия приводят к временным ошибкам.

Если элемент списка - регулярное выражение, знак обратного слеша, знак доллара и возможно другой спецсимвол в выражении, он должен быть защищен от неправильной интерпретации функцией раскрытия. Самый простой способ это сделать - использовать особенность раскрытия ``\N``, чтобы обозначить что содержимое регулярного выражения не должно раскрываться. Например, в списке управления доступом вы можете указать::

    deny senders = \N^\d{8}\w@.*\.baddomain\.example$\N : \
    ${lookup{$domain}lsearch{/badsenders/bydomain}}

Первый элемент - это регулярное выражение защищенное от раскрытия указанием ``\N``, а второй использует раскрытие для получения списка нежелательных отправителей на основе списка нежелательных доменов.

.. _ch10_02:

-----------------------------
Отрицаемые элементы в списках
-----------------------------

Элемент в списке может положительным или отрицательным. Отрицательные элементы идентифицируются предшествующим знаком восклицания, за которым может следовать пробел. Список определяет набор элементов (доменов, etc). Когда Exim обрабатывает один из этих списков, он пытается найти домен, узел, адрес или локальную часть [почтового] адреса в наборе, определенном списком. Это работает так:

Список сканируется слева направо. Если совпадает положительный элемент, проверяемый элемент включается в результирующее множество, если совпадает отрицательный - элемент исключается из результирующего множества. Если был достигнут конец списка и не было совпадений проверяемых объектов с шаблоном, то проверяемый элемент включается в множество, если последний элемент был отрицательным; если последний элемент был положительным, элемент исключается из результирующего множества::

    domainlist relay_domains = !a.b.c : *.b.c


соответствует любому домену оканчивающемуся ``.b.c`` за исключением ``a.b.c``. Домены не соответствующие ни ``a.b.c`` ни ``*.b.c`` не соответствуют, т.к. последний элемент списка позитивный. Тем не менее если бы было установлено

::

    domainlist relay_domains = !a.b.c


тогда бы совпадали все домены кроме ``a.b.c`` т.к. последний элемент списка позитивный. Другими словами список, оканчивающийся отрицательным элементом интерпретируется так, как если бы он имел дополнительный элемент ``:*`` в конце.

Другой способ подумать о положительных и отрицательных элементах списков - это читать соединитель как “или” после положительных элементов, и как “и” - после отрицательных.

.. _ch10_03:

----------------------
Имена файлов в списках
----------------------

Если элемент списка доменов, хостов, адресов или локальных частей [почтового] адреса является абсолютным именем файла (начинается со знака слеша), каждая строка файла читается и обрабатывается так, как если бы это был независимый элемент списка, за исключением того, что не допускаются дальнейшие имена файлов; раскрытие данных из файла не происходит. Пустые строки файла игнорируются, файл также может содержать строки комментариев:

* Для списков доменов и хостов если где-либо в строке файла встречается символ ``#`` он и все следующие символы игнорируются.
* Т.к. локальные части [почтового] адреса могут содержать знаки ``#``, комментарий в списке адресов или локальных частей [почтового] адреса распознается только если ``#`` стоит после пробела либо в начале строки. Например::
  
    not#comment@x.y.z   # but this is a comment

Указывая имя файла в списке имеет такой эффект как вставка каждой строки файла в качестве элемента в список (пустые строки и комментарии исключаются). Тем не менее есть одно важное отличие: файл читается при каждой обработке списка, таким образом если его содержимое периодически меняется, изменяется и поведение Exim.

Если имени файла предшествует восклицательный знак значение любых совпадений с файлом инвертируется. Например, если

::

    hold_domains = !/etc/nohold-domains

и файл содержит строки

::

    !a.b.c
    *.b.c

тогда ``a.b.c`` будет находится в списке доменов определенных в **hold_domains**, в то время как любой домен совпадающий с ``*.b.c`` - нет.

.. _ch10_04:

-----------------------------------
Файл “lsearch” не нелинейный список
-----------------------------------

Как будет описано в следующих секциях, поиски могут использоваться в списках, для обеспечения индексированных методов проверки списка членов. Было некоторое количество путаницы о способе работы **lsearch** со списками. Поскольку файл **lsearch** содержит простой текст и сканируется последовательно, то некоторые думают, что в него можно ставить групповые символы и другие переменные шаблоны. Это не так. Ключи в файле **lsearch**, всегда фиксированные строки, также как и для любого другого одноключевого поиска.

Если вы хотите использовать файл содержащий подстановочные шаблоны являющиеся частью списка, просто дайте самостоятельное имя файла, без типа поиска, как описано в предыдущей секции. Также, вы можете использовать **wildlsearch** или **nwildlsearch**, но преимуществ не получите.

.. _ch10_05:

------------------
Именованные списки
------------------

Списку доменов, хостов, e-mail адресов или локальных частей адреса можно дать название, которое используется для обращения к списку в другом месте конфигурации. Это особенно удобно, если один и тот же список нужно использовать в нескольких различных местах. Это также позволяет давать спискам осмысленные обозначения, что может улучшить понимание файла конфигурации. Например, часто задают список доменов называемый *local_domains* для всех локальных доменов, обрабатываемых на этой машине, с использованием конфигурационной строки типа::

    domainlist local_domains = localhost:my.dom.example

На именованный список можно ссылаться, давая его имя с предшествующим ему знаком ``+`` например, маршрутизатор предназначенный для обработки локальных доменов, был бы сконфигурен со строкой::

    domains = +local_domains

Первый маршрутизатор в конфигурации, обычно, тот, который обрабатывает все домены, кроме локальных, используя конфигурацию с инвертированным элементом, как этот::

    dnslookup:
      driver = dnslookup
      domains = ! +local_domains
      transport = remote_smtp
      no_more

Четыре вида именованных списков создаются конфигурационными строками, начинающимися со слов **domainlist**, **hostlist**, **addresslist** или **localpartlist** соответственно. Задаваемые вами списки помещайте после них. Например::

    hostlist    relay_hosts = 192.168.23.0/24 : my.friend.example
    addresslist bad_senders = cdb;/etc/badsenders

Именованный список может обращаться к другим именованным спискам::

    domainlist  dom1 = first.example : second.example
    domainlist  dom2 = +dom1 : third.example
    domainlist  dom3 = fourth.example : +dom2 : fifth.example



.. warning:: Если последний элемент, в списке на который ссылаются, отрицательный (инвертированный), то может быть вовсе не тот эффект, который вы ожидали, поскольку отрицание не передаётся на следующий (более высокий) уровень. Например, рассмотрите::

      domainlist  dom1 = !a.b
      domainlist  dom2 = +dom1 : *.b


                                  
  Второй список задан: “или в списке **dom1** или ``*.b``”. Первый список задаёт только ``не a.b``, таким образом домен ``x.y`` совпадает с ним. Это означает, что он также соответствует и второму списку. Эффект не такой же как::
  
      domainlist  dom2 = !a.b : *.b


  что не соответствует ``x.y``. Вообще, по возможности, лучше избегать отрицания в списках.

Именованные списки могут быть выгодны в плане производительности. Когда Exim маршрутизирует адрес или проверяет входящее сообщение, он кэширует результаты теста именованного списка. Так, если у вас есть такой пункт::

    domains = +local_domains

в нескольких маршрутизаторах или нескольких ACL, то фактически, тестируется только в первом. Однако, кэширование работает, лишь если в пределах списка, или любых подсписков, нет раскрытий. Другими словами, кэширование происходит только для списков, про которые известно, что они будут одинаковыми при каждом обращении.

По умолчанию, могут быть до 16 именованных списков каждого типа. Этот предел может быть увеличен изменением компиляционной переменной. Использование списков хостов и доменов рекомендуется для концепции типа локальных доменов, релейных доменов и релейных хостов. В конфигурации по умолчанию так и установлено.


.. _ch10_06:

-----------------------------------------
Сравнение именованных списков с макросами
-----------------------------------------

На первый взгляд, как могло бы показаться, в файле конфигурации, именованные списки неотличимы от макросов. Однако, макрос - лишь текстовая замена. Если вы напишете

::

    ALIST = host1 : host2
    auth_advertise_hosts = !ALIST

то оно, вероятно, не будет делать то, что вы хотите, потому что это, то же самое что и

::

    auth_advertise_hosts = !host1 : host2

Заметьте, что второе имя хоста не инвертировано. Однако, если вы используете список хостов, и напишете

::

    hostlist alist = host1 : host2
    auth_advertise_hosts = ! +alist

то отрицание применяется ко всему списку, и в итоге это эквивалентно

::

    auth_advertise_hosts = !host1 : !host2


.. _ch10_07:

-------------------------------
Кэширование именованных списков
-------------------------------

При обработке сообщения Exim кэширует результат проверки именованного списка, если есть уверенность, что список статический. Практически, это означает, что кэширование работает только если список не содержит символов ``$``, что гарантирует, что список не будет изменяться при раскрытии. Однако, иногда, вы можете иметь раскрываемый список, про который вы знаете, что это в пределах одного сообщения это будет тот же самый список при каждой проверке. Например::

    domainlist special_domains = \
               ${lookup{$sender_host_address}cdb{/some/file}}

Это обеспечивает список доменов, который зависит лишь от IP-адреса хоста отправителя. Если этот список доменов используется неоднократно (например в нескольких строках ACL, или в нескольких маршрутизаторах), по умолчанию, результат не кэшируется, поскольку Exim не знает, что каждую проверку это будет один и тот же список.

Добавив ``_cache`` к **domainlist** вы можете сказать Exim`y что результат можно кэшировать. Например::

    domainlist_cache special_domains = ${lookup{...

Если вы сделаете это, то вы должны быть абсолютно уверенны, что кэшированный результат будет верен во всех случаях. Если вы сомневаетесь, не делайте этого.


.. _ch10_08:

--------------
Списки доменов
--------------

Списки доменов содержат шаблоны, не совпадающие с почтовыми доменами. Следующие типы элементов могут использоваться в списках доменов:

* Если шаблон состоит из единственного символа ``@``, он совпадает с именем локального хоста, установленному параметру **primary_hostname** (или по-умолчанию). Это позволяет использовать один и тот же конфигурационный файл на нескольких разных хостах, различающихся лишь названием.
* Если шаблон содержит строку ``@[]`` - он совпадает с IP-адресом заключённым в квадратные скобки (как в почтовом адресе, который содержит доменный литерал), но лишь в случае, если этот IP адрес распознан как локальный для целей почтовой маршрутизации. Параметры **local_interfaces** и **extra_local_interfaces** могут использоваться для контроля, какой именно из нескольких IP адресов хоста обрабатывается как локальный. В сегодняшнем интернете, доменные литералы практически не используются.
* Если шаблон состоит из строки ``@mx_any``, то это совпадает с любым доменом, чья MX-запись указывает на локальных хост, или на любой хост который перечислен в **hosts_treat_as_local**. Элементы ``@mx_primary`` и ``@mx_secondary`` являются подобными, за тем исключением, что первый соответствует лишь в случае если первичных MX указывает на локальную машину, а второй, лишь когда нет первичной записи MX указывающей на локалхост, но на него указывает вторичная MX-запись. “Первичная” MX запись, означает, что у неё самое маленькое значение, и их может быть более одной.
  Поиск MX, соответствующей образцу, выполняется с параметрами резольвера для отключения раскрытия имён. Таким образом, например, однокомпонентный домен не будет раскрыт резольвером, добавлением домена по умолчанию. Смотрите параметры **qualify_single** и **search_parents** маршрутизатора **dnslookup** для подробной информации о раскрытии домена.
  Иногда можно игнорировать определённые IP-адреса, при использовании одного из этих шаблонов. Вы можете задать их сразу за образцом, при помощи ``/ignore=<ip list>``, где ``<ip list>`` - список IP-адресов. При обработке шаблона, эти адреса игнорируются (сравните с параметром **ignore_target_hosts** в маршрутизаторе). Например::

      domains = @mx_any/ignore=127.0.0.1

  Этот пример совпадает с любым доменом имеющим MX-запись указывающую на один из IP-адресов локальной машины, за исключением 127.0.0.1.

  Список IP-адресов обрабатывается тем же самым кодом, который обрабатывает список хостов, таким образом тут можно писать сети в виде CIDR, и также тут могут находится негативные элементы.

  Поскольку список IP-адресов является подсписком внутри списка доменов, вы должны быть осторожны, при использовании разделителей если тут больше одного адреса. Как и в любом другом списке, разделитель по умолчанию может быть заменён. Таким образом, можно сделать так::
  
      domains = @mx_any/ignore=<;127.0.0.1;0.0.0.0 : \
                an.other.domain : ...


  чтобы подсписок использовал в качестве разделителя точку с запятой (“;”). При использовании адресов IPv6, полезно поменять разделитель и для главного списка::
  
      domains = <? @mx_any/ignore=<;127.0.0.1;::1 ? \
                an.other.domain ? ...


* Если шаблон начинается со звёздочки (“*”), оставшиеся символы шаблона сравниваются с последними символами домена. Использование звёздочки в списках доменов отличается от её использования в частично соответствующих поисках. В списке доменов, символ следующий за звёздочкой не должен быть точкой, тогда как частичное соответствие работает лишь в разделённых точкой компонентах. Например, элемент списка доменов типа ``*key.ex`` совпадает с ``donkey.ex`` также как и с ``cipher.key.ex``
                                   
* Если шаблон начинается с символа крышки (“^”), то он обрабатывается как регулярное выражение, и совпадает с доменом с использованием соответствующей функции регулярного выражения. Крышка обрабатывается как часть регулярного выражения. Почтовый домен регистронезависим, таким образом, это регулярное выражение по умолчанию регистронезаисимо, но, вы можете сделать его регистрозависимым, начав его с ``(?-i)``. Справочная информация, описывающая синтаксис регулярных выражений, дается в главе :ref:`8 <ch08_00>`.

  .. warning:: Поскольку список доменов раскрывается до обработки, необходимо предварить обратным слешем символы обратного слэша и доллара “$”, или использовать специальную последовательность ``\N`` (смотрите главу :ref:`11 <ch11_00>`) для определения того, что не надо раскрывать (если вы действительно не хотите строить регулярное выражение при помощи раскрытия, разумеется).

* Если шаблон начинается с имени одноключевого поиска, сопровождающегося точкой с запятой (например, “dbm;” или “lsearch;”), то остаток шаблона должен быть именем файла в подходящем для поиска формате. Например, для “cdb;” это должен быть абсолютный путь::
  
      domains = cdb;/etc/mail/local_domains.cdb

  Соответствующий тип поиска производится по файлу, с использованием доменного имени как ключа. В большинстве случаев, данные которые ищутся не нужны, Exim`а интересует лишь есть или нет ключ в файле. Однако, при использовании поиска для параметров **domains** в маршрутизаторе или **domains** условии ACL, данные сохраняются в переменной ``$domain_data`` и могут быть использованы в других параметрах маршрутизатора или в утверждениях, в той же самой ACL.

* Любое имя типа одноключевого поиска может претворяться частью ``<n>-``, где ``<n>`` необязательно, например::
  
      domains = partial-dbm;/partial/domains

  Это вызывает частично-соответствующую логику; описание как это работает, дано в разделе :ref:`9.7 <ch09_07>`.

* Любой из одноключевых поисков может сопровождаться звёздочкой. Это вызывает поиск значения по умолчанию для ключа содержащего единственную звёздочку, если первоначальный поиск неудачен. Это бесполезная особенность при использовании списка доменов для выбора специфического домена (поскольку совпадает любой домен), но это может иметь значение если результат поиска используется через переменную раскрытия ``$domain_data``.

* Если шаблон начинается с имени поиска в стиле запросов, сопровождаемого точкой с запятой (например,  “nisplus;” или “ldap;”), оставшаяся часть шаблона должна быть соответствующим запросом для поиска, как описано в главе :ref:`9 <ch09_00>`. Например::
  
      hold_domains = mysql;select domain from holdlist \
        where domain = '$domain';


  В большинстве случаев, данные поиска не используются (так, для SQL-запроса, к примеру, не имеет значения выбираемое поле). Exim интересуется лишь тем, успешен запрос или нет. Однако, при использовании поиска в параметрах **domains** в маршрутизаторе, данные сохраняются в переменной ``$domain_data`` и могут быть использованы в других параметрах.

* Если ни один из вышеупомянутых случаев не применяется, производится регистронезависимое текстовое сравнение между шаблонами и доменом.

Вот пример, использующий несколько различных видов шаблонов::

    domainlist funny_domains = \
      @ : \
      lib.unseen.edu : \
      *.foundation.fict.example : \
      \N^[1-2]\d{3}\.fict\.example$\N : \
      partial-dbm;/opt/data/penguin/book : \
      nis;domains.byname : \
      nisplus;[name=$domain,status=local],domains.org_dir

Тут очевидна обработка в различных режимах соответствия. Использование звёздочки быстрей чем регулярного выражения (имеется ввиду по трудоёмкости, т.е. процессорным ресурсам)и внесение в список нескольких имён, очевидно тоже. Использование поиска по БД или файлу - дорого (опять-таки - по процессорному времени), но это может оказаться единственным вариантом, если используются сотни имён. Поскольку шаблоны проверяются по порядку, имеет смысл поместить самые вероятные (совпадающие чаще всего) выше.

.. _ch10_09:

-------------
Списки хостов
-------------

Списки хостов используются для контроля, что можно делать удалённым хостам. Например, некоторым хостам можно разрешить релей через локальную машину, и некоторым может быть разрешено использовать команду SMTP ETRN. Хосты могут быть идентифицированы двумя различными путями, по имени или по IP-адресу. В списке хостов некоторые типы шаблонов совпадают с именем хоста, и некоторые совпадают с IP-адресом. Вы должны быть особенно осторожны при использовании одноключевых поисков, и гарантировать что используется правильный ключ.

.. _ch10_10:

---------------------------------
Специальные шаблоны списка хостов
---------------------------------

Если элемент списка хостов - пустая строка, то она совпадает только когда не используется удалённый хост. Так происходит при получении сообщения от локального процесса используя SMTP на стандартном вводе, т.е. когда не используется соединение TCP/IP. 

Специальный шаблоном “*” в списке хостов совпадает с любым хостом, или ни с каким хостом (наверное, имеется ввиду то самое подключение без TCP/IP, от локальных процессов). Фактически, ни имя ни Ip-адрес не просматриваются.

.. _ch10_11:

-----------------------------------------------
Шаблоны списка хостов, совпадающие с IP-адресом
-----------------------------------------------

Если хост IPv4 соединяется с хостом IPv6 и запрос принимается на сокет IPv6, входящий адрес на хосте IPv6 фигурирует как ``::ffff:<v4address>``. Когда такой адрес проверяется в списке хостов, он сначала преобразуется в традиционный адрес IPv4. (Не все операционные системы принимают вызовы IPv4 на сокеты IPv6, поскольку были проблемы с безопасностью.)

Следующие типы шаблонов в списках хостов проверяют удалённый хост, просматривая его IP-адрес:

* Если шаблон - просто имя домена (не регулярное выражение, не начинается с ``*``, не является разновидностью поиска), Exim вызывает функцию операционной системы для нахождения ассоциации с IP-адресом (или адресами). По возможности, он использует функцию ``getipnodebyname()``, если же она недоступна, то ``gethostbyname()``. Обычно, она вызывает поиск в DNS. Результат сравнивается с IP-адресом хоста.

  Если происходит временная проблема (типа таймаута DNS) при поиске имени хоста, происходит временная ошибка. Например, если список начинается с использования условия ACL, то ACL даёт “задерживающий” (“defer”) ответ, обычно приводящий к временной ошибке SMTP. Что происходит при невозможности найти адрес для имени хоста, описано ниже, в разделе :ref:`10.14 <ch10_14>`.

* Если шаблон - “@”, он заменяется первичным именем хоста, и используется как имя домена, как описано.

* Если шаблон - IP-адрес, он сравнивается с IP-адресом хоста. Адреса IPv4 даются в нормальной нотации “пунктирной четвёрки”. Адреса IPv6 можно использовать в формате с двоеточием в качестве разделителя, но двоеточия должны быть удвоены, чтобы они не были приняты за разделитель, при использовании разделителя по умолчанию. Адреса IPv6 распознаются даже когда Exim собран без поддержки IPv6. Это означает, что если они фигурируют в списке хостов только для IPv4, Exim не станет из обрабатывать как имена хостов. Они - лишь адреса, которые никогда не совпадают с хостом клиента.

* Если шаблон - “@[]”, он совпадает с IP-адресом любого интерфейса локального хоста. Например, если локалхост - хост IPv4 с одним адресом интерфейса 10.45.23.56, эти две ACL будут иметь одинаковый эффект::
  
      accept hosts = 127.0.0.1 : 10.45.23.56
      accept hosts = @[]

* Если шаблон - IP-адрес со слешем и маской сети (например 10.11.42.0/24), он совпадает с IP-адресом хоста при такой маске. Это позволяет включать целую сеть хостов одним пунктом. Маска используется в CIDR-нотации; это задаёт число битов адреса, которые должны совпадать, начиная с конца адреса.

  .. note:: Маска - это не число адресов, при этом это не самое большое число диапазона адресов. Это число битов в сетевой части адреса. Вышеупомянутый пример определяет 24-х битовую сетевую маску, таким образом она совпадает с 256 адресами в сети 10.11.42.0. Элемент типа::

          192.168.23.236/31
  
    совпадает лишь с двумя адресами, 192.168.23.236 и 192.168.23.237. Маска со значением 32 для адреса IPv6 - тоже самое что её отсутствие; такому элементу соответствует единственный адрес.

  Вот другой пример, показывающий сети IPv4 и IPv6::
  
      recipient_unqualified_hosts = 192.168.0.0/16: \
                                    3ffe::ffff::836f::::/48

  Удвоение разделителей списка применяется лишь в случае когда эти элементы используется внутри строки списка хостов. Это не требуется при задании их внутри файла. Например::
  
      recipient_unqualified_hosts = /opt/exim/unqualnets

  может использовать файл содержащий
  
  ::
  
      172.16.0.0/12
      3ffe:ffff:836f::/48


                                             
  и будет иметь точно такой же эффект как и предыдущий пример. При использовании адресов IPv6 внутри строки, обычно более удобно использовать изменение символа разделителя. Такой список содержит теже самые две сети::
  
      recipient_unqualified_hosts = <; 172.16.0.0/12; \
                                       3ffe:ffff:836f::/48



  Разделитель изменён на точку запятой использованием “<;” в начале списка.

.. _ch10_12:

-------------------------------------------------------------
Шаблоны списка хостов для одноключевого поиска по имени хоста
-------------------------------------------------------------

Когда хост идентифицируется по одноключевому поиску его полного IP-адреса, Шаблон принимает такой вид::

    net-<single-key-search-type>;<search-data>

Например::

    hosts_lookup = net-cdb;/hosts-by-ip.db

Текстовая форма Ip-адреса хоста используется как ключ поиска. Адреса IPv6 конвертируются к несокращённой форме, с использованием строчных букв, с точками в качестве разделителей, поскольку двоеточие - ограничитель ключа в файлах **lsearch**. [Двоеточия могут использоваться в внутри ключа в файлах **lsearch**, если пометить ключ в кавычки, но это было добавлено позже.] Данные возвращённые поиском не используются.

Одноключевые поиски также могут выполняться с использованием IP-адресов с маской, используя шаблон такой формы::

    net<number>-<single-key-search-type>;<search-data>

Например::

    net24-dbm;/networks.db


Ip-адрес хоста замаскирован используя ``<number>`` в качестве длинны маски. Текстовая строка создаётся из скрытого маской значения, сопровождаемого маской, и это иcпользуется как ключ поиска. Например, если у хоста IP-адрес 192.168.34.6, то ключ для вышеупомянутого примера - “192.168.34.0/24”.

Когда адреса IPv6 конвертируются в строку, обычно, вместо двоеточия используются точки, таким образом, ключи в файлах **lsearch** не должны не должны содержать двоеточий (которые используются для завершения ключей **lsearch**). Это было реализовано за некоторое время, до того как в файлах **lsearch** появилась возможность использовать кавычки. Тем не менее, последние реализации файлов **lsearch** требуют двоеточий в IPv6 ключах (обозначенных кавычками), для того чтобы отличичать их от ключей IPv4. По этой причине, когда тип поиска - **iplsearch**, адреса IPv6 конвертируются, используя двоеточия, а не точки. Во всех случаях, всегда используются полные адреса IPv6, а не аббревиатуры.

В идеале, неплохо было бы убрать все эти аномальные ситуации, путём изменения двоеточий во всех случаях, поскольку теперь квотирование (помещение в кавычки) доступно для **lsearch**. Однако, это было бы несовместимым изменением, сломавшим бы некоторые работающие конфигурации.

.. warning:: Специфические ``net32-`` (для адреса IPv4) или ``net128-`` (для адреса IPv6), не тоже самое что и специфическое ``net-`` без номера. В предыдущем случае ключевые строки включают значение маски, тогда как в последнем IP-адрес используется самостоятельно.

.. _ch10_13:

------------------------------------------------
Шаблоны списка хостов совпадающие по имени хоста
------------------------------------------------

Существует несколько типов шаблонов, требующих, чтобы Exim знал имя удалённого хоста. Они являются подстановочными шаблонами или поиском по имени. (Если полное имя хоста даётся без какого-либо подстановочного знака, оно используется для поиска соответствующего IP-адреса, как описано выше, в разделе :ref:`ch10_11`.)

Если при столкновении Exim`a с одним из этих шаблонов, удалённое имя хоста неизвестно, оно будет найдено по IP-адресу. Хотя многие сервера интернета являются вполне добросовестными, и имеют обратные DNS-записи, есть много хостов у которых её нет [#]_. Следовательно, имя не всегда может быть найдено, и это может привести к нежелательным эффектам. Позаботьтесь об этом при конфигурировании списков хостов с подстановочными шаблонами. Рассмотрите вариант, если имя не может быть найдено.

Из-за проблем с разрешением имён хостов по IP-адресам, соответствие имён хостов не такое же как совпадение IP-адресов.

По-умолчанию, для нахождения имени хоста, Exim делает обратный DNS-поиск; если в DNS имя не найдено, пробуются системные функции ``gethostbyaddr()`` или ``getipnodebyaddr()`` - какая доступна. Порядок, в котором производится поиск, может быть изменён установками параметров **host_lookup_order**. Для безопасности, как только Exim находит одно или несколько имён, он ищет адрес IP адреса для этих имён и сравнивает их с IP адресами с которых начал. Принимаются лишь те адреса, чьи IP адреса совпадют. Любые другие имена отбрасываются. Если имена отстутсвуют, Exim ведёт себя так, как будто имя хоста не может быть найдено. В большинстве случаев, бывает лишь одно имя и один IP адрес.

Есть несколько параметров управляющих поведением в случае, если имя хоста не найдено. Они описаны ниже, в разделе :ref:`10.14 <ch10_14>`.

В результате подстановки синонима, хосты могут иметь более одного имени. При обработке любого из следующих типов шаблонов, все имена хостов проверяются:

* Если шаблон начинается с “*”, остаток элемента должен соответствовать концу имени хоста. Например, ``*.b.c`` совпадает со всеми хостами, имена которых заканчивается на ``.b.c``. Эта специальная простая форма используется, поскольку она очень часто необходима. Другие виды подстановок требуют использования регулярных выражений.

* Если элемент начинается с “^”, то это берётся как регулярное выражение которое сравнивается с именем хоста. Имя хоста регистронезависимо, таким образом, это регулярное выражение, по уполчанию, регистронезависимо, но вы можете сделать его регистрозависимым, начав его с ``(?-i)``. Ссылки на описание синтаксиса регулярных выражений даны в главе `8 <ch08_00>`. Например::

      ^(a|b)\.c\.d$

  является регулярным выражением, совпадающим с двумя хостами ``a.c.d`` или ``b.c.d``. Когда регулярное выражение используется в списке хостов, вы должны позаботится о том, чтобы обратный слэш (“\”) и символ доллара (“$”) не были неверно восприняты как часть раскрытия строки. Самый простой способ избежать этого - использовать ``\N`` для того чтобы отметить нужную часть строки как не раскрываемую::
  
      sender_unqualified_hosts = \N^(a|b)\.c\.d$\N : ....

  .. warning:: Если вы хотите соответствия полному имени хоста, то вы должны включить символ “$” - закрывающий метасимвол в регулярном выражении, как в вышеупомянутом примере. Без этого, будет подходить всё, с совпадаюшим именем хоста.

.. _ch10_14:

----------------------------------------------
Поведение, когда IP-адрес не может быть найден
----------------------------------------------

Когда обрабатывается список хостов, Exim`y может понадобиться найти IP-адрес по имени (смотрите раздел :ref:`10.11 <ch10_11>`), или имя хоста по IP-адресу (смотрите раздел :ref:`10.13 <ch10_13>`). В любом случае, при невозможности найти информацию поведение одинаковое.

..note:: Эта секция применяется к постоянным ошибкам поиска. Она не применяется к временным ошибкам DNS, обработка которых описана в следующей секции.
      
По-умолчанию, Exim ведёт себя так, будто хост не совпадает со списком. Это не всегда совпадает с тем, что вам нужно. Для изменения поведения Exim`a есть специальные элементы - ``+include_unknown`` или ``+ignore_unknown`` которые могут появляться в списке (на верхнем уровне, они не признаются в списках файлов).

* Если любой элемент, который следует ``+include_unknown`` требует информации, которая не может быть найдена, Exim ведет себя так, будто хост соответствует списку. Например,
  ::

      host_reject_connection = +include_unknown:*.enemy.ex

  отклоняет подключения от любых хостов, чьи имена совпадают с ``*.enemy.ex``, и от тех хостов, чьи имена не могут быть найдены.

* Если любой элемент, который следует ``+ignore_unknown`` требует информации, которая не может быть найдена, Exim игнорирует этот пункт и переходит к оставшейся части списка. Например::
  
      accept hosts = +ignore_unknown : friend.example : \
                     192.168.4.5


  принимает [#]_ от любого хоста, имя которого *friend.example*, и от 192.168.4.5, независимо найдено или нет его имя. Без ``+ignore_unknown``, если имя для 192.168.4.5 не найдено, почта отклоняется.
 
Оба элемента, ``+include_unknown`` и ``+ignore_unknown`` могут появляться в одном списке. Эффект от каждого длиться до следующего или до конца списка.

.. _ch10_15:

--------------------------------------------------
Временные ошибки DNS при поиске информации о хосте
--------------------------------------------------

Обычно, временные ошибки DNS приводят к задержке (за исключением, когда параметр **dns_again_means_nonexist** превращает их в постоянные ошибки). Однако, список хостов может включать ``+ignore_defer`` и ``+include_defer``, аналогично ``+ignore_unknown`` и ``+include_unknown``, как описано в предыдущей секции. Эти параметры должны использоваться с осторожностью, предположительно в некритичных списка хостов, типа "белых списков".


.. _ch10_16:

--------------------------------------------------------------
Список шаблонов хостов для одноключевого поиска по имени хоста
--------------------------------------------------------------

Если шаблон имеет форму

::

    <single-key-search-type>;<search-data>

например

::

    dbm;/host/accept/list

то выполняется одноключевой поиск, с использованием имени хоста в качестве ключа. Если поиск успешен, хост совпадает с элементом. Данные, возвращённые поиском, не используются.

.. note:: С этим видом шаблона вы должны иметь имена хостов как ключи в файле, а не IP-адреса. Если вам нужно сделать поиск основанный на Ip-адресах, то необходимо предварить тип поиска префиксом ``net-`` (смотрите раздел :ref:`10.12 <ch10_12>`). Однако, ничто не препятствует вам использовать два элемента в одном списке, один для поиска адреса, другой для поиска имени, с использованием обоими одного и того же файла.

.. _ch10_17:

--------------------------------------------------
Список шаблонов хостов для поиска в стиле запросов
--------------------------------------------------

Если шаблон имеет форму

::

    <query-style-search-type>;<query>

то выполняются запросы, если они успешны, имя хоста совпадает с элементом. Данные, которые искались, не используются. Переменные ``$sender_host_address`` и ``$sender_host_name`` могут использоваться в запросе. Например::

    hosts_lookup = pgsql;\
      select ip from hostlist where ip='$sender_host_address'

Значение переменной ``$sender_host_address`` для адреса IPv6 содержит двоеточия. Если вам необходимо, вы можете использовать элемент раскрытия **sg** для изменения этого. Если хотите использовать адреса с маской, то можете использовать оператор раскрытия **mask**.

Если запрос содержит ссылку на ``$sender_host_name``, Exim автоматически ищет имя хоста, если это не было сделано раньше. (Смотрите раздел :ref:`10.13 <ch10_13>`, для подробностей о поиске имён хостов.)

.. note:: До релиза 4.30, Exim всегда пытался найти имя хоста перед выполнением запроса, если типу поиска не предшествовало ``net-``. Сейчас это не так. Для обратной совместимости, ``net-`` распознаётся при поиске в стиле запроса, но его присутствие или отсутствие не имеет никакого эффекта. (Разумеется, для одноключевых поисков, ``net-`` является важным. Смотрите раздел :ref:`10.12 <ch10_12>`).

.. _ch10_18:

----------------------------------------------------------------
Смешивание подстановочных имён хостов и адресов в списках хостов
----------------------------------------------------------------

Если вы используете поиск имени или подстановочного имени хоста и IP-адреса в одном списке хостов, то вы должны размещать IP-адреса вначале. Например, в ACL вы могли бы иметь::

    accept hosts = 10.9.8.7 : *.friend.example

Причина этого, в том, что Exim обрабатывает списки слева направо. Это позволяет проверить IP-адрес без запроса DNS, а при достижении элемента требующего разрешения имени в адрес происходит ошибка, если невозможно найти имя хоста для сравнения с шаблоном. Если вышеупомянутый список был бы в обратном порядке, утверждение **accept** было бы неудачно для хоста имя которого найти невозможно, даже если его IP адрес 10.9.8.7. 

Если же вам действительно необходимо проверять первыми имена, и продолжить проверять IP-адреса, то вы можете переписать эту ACL таким образом::

    accept hosts = *.friend.example
    accept hosts = 10.9.8.7

Если первый **accept** неудачен, Exim продолжает проверять второе утверждение. Смотрите часть :ref:`40 <ch40_00>`, для получения подробной информации о ACL.


.. _ch10_19:

--------------
Списки адресов
--------------

Списки адресов содержат шаблоны совпадающие с почтовыми адресами. Есть лишь один специальный случай: адрес отправителя для рикошета всегда пустой. Вы можете проверить это, задав пустой элемент в списке адресов. Например, вы могли бы установить параметры маршрутизатора, для обработки рикошетов::

    senders = :

Присутствие двоеточия означает пустой элемент. Если никаких данных нет [#]_, то список пуст и не соответствует вообще ничему. Пустой отправитель также может быть обнаружен регулярным выражением, соответствующим пустой строке, и поиском в стиле запросов, успешному в случае если переменная ``$sender_address`` пуста.

Непустые элементы списка адресов могут быть прямыми адресами электронной почты. Например::

    senders = jbc@askone.example : hs@anacreon.example

Разрешается некоторое число групповых символов (т.е. шаблонов). Если шаблон содержит символ ``@``, но он не регулярное выражение, и не начинается с типа поиска заканчивающегося точкой с запятой (описано ниже), локальная часть адреса сравнивается с локальной частью шаблона, которая может начинаться со звёздочки. Если локальная часть совпадает, проверяется точно таким же образом для шаблона списка доменов. Например, домен может быть безразличным, обращаясь к именованному списку, или быть поиском::

    deny senders = *@*.spamming.site:\
                   *@+hostile_domains:\
                   bozo@partial-lsearch;/list/of/dodgy/sites:\
                   *@dbm;/bad/domains.db


    
Если локальная часть начинается с восклицательного знака, требуется чтобы это было определено как регулярное выражение, поскольку в противном случае восклицательный знак, как обычно в списках, будет воспринят как символ отрицания.

Если непустой шаблон не регулярное выражение, или поиск не содержит символ ``@``, это сравнивается с доменной частью адреса. Так понимаются только два формата - литеральный домен (домен в виде IP-адреса) или шаблон домена начинающийся со звёздочки. В обоих случаях, эффект точно такой же, как будто ``*@`` предшествовала шаблону. Например::

    deny senders = enemy.domain : *.enemy.domain

Следующие виды более сложных видов шаблонов списков адресов могут совпадать с любым адресом, включая пустой адрес, являющийся характеристикой [#]_ отправителей рикошета:

* Если (после раскрытия) шаблон начинается с “^”, регулярное выражение сравнивается с полным адресом, с шаблоном в качестве регулярного выражения. Вы должны позаботится о том, чтобы символы обратного слэша (“\”) и доллара (“$”) не были неправильно восприняты как часть раскрытия строки.Самый простой способ избежать этого - использовать ``\N`` чтобы отметить эту часть строки как не раскрываемую. Например::
  
      deny senders = \N^.*this.*@example\.com$\N : \
                     \N^\d{8}.+@spamhaus.example$\N : ...

  Последовательность ``\N`` удаляется при раскрытии, таким образом элементы действительно начинаются с крышки (“^”), к тому времени как они интерпретируются как шаблон адреса.

* Полные адреса могут искаться с использованием шаблона который с типа поиска завершаемого точкой с запятой, и сопровождаемого данными для поиска. Например::
  
      deny senders = cdb;/etc/blocked.senders : \
        mysql;select address from blocked where \
        address='${quote_mysql:$sender_address}'

  Могут использоваться и одноключевой стиль, и стиль запросов. Для одноключевого типа, Exim использует полный адрес как ключ. Однако, пустые ключи не поддерживаются одноключевым поиском, таким образом, сравнение с пустым адресом всегда будет неудачно. Это ограничение не применяется к поиску в стиле запросов.

  Частичное соответствие для одноключевых поисков (раздел :ref:`9.7 <ch09_07>`) не может использоваться, и игнорируется, если задано, с записью в журнал событий (paniclog). Однако, вы можете сконфигурить параметры поиска по умолчанию, как описано в разделе :ref:`9.6 <ch09_06>`, но это полезно лишь для значений по-умолчанию типа ``*@``. Например, с этим поиском::
  
       accept senders = lsearch*@;/some/file

  файл может содержать строки типа таких::
  
      user1@domain1.example
      *@domain2.example

  и для адреса отправителя *nimrod@jaeger.example* последовательность пробуемых ключей будет::
  
      nimrod@jaeger.example
      *@jaeger.example
      *



  .. warning:: Не включайте строку “*” в ключевой файл, поскольку это означало бы что соответствие любому адресу, делая эту проверку бесполезной.

  .. warning:: Не путайте эти два вида элементов::

          deny recipients = dbm*@;/some/file
          deny recipients = *@dbm;/some/file
       
       Первый, по умолчанию, производит полный поиск адреса, как описано, поскольку он начинается с типа поиска. Второй сравнивается с локальной и доменной частью независимо, как описано ниже.

Следующие виды шаблонов списков адресов могут совпадать лишь с непустыми адресами. Если адрес пуст, сравнение с любым из этих типов шаблонов неудачно.

* Если шаблон начинается с ``@@`` сопровождаемых элементом одноключевого поиска (например ``@@lsearch;/some/file``), проверяемый адрес разбивается на локальную и доменную части. Домен ищется в файле. Если он там не найден, в этом пункте нет соответствий. Если он найден, найденные в файле данные обрабатываются как список шаблонов локальных частей, разделённых двоеточиями, каждый из которых, по очереди, сравнивается с локальной частью.

  Поиск может быть частичным, и/или одним относящимся к поиску с ключом по умолчанию “*” (смотрите раздел :ref:`9.6 <ch09_06>`). Искомая локальная часть шаблона, может быть регулярным выражением, или начинаться с “*”, или даже к будущему поиску. Также, они могут быть независимо инвертированы. Например::
  
        deny senders = @@dbm;/etc/reject-by-domain

  данные из DBM файла, могли бы содержать строки::
  
        baddomain.com:  !postmaster : *
        
  для отклонения всех отправителей, кроме “postmaster” из этого домена.
 
  Если требуется, чтобы локальная часть, начиналась с восклицательного знака, это должно быть определено с использованием регулярного выражения. В файлах **lsearch**, отдельные записи могут быть разбиты на несколько строк, для выравнивания, но разделяющие двоеточия всё ещё могут включаться в перевод строки. Пустое место вокруг двоеточий игнорируется. Например::
  
         aol.com:  spammer1 : spammer2 : ^[0-9]+$ :
         spammer3 : spammer4

  Как и во всех списках Exim`a, разделённых двоеточиями, двоеточие может быть включено в элемент, путём его (двоеточия) удвоения.

  Если последний элемент списка начинается с правой угловой скобки (“>”), остаток элемента берётся как новый ключ поиска для получения списка продолжения локальных частей. Новый ключ может быть последовательностью символов. Таким образом можно иметь такие вхождения в файле::
  
         aol.com: spammer1 : spammer 2 : >*
         xyz.com: spammer3 : >*
         *:       ^\d{8}$

  в файле который ищется с ``@@dbm*``, для задания совпадения с 8-цифровой локальной частью для всех доменов, в дополнение к специфическим локальным частям перечисленным для каждого домена. Конечно, использование этой особенности стоит другого поиска каждый раз когда цепочка сопровождается [#]_, но целью было уменьшить нагрузку.

  При использовании этого средства, возможно создание петель, и для того чтобы их выявить, цепочки не могут содержать более пятидесяти элементов.

* Стиль ``@@<lookup>`` элемента может использоваться для поиска в стиле запросов, но в этом случае, средство цепочек недоступно. Поиск может вернуть только один список локальных частей.

  .. warning:: есть важное различие между элементами списка адресов в этих двух примерах::

         senders = +my_list
         senders = *@+my_list

    В первом, ``my_list`` является именованным списком адресов, тогда как во втором примере - именованный список доменов.


.. _ch10_20:

------------------------------
Регистр букв в списках адресов
------------------------------

Домены в e-mail адресах всегда обрабатываются регистронезависимо, но для локальных частей, на некоторых системах, это может быть существенно (смотрите **caseful_local_part** для разъяснения того, как Exim работает с этими адресами при маршрутизации). Однако, :rfc:`2505` (“Anti-Spam Recommendations for SMTP MTAs” - антиспамовые рекомендации для SMTP MTA) предлагает чтобы соответствие адресов спискам заблокированных было сделано в регистронезависимой маненре. Так как большинство списков адресов в Exim`e используется для этого вида управления, Exim пытается сделать это [#]_ по-умолчанию.
   
Доменная часть адреса всегда переводится в нижний регистр до сравнения её со списком адресов. Локальная часть, по умолчанию, переводится в нижний регистр, и любые производимые сравнения строки делаются регистронезависимо. Это значит, что данные могут быть непосредственно в списках адресов, в файлах включаемых простые имена файлов, и в любых файлах в которых производится поиск с использованием механизма ``@@``, могут быть в любом регистре. Однако, ключи в файлах, поиск в которых производится по типу отличному от **lsearch** (который выполняется регистронезависимо), должны быть в строчных буквах, поскольку в них поиск регистрозависим.

Для разрешения регистрозависимого совпадения в списках адресов, если элемент списка адресов является строкой ``+caseful``, оригинальный регистр локальной части восстанавливается для любого проводимого сравнения, и сравнения строк становятся регистрозависимы. Это не затрагивает домен, остающийся в нижнем регистре. Однако, хотя независимые сравнения доменов остаются регистронезависимы, регулярные выражения производящие сравнение со всем адресом, становятся  регистрозависимыми после того, как был обнаружен пункт ``+caseful``.

.. _ch10_21:

-----------------------
Списки локальных частей
-----------------------

Чувствительность к регистру в списках локальных частей обрабатывается таким же образом для списков адресов, как только что описано. Элемент ``+caseful`` может использоваться, по необходимости. В установке параметра **local_parts** в маршрутизаторе с установленным в ``false`` пунктом **caseful_local_part** адрес в строчных буквах и изначально сравнивается регистронезависмо. В этом случае, ``+caseful`` восстановит регистрозависимое сравнение в списках локальных частей, но не в других местах маршрутизатора. Если в маршрутизаторе параметр **caseful_local_part** установлена в ``true``, сравнение в параметре **local_parts** регистрозависимо с начала маршрутизатора.

Если список локальных частей расположен в файле (смотрите раздел :ref:`10.3 <ch10_03>`), комментарии обрабатываются также как и списки адресов - они распознаются лишь в случае, если символу “#” предшествует пустой символ, или символ начала новой строки. Иначе, списки локальных частей сравниваются точно также как и списки доменов, за исключением специальных элементов относящихся к локальному хосту (``@``, ``@[]``, ``@mx_any``, ``@mx_primary`` и ``@mx_secondary``) которые не распознаются. Обратитесь к разделу :ref:`10.8 <ch10_08>` для получения дополнительных деталей о других доступных типах элементов.

.. [#] прим. lissyara: иногда очень проблематично добиться от провайдера обратной записи, обусловлено это, по моему, тем что там работают люди понятия не имеющие как её прописать
.. [#] почту, видимо :))
.. [#] в смысле, не было бы даже двоеточия - прим. lissyara
.. [#] видимо, признаком - прим. lissyara
.. [#] видимо, символом “>” - прим. lissyara
.. [#] регистронезависимый поиск, видимо - прим. lissyara
