
.. _ch34_00:

Аутентификатор **plaintext**
============================

Аутентификатор **plaintext** может быть сконфигурирован для поддержки аутентификационных механизмов PLAIN и LOGIN, оба которые передают аутентификационные данные в виде открытого (не зашифрованного) текста (хотя и кодированного base64). Использование открытого текста - риск для безопасности; настоятельно рекомендуем на использовании SMTP-шифрования (смотрите главу :ref:`39 <ch39_00>`), если вы используете механизмы PLAIN и LOGIN. Если вы используете открытый текст, то вы не должны использовать для SMTP-подключений те же самые пароли, что и для учётных записей пользователей [#]_.

.. _ch34_01:

Параметры **plaintext**
-----------------------

При настройке сервера, **plaintext** имеет следующие параметры:

.. index::
   triple: authenticators; plaintext; server_condition

====================  ===================  =============  ==============
**server_condition**  Use: authenticators  Type: string†  Default: unset
====================  ===================  =============  ==============

Фактически, это глобальная аутентификационный параметр, но, она может быть установлена для настройки драйвера **plaintext** как сервера. Её использование описано ниже.

.. index::
   pair: plaintext; server_prompts

==================  ==============  =============  ==============
**server_prompts**  Use: plaintext  Type: string†  Default: unset
==================  ==============  =============  ==============

Содержимое этого параметра, после раскрытия, должно быть списком строк подсказок, разделённых двоеточиями. Если раскрытие неудачно, даётся временное отклонение аутентификации.

.. _ch34_02:

Использование **plaintext** в сервере
-------------------------------------

При работе в качестве сервера, **plaintext** выполняет тест аутентификации путём раскрытия строки. Данные посылаются клиентом с командой AUTH, или в ответе на последующие подсказки, закодированные по base64, таким образом, после декодирования они могут содержать любые символы. Если с командой предоставляются какие-то данные, они рассматриваются как список строк, разделённых NUL (бинарным нулём), первые три из которых помещаются в переменные раскрытия $auth1, $auth2 и $auth3 (ни LOGIN ни PLAIN не используют более чем три строки).

Для совместимости с предыдущими версиями Exim`a, значения, также, помещаются в переменные раскрытия $1, $2 и $3. Однако, использование этих переменных с этой целью, сейчас, осуждается, поскольку оно может привести к беспорядку в раскрытиях строк, которые также их используют для других целей.

Если в **server_prompts** находится больше строк, чем переданных с командой AUTH, остающиеся подсказки используются для получения дополнительных данных. Каждый ответ клиента может быть списком строк, разделённых NUL-символами.

Как только получено достаточное число строк данных, раскрывается **server_condition**. Если раскрытие принудительно неудачно, аутентификация не пройдена. Любые другие ошибки аутентификации вызывают возврат временного кода ошибки. Если результат успешного раскрытия - пустая строка,  “0”, “no”, или “false”, - аутентификация неудачна. Если результат раскрытия - “1”, “yes”, или “true”, - аутентификация успешна, и раскрывается общий параметр **server_set_id**, и сохраняется в $authenticated_id. Для любого другого результата, возвращается временный код ошибки, с раскрытой строкой в качестве текста ошибки.

.. warning:: Если вы используете, для нахождения пароля пользователя, поиск в раскрытии - убедитесь, что сделали неудачу аутентификации, если пользователь неизвестен. В конце следующего раздела есть хорошие и плохие примеры.

.. _ch34_03:

Аутентификационный механизм PLAIN
---------------------------------

Аутентификационный механизм PLAIN (:rfc:`2595`), определяет, что три строки посылаются как один элемент данных (т.е. одна, комбинированная строка, содержащая два NUL-разделителя). Данные посылаются или как часть команды AUTH, или впоследствии, в ответе на пустую подсказку сервера.

Вторая и третья строки - имя пользователя и соответствующий пароль. Используя одно фиксированное имя пользователя и пароль, как пример, это могло бы быть сконфигурировано следующим образом::

    fixed_plain:
      driver = plaintext
      public_name = PLAIN
      server_prompts = :
      server_condition = \
        ${if and {{eq{$auth2}{username}}{eq{$auth3}{mysecret}}}}
      server_set_id = $auth2

Отметьте, что по-умолчанию результирующая строка из “if” (“true” или пустая строка) в точности то что мы тут хотим, таким образом, она должна быть не задана. Очевидно, если пароль содержит символы зависимые от раскрытия, например - доллар, обратный слэш, или закрывающую скобку, они будут экранированы.

Установка **server_prompts** задаёт единственную, пустую подсказку (пустые элементы в конце списка строки - игнорируются). Если все данные прибывают как часть команды AUTH, как обычно и бывает, - подсказка не используется. Об этом аутентификаторе извещается в ответе на EHLO

::

    250-AUTH PLAIN

и клиентский хост может аутентифицироваться путём посыла команды

::

    AUTH PLAIN AHVzZXJuYW1lAG15c2VjcmV0

Поскольку тут содержится три строки (больше чем число подсказок), от клиента не требуется больше данных. Альтернативно, клиент может лишь послать

::

    AUTH PLAIN

для начала аутентификации, в этом случае сервер отвечает пустой подсказкой. Клиент должен ответить комбинированной строкой данных.

Строка данных - закодирована base64, как требуется по RFC. Этот пример, после расшифровки, - *<NUL>username<NUL>mysecret*, где *<NUL>* - нулевой байт. Она разделяется на три строки, первая из которых - пустая. Параметр **server_condition**, в проверках аутентификаторов, что вторые две - *username* и *mysecret* - соответствуют.
                                
Наличие лишь одного фиксированного имени пользователя и пароля, как в этом примере, - не очень реалистично, хотя, для маленькой организации, с горсткой аутентифицируемых клиентов, - это могло бы иметь смысл.

Более сложный случай этого аутентификатора может использовать имя пользователя в $auth2, для поиска пароля в файле, или БД, и, возможно, делать шифрованное сравнение (смотрите **crypteq**, в главе :ref:`11 <ch11_00>`). Вот - пример этого подхода, где пароли ищутся в DBM-файле. 

.. warning:: Это - неправильный пример

:: 

    server_condition = \
      ${if eq{$auth3}{${lookup{$auth2}dbm{/etc/authpwd}}}}

Раскрытие использует имя пользователя ($auth2), как ключ для поиска пароля, который, затем, сравнивается с переданным паролем ($auth3). Почему этот пример неправилен? Он прекрасно работает для существующих пользователей, но рассмотрим, что происходит если даётся имя несуществующего пользователя. Поиск неудачен, но поскольку для поиска не даны строки удачи/неудачи, он приводит к пустой строке. Таким образом, чтобы обойти аутентификацию, все клиенты должны предоставлять несуществующее имя пользователя, и пустой пароль. Корректный способ написать эту проверку::

    server_condition = ${lookup{$auth2}dbm{/etc/authpwd}\
      {${if eq{$value}{$auth3}}} {false}}

В этом случае, если поиск успешен, результат проверяется; если поиск неудачен, возвращается “false” и аутентификация неудачна. Если вместо **eq** используется **crypteq**, первый пример, фактически, безопасен, поскольку **crypteq** всегда неудачна, если второй аргумент пуст. Однако, второй способ написания проверки, делает логику более понятной.

.. _ch34_04:

Аутентификационный механизм LOGIN
---------------------------------

Аутентификационный механизм LOGIN не задокументирован в каком-либо RFC, но - он используется множеством программ. С командой AUTH никаких данных не посылается. Вместо этого, имя пользователя и пароль даются раздельно, в ответах на подсказки. Аутентификатор **plaintext** может быть сконфигурирован для поддержки этого, как в этом примере::

    fixed_login:
      public_name = LOGIN
      server_prompts = User Name : Password
      server_condition = \
        ${if and {{eq{$auth1}{username}}{eq{$auth2}{mysecret}}}}
      server_set_id = $auth1

Поскольку работает **plaintext**, этот аутентификатор принимает данные предоставленные с командой AUTH (в нарушение спецификации LOGIN), но, если клиент не предоставляет их (как в случае LOGIN клиентов), строка подсказки используется для получения двух элементов данных.

Некоторые клиенты очень следят за точным текстом подсказок. Например, Outlook Express, как сообщают, распознаёт только “Username:” и “Password:”. Вот - пример аутентификатора LOGIN, использующего эти строки. Они использует условие раскрытия **ldapauth**, для проверки имени пользователя и пароля, путём связи с LDAP-сервером::

    login:
      driver = plaintext
      public_name = LOGIN
      server_prompts = Username:: : Password::
      server_condition = ${if and{{
        !eq{}{$auth1} }{ \
        ldapauth{user="cn=${quote_ldap_dn:$auth1},ou=people,o=example.org" \
        pass=${quote:$auth2} \
        ldap://ldap.example.org/} }} }
      server_set_id = uid=$auth1,ou=people,o=example.org

Мы делаем проверку что имя пользователя не пустое до его использования, поскольку LDAP не разрешает пустые компоненты DN. Также, мы должны использовать оператор **quote_ldap_dn** для корректного квотирования DN для аутентификации. Однако, базовый оператор **quote**, а не любой из операторов квотирования LDAP, явялется правильным при использовании для пароля, поскольку квотирование необходимо лишь для того, чтобы пароль соответствовал синтаксису Exim'a. На уровне LDAP, пароль - не интерпретируемая строка.

.. _ch34_05:

Поддержка для иных видов аутентификации
---------------------------------------

Множество особенностей раскрытия строк предоставлены как интерфейс к иным способам аутентификации пользователей. Они включают проверку традиционно зашифрованных паролей */etc/passwd* (или эквивалент), PAM, Radius, **ldapauth**, *pwcheck*, and *saslauthd*. Для дополнительных деталей смотрите раздел :ref:`11.7 <ch11_07>`.

.. _ch34_06:

Использование **plaintext** как клиента
---------------------------------------

Аутентификатор **plaintext** имеет два клиентских параметра:

============================  ==============  =============  ==============
client_ignore_invalid_base64  Use: plaintext  Type: boolean  Default: false
============================  ==============  =============  ==============

Если клиент получает подсказку сервера не являющуюся допустимой base64 строкой, оставляется аутентификация по-умолчанию. Однако, если этот параметр установлен в истину, ошибка в вызове игнорируется, и клиент посылает обычный ответ.

===========  ==============  =============  ==============
client_send  Use: plaintext  Type: string†  Default: unset
===========  ==============  =============  ==============

Строка - список разделённых двоеточиями строк аутентификационных данных. Каждая строка независимо раскывается до отправки на сервер. Первая строка - посылается с командой AUTH; дополнительные строки посылаются на подсказки сервера. До раскрытия каждой строки, значение новой подсказки помещается в следующую переменную $auth<n>, начинающихся с $auth1, для первой подсказки. Этим способом сохраняется вплоть до трёх подсказок. Таким образом, подсказка полученная в ответ на отправленную первую строку (с командой AUTH), может быть использована в раскрытии второй строки, и так далее. Если получена недопустимая base64 строка при установленном параметре **client_ignore_invalid_base64**, в переменную $auth<n> помещается пустая строка.


.. note:: Вы не можете использовать раскрытия для создания нескольких строк, поскольку у разбиения приоритет выше и оно происходит раньше.

Поскольку аутентификационный механизм PLAIN требует байт NUL (бинарный ноль) в данных, к каждой строке до её отправки применяется дальнейшая обработка. Если в строке есть символы крышки (^), они конвертируются в NUL. Если в строке требуется крышка как данные, символ должен быть удвоен в строке.

Это - пример клиентской конфигурации, которая воплощает аутентификационный механизм PLAIN с фиксированным именем пользователя и паролем::

    fixed_plain:
      driver = plaintext
      public_name = PLAIN
      client_send = ^username^mysecret

Нехватка двоеточий означает, что весь текст посылается с командой AUTH, с символами крышки преобразованными в NUL. Подобный пример, использующий механизм LOGIN::

    fixed_login:
      driver = plaintext
      public_name = LOGIN
      client_send = : username : mysecret

Начальное двоеточие означает, что первая строка пустая, таким образом, с командой AUTH никаких данных не посылается. Оставшиеся строки посылаются в ответ на подсказки.


.. [#] имеются ввиду системные учётки - чтоб не могли перехватить и залогинится - прим. lissyara
