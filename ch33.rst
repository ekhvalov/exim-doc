
.. _ch33_00:

SMTP-аутентификация
===================

Секция “authenticators”, рабочей конфигурации Exim'a, управляет SMTP-аутентификацией. Это средство - расширение протокола SMTP, описанное в :rfc:`2554`, которое разрешает клиентскому SMTP-хосту атентифицироваться на сервере. Это - обычный серверный способ распознавать клиентов, которым разрешено использовать его как релей. SMTP-аутентификация неуместна для передачи почты между серверами которые организационно никак не связаны друг с другом.

Вкратце, способ работы SMTP-аутентификации таков:

* Сервер информирует число аутентифкационных механизмов (mechanisms) в ответе на клиентскую команду EHLO.
  
* Клиент выдаёт команду AUTH, именуя специфический механизм. Команда может, не обязательно, содержать какие-либо аутентификационные данные.
  
* Сервер может выдать один или более вызовов [#]_, на которые клиент должен послать соответствующие ответы. В простых опознавательных механизмах, вызовы - просто запросы имён пользователей и паролей. Сервер не должен выдавать каких-либо вызовов - в некоторых механизмах, все уместные данные могут быть переданы с командой AUTH.

* Сервер или принимает, или отклоняет аутентификацию.
   
* Если аутентификация успешна, клиент, не обязательно, может использовать gfhfvtnh AUTH в команде MAIL для передачи аутентифицированного (заверенного) отправителя в последующих почтовых транзакциях. Аутентификация остаётся до конца SMTP-соединения.
  
* Если аутентификация неудачна, клиент может отключиться, или может попробовать другой аутентификационный механизм, или может попробовать передать почту по неаутентифицированному соединению.

* Если вы настраиваете клиента, и хотите знать, какие аутентификационные механизмы поддерживает сервер, вы можете использовать telnet для соединения с 25 портом (порт SMTP) на сервере, и выдать команду EHLO. Ответ на неё включает список поддерживаемых механизмов. Например:

  ::
  
      $ telnet server.example 25
      Trying 192.168.34.25...
      Connected to server.example.
      Escape character is '^]'.
      220 server.example ESMTP Exim 4.20 ...
          ehlo client.example
          250-server.example Hello client.example [10.8.4.5]
          250-SIZE 52428800
          250-PIPELINING
          250-AUTH PLAIN
          250 HELP

Предпоследняя линия этого примера, показывает, что сервер поддерживает аутентификацию с использованием механизма PLAIN. В Exim`e, различные аутентификационные механизмы настраиваются путём специфических драйверов *authenticator*. Как у маршрутизаторов и транспортов, то, какие аутентификаторы включены в исполняемый файл, определяется при сборке. В настоящее время, доступны следующие установки:: 

    AUTH_CRAM_MD5=yes
    AUTH_CYRUS_SASL=yes
    AUTH_PLAINTEXT=yes
    AUTH_SPA=yes


в *Local/Makefile*, соответственно. Первая из этих поддержек аутентификационный механизм CRAM-MD5 (:rfc:`2195`), второй предоставляет интерфейс к аутентификационной библиотеке Cyrus SASL. Третий может быть сконфигурирован для поддержки аутентификационного механизма PLAIN (:rfc:`2595`), или механизма LOGIN, который формально не зарегистрирован, но используется несколькими MUA. Четвёртый аутентификатор поддерживает механизм Microsoft’овский “Secure Password Authentication”.

Аутентификаторы конфигурируются с использованием того же синтаксиса, что и другие драйверы (смотрите раздел :ref:`6.22 <ch06_22>`). Если аутентификаторы не требуются, аутентификационная секция в конфигурационном файле не требуется. Каждый аутентификатор, в принципе, может иметь и клиентские и серверные функции. Когда Exim принимает почту по SMTP, он работает как сервер, когда он шлёт сообщения наружу через SMTP - он выступает в роли клиента. Конфигурационные параметры аутентификатора предоставляют возможность использования обоих этих обстоятельств.

Для прояснения, какой параметр к какой ситуации применяется, в именах параметров используются префиксы **server_** и **client_**, определяющие серверные или клиентские функции, соответственно. Серверные и клиентские функции отключены, если не установлен ни один из вариантов. Если аутентификатор должен использоваться для обоих, серверных и клиентских функций, в одном определении, требуется использование обоих установок параметров. Например::

    cram:
      driver = cram_md5
      public_name = CRAM-MD5
      server_secret = ${if eq{$auth1}{ph10}{secret1}fail}
      client_name = ph10
      client_secret = secret2


Параметры **server_** используется когда Exim выступает в роли сервера, и **client_** - когда он выступает в роли клиента.

Описания индивидуальных аутентификаторов даны в последующих главах. Оставшаяся часть этой главы охватывает общие параметры для аутентификаторов, сопровождаемые общим обсуждением о способе работы аутентификации в Exim`e.

.. _ch33_01:

Общие параметры для аутентификаторов
------------------------------------

.. index::
   pair: authenticators; client_condition

====================  ===================  =============  ==============
**client_condition**  Use: authenticators  Type: string†  Default: unset
====================  ===================  =============  ==============

Когда Exim аутентифицируется как клиент, он пропускает любые аутентификаторы чьё раскрытие приводит к “0” или “false”. Это может быть использовано, например, для пропуска аутентификатора с открытым текстом, когда соединение незашифровано, путём такой установки::

    client_condition = ${if !eq{$tls_cipher}{}}

(Старая документация некорректно указывает, что $tls_cipher содержит шифрование используемое для входящих сообщений. Фактически, в процессе SMTP доставки, она содержит шифр используемый для доставки.)

.. index::
   pair: authenticators; driver

==========  ===================  ============  ==============
**driver**  Use: authenticators  Type: string  Default: unset
==========  ===================  ============  ==============

Этот параметр всегда должен быть установлен. Он определяет, какой из доступных аутентификаторов должен использоваться.

.. index::
   pair: authenticators; public_name

===============  ===================  ============  ==============
**public_name**  Use: authenticators  Type: string  Default: unset
===============  ===================  ============  ==============

Этот параметр определяет имя аутентификационного механизма, который принадлежит драйверу, и путём которого он известен внешнему миру. Эти имена должны содержать лишь буквы в прописном регистре [#]_, цифры, подчёркивания, и дефисы (:rfc:`2222`), но Exim фактически, соответствует им регистронезависимо. Если **public_name** не задана, по умолчанию используется имя драйвера.

.. index::
   pair: authenticators; server_advertise_condition

==============================  ===================  =============  ==============
**server_advertise_condition**  Use: authenticators  Type: string†  Default: unset
==============================  ===================  =============  ==============

Когда сервер собирается информировать об аутентификационном механизме, условие раскрывается. Если оно приводит к пустой строке, “0”, “no”, или “false”, то механизм не информируется. Если ошибка не принудительная, и не вызывана путём задержки поиска, инцидент записывается в лог. Смотрите ниже, раздел :ref:`33.3 <ch33_03>` для дальнейшего обсуждения.

.. index::
   pair: authenticators; server_condition

====================  ===================  =============  ==============
**server_condition**  Use: authenticators  Type: string†  Default: unset
====================  ===================  =============  ==============

Этот параметр должен быть задан для серверного аутентификатора **plaintext**, где он используется для прямого контроля аутентификации. Для дополнительных деталей, смотрите раздел :ref:`34.2 <ch34_02>`.

Для других аутентификаторов **server_condition** может быть использована как дополнительный механизм аутентификации или авторизации, который применяется после успеха других условий аутентификаторов. Если она задана, она раскрывается, когда аутентификатор должен вернуть код успеха. Если раскрытие принудительно неудачно, аутентификация неудачна. Любые другие ошибки раскрытия вызывают возврат кода временной ошибки. Если результат успешного раскытия пустая строка, “0”, “no”, или “false” - аутентификация неудачна. Если результат раскрытия “1”, “yes”, или “true” - аутентификация успешна. Для любых других результатов возвращается код временной ошибки, с текстом ошибки в виде результата раскрытия.

.. index::
   pair: authenticators; server_debug_print

======================  ===================  =============  ==============
**server_debug_print**  Use: authenticators  Type: string†  Default: unset
======================  ===================  =============  ==============

Если этот параметр установлен, и включена отладка аутентификации (смотрите параметр **-d** командной строки), строка раскрывается, и включается в отладочный вывод, когда аутентификатор работает как сервер. Это может помочь, при проверке значений переменных. Если раскрытие строки неудачно, сообщение о ошибке пишется в отладочный вывод, и Exim продолжает обработку.

.. index::
   pair: authenticators; server_set_id

=================  ===================  =============  ==============
**server_set_id**  Use: authenticators  Type: string†  Default: unset
=================  ===================  =============  ==============

Когда сервер Exim успешно аутентифицируется как клиент, эта строка раскрывается, используя данные из аутентификации, и сохраняется для входящих сообщений в переменной $authenticated_id. Также, она включается в строку лога для входящих сообщений. Например, конфигурация аутентификатора user/password могла бы сохранять использовавшееся для аутентификации имя пользователя, и обращаться к нему впоследствии, в течение доставки сообщения. Если раскрытие неудачно, параметр игнорируется.

.. index::
   pair: authenticators; server_mail_auth_condition

==============================  ===================  =============  ==============
**server_mail_auth_condition**  Use: authenticators  Type: string†  Default: unset
==============================  ===================  =============  ==============

Этот параметр позволяет серверу отказываться от аутентифицированных отправителей адресов, подаваемых как часть команды MAIL в SMTP-соединении, которое аутентифицировано путём драйвера, на котором установлен параметр **server_mail_auth_condition**. Параметр не используется как часть аутентификационного процесса; вместо этого его (нераскрытое) значение запоминается для дальнейшего использования. То, как оно используется, описано в следующей секции.


.. _ch33_02:

Параметр AUTH в команде MAIL
----------------------------

Когда клиент предоставляет ``AUTH=`` элемент в команде MAIL, Exim применяет следующие проверки, до приёма его как аутентифицированного отправителя сообщения:

* Если соединение не использует расширенный SMTP (т.е. использовался HELO вместо EHLO), использование ``AUTH=`` - синтаксическая ошибка.

* Если значение параметра `AUTH=` - “<>”, оно игнорируется.

* Если задана **acl_smtp_mailauth**, запускается определённая ACL. Когда она работает, значение $authenticated_sender устанавливается из параметра ``AUTH=``. Если ACL не выносит **accept**, значение $authenticated_sender удаляется. ACL **acl_smtp_mailauth** может не вернуть **drop** или **discard**. Если она задерживается, для команды MAIL выдаётся код временной ошибки (451).

* Если **acl_smtp_mailauth** не задана, значение параметра ``AUTH=`` принимается, и помещается в $authenticated_sender лишь если клиент аутентифицировался.

* Если значение ``AUTH=`` было принято любым из двух предыдущих правил, и клиент аутентифицировался, и аутентификатор имеет установку для **server_mail_auth_condition**, условие проверяется в этой точке. Значение, которое было сохранено из аутенификатора - раскрывается. Если раскрытие неудачно, или приводит к пустой строке, “0”, “no”, или “false”, значение $authenticated_sender удаляется. Если раскрытие приводит к другому значению, значение $authenticated_sender сохраняется, и передаётся с сообщением.

Когда $authenticated_sender установлена для сообщения, оно передаётся к другим хостам, на которых Exim аутентифицируется как клиент. Не путайте это значение с $authenticated_id, которое является строкой, полученной из аутентификационного процесса, и которое, обычно, не является полным адресом электронной почты.

Каждый раз, когда значение ``AUTH=`` игнорируется, инцидент записывается в лог. ACL для MAIL, если задана, запускается после того как ``AUTH=`` принята, или проигнорирована. Поэтому, она может использовать $authenticated_sender. Обратное - неверно: значение $sender_address - ещё не установлено, когда работает **acl_smtp_mailauth** ACL.

.. _ch33_03:

Аутентификация на сервере Exim
------------------------------

Когда Exim получает команду EHLO, он сообщает публичные имена тех аутентификаторов, которые сконфигурированы как сервера, подчиняясь следующим условиям:

* Клиентский хост должен совпадать с **auth_advertise_hosts** (по умолчанию - \*)
* Если установлен параметр **server_advertise_condition**, его раскрытие не должно привести к пустой строке, “0”, “no”, или “false”. 
* Порядок, в котором заданы аутентификаторы контролирует порядок, в котором информируется о механизмах.

Некоторые почтовые клиенты (например, некоторые версии Netscape) требуют, чтобы пользователь предоставлял имя и пароль для аутентификации каждый раз, когда информируется о AUTH, даже при том, что аутентификация фактически, не необходима (например, Exim может быть настроен для разрешения безоговорочного релея от клиентов, путём проверки IP-адреса). Вы можете сделать таких клиентов более дружественными, не сообщая им о AUTH. Например, если клиентам сети 10.9.8.0/24 разрешено (путём ACL работающих для RCPT) доставлять почту без аутентификации, вы должны установить

::

    auth_advertise_hosts = ! 10.9.8.0/24

чтобы не информировать их о аутентификационных механизмах.

Параметр **server_advertise_condition** контролирует информирование о отдельных аутентификационных механизмах. Например, она может быть использована для ограничения информирования о специфических механизмах в шифрованных соединениях, путём установки типа::

    server_advertise_condition = ${if eq{$tls_cipher}{}{no}{yes}}

Если сессия зашифрована, переменная $tls_cipher - не пуста, и таким образом, раскрытие приводит к “yes”, которое разрешает информирование.

Когда Exim как сервер получает от клиента команду AUTH, он немедленно её отклоняет, если о AUTH не сообщалось в более раннем ответе на команду EHLO. Так происходит если
               
* Хост клиента не совпадает с **auth_advertise_hosts**; или
* Отсутствуют аутентификаторы сконфигурированные с серверного параметра; или
* Раскрытие **server_advertise_condition** заблокировало информирование о всех серверных аутентификаторах.

Иначе, Exim запускает ACL определённую путём **acl_smtp_auth**, чтобы решить - принять ли команду. Если параметр **acl_smtp_auth** не задана, AUTH принимается от любых клиентских хостов.

Если AUTH не отклонена путём ACL, Exim ищет свою конфигурацию для серверного аутентификационного механизма, о котором информировалось в ответе на EHLO, и который совпадает с именованным в команде AUTH. Если он его находит, он запускает соответствующий аутентификационный протокол, и аутентификация успешна или неуспешна. Если нет соответствия с информировавшимся механизмом, команда AUTH отклоняется с ошибкой 504.

Когда сообщение получено с аутентифицированного хоста, значение $received_protocol установлено в “esmtpa” или “esmtpsa” вместо “esmtp” или “esmtps”, и $sender_host_authenticated содержит имя (не публичное имя) драйвера аутентификации, который успешно аутентифицировал клиента, от которого было получено сообщение. Эта переменная пуста, если небыло успешной аутентификации.


.. _ch33_04:

Проверка серверной аутентификации
---------------------------------

Параметр **-bh** командной строки Exim`a, может быть полезной при тестировании серверной конфигурации аутентификации. Данные для команды AUTH нужно посылать используя кодирование base64. Быстрый способ делать такие данные для тестирования - следующий скрипт на Perl::

    use MIME::Base64;
    printf ("%s", encode_base64(eval "\"$ARGV[0]\""));

Он интерпретирует свои аргументы как строки Perl, и, затем, кодирует их. Интерпретация как строки Perl позволяет бинарные нули, которые должны быть включены в некоторые виды аутентификационных данных. Например, командная строка, для запуска этого скрипта с такими данными, могла бы быть такой::

    encode '\0user\0password'

Отметьте использование одиночных кавычек, для предотвращения интерпретации шеллом обратных слэшей, чтобы они могли быть интерпретированы Perl`ом в специфические символы, чьё кодовое значение - ноль.

.. warning:: Если строка пользователя или пароля начинается с восьмеричной цифры, вы должны использовать три нуля вместо одного, после начального обратного слэша. Если вы этого не сделаете, восьмеричная цифра, с которой начинается ваша строка будет некорректно интерпретирована как часть кода первого знака.

.. warning:: Если в строках есть символы которые Perl интерпретирует особым образом, вы должны использовать экранирование Perl`a для предотвращения их неверного восприятия. Например, команда типа:
 
  ::

      encode '\0user@domain.com\0pas$$word'

  даст некорректный ответ, поскольку неэкранированы символы “@” и “$”.

Если у вас есть инсталлированная команда “mimencode”, то другой способ создать закодированную по base64 строку - запустить команду

::

    echo -e -n `\0user\0password' | mimencode

Параметр **-e** команды *echo* включает интерпретацию экранирования обратных слэшей в аргументе, и параметр **-n** определяет, что в конце вывода не нужно добавлять символ новой строки. Однако, не все версии *echo* распознают эти параметры, следовательно, вы должны проверить вашу версию до того как полагаться на этот совет. [#]_ 


.. _ch33_05:

Аутентификация Exim`a как клиента
---------------------------------

Транспорт **smtp** имеет два параметра, называемые **hosts_require_auth** и **hosts_try_auth**. Когда транспорт **smtp** подключается к серверу которые информировал о поддержке аутентификации, и хост совпадает с отдельной записью в любой из этих параметров, Exim (как клиент) пробует аутентифицироваться следующим образом:

* Для каждого аутентификатора, который сконфигурирован как клиент, в порядке как они заданы в конфигурации, ищщутся аутентификационные механизмы объявленные сервером для того, чьё имя совпадает с публичным именем аутентификатора.

* Когда он находит соответствующий, он запускает клиентский код аутентификатора. Переменные $host и $host_address доступны для любых раскрытий строк которые мог бы сделать клиент. Они устанавливаются в имя и IP-адрес сервера. Если любое раскрытие принудительно неудачно, попытка аутентификации прекращается и Exim движется к следующему аутентификатору. Иные ошибки раскрытия вызывают задержку доставки

* Если результат попытки аутентификации - временная ошибка или таймаут, Exim прекращает попытку послать сообщение к хосту в этот момент. Он пробует позднее. Если есть доступные резервные хосты, они испытываются обычным образом.

* Если ответ на аутентификацию - постоянная ошибка (с кодом 5xx), Exim продолжает поиск списка аутентификаторов и пробует иные, если возможно. Если все попытки аутентификации дают постоянную ошибку, или если нет попыток по причине отсутствия совпадающих механизмов (или раскрытие параметра приводит к принудительной неудаче), происходящее зависит от того, совпадает ли хост с **hosts_require_auth** или **hosts_try_auth**. В первом случае, выводится временная ошибка, и доставка задерживается. Ошибка может быть детектирована в правилах повторов, и, таким образом, превращена в постоянную - если вам это необходимо. Во втором случае, Exim пробует доставить сообщение неаутентифицированным.

Когда Exim подтвердил свою подлинность удалённому хосту, он добавляет параметр AUTH к посылаемой команде MAIL, если он имеет аутентифицированного отправителя. Если сообщение пришло с удалённого хоста, аутентифицированный отправитель - тот, который получен во входящей команде MAIL, при условии, что входящее соединение аутентифицировано, и условие **server_mail_auth** позволяет сохранять аутентифицированного отправителя. Если локальный процесс вызывает Exim для отправки сообщения, адрес отправителя построенный из имени логина пользователя и **qualify_domain** рассматривается как аутентифицированный. Однако, если для транспорта **smtp** установлен параметр **authenticated_sender**, она замещает аутентифицированного отправителя полученного с сообщением.

.. [#] challenges, может быть переведено как откликов - прим. lissyara
.. [#] заглавные - прим. lissyara
.. [#] Надо заметить, что из перечисленных ключей в FreeBSD существует только ключ “-n”, остальных нет - прим. lissyara.
