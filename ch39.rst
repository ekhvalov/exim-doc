
.. _ch39_00:

Шифрование соединений с использованием TLS/SSL
==============================================

Поддержка TLS (Transport Layer Security), прежде известной как SSL (Secure Sockets Layer), осуществлена с использованием библиотеки OpenSSL или библиотеки GnuTLS (Exim требует GnuTLS, версии 1.0 или более позднего). В дистрибутиве Exim'a нет никакого кода для непосредственного осуществления TLS. Для его использования, вы должны инсталлировать OpenSSL или GnuTLS, и, затем, собрать версию Exim'a в которую включена поддержка TLS (смотрите раздел :ref:`4.7 <ch04_07>`). Также, вы должны понимать базовые концепции шифрования на организационном уровне, и, в частности, способы использования публичных ключей, частных ключей, и сертификатов.

:rfc:`3207` задаёт, как SMTP-соединения могут использовать шифрование. Как только установлено подключение, клиент даёт команду STARTTLS. Если сервер её принимает, клиент и сервер договариваются о механизме шифрования. Если договорённость успешна, данные, впоследствии передаваемые между ними, - зашифрованы.

ACL Exim'a позволяют детектировать, зашифрован текущий сеанс, или нет, и, таким образом, какой метод шифрования используется, предоставил ли клиент сертификат, и был ли сертификат проверен. Это позволяет серверу Exim принимать или отклонять определённые команды основанные на состоянии шифрования.

.. warning:: Определённые типы межсетевых экранов и определённые типы антивирусных продуктов могут прерывать  TLS-соединения. Вам необходимо выключить SMTP-сканирование для этих продуктов, чтобы TLS заработало.

.. _ch39_01:

Поддержка для наследственного ssmtp (или smtps) протокола
---------------------------------------------------------

Ранние воплощения шифрованного SMTP использовали иной порт TCP, вместо обычного, и ожидали, что переговоры о шифровании начнутся немедленно, вместо ожидания команды клиента STARTTLS, использующего стандартный SMTP-порт. Протокол назывался “ssmtp” или “smtps”, и для этой цели был выделен 465 порт.

Этот подход был оставлен, когда было стандартизовано шифрованное SMTP, но, всё ещё есть клиенты, использующие его по наследству. Exim поддерживает этих клиентов путём глобального параметра **tls_on_connect_ports**. Её значение должно быть списком номеров портов; обычное использование - таково::

    tls_on_connect_ports = 465

Номер порта, определяемый этим параметром, применяется ко всем SMTP-соединениям, и через демона, и через *inetd*. Вам всё ещё необходимо задавать все порты используемые демоном (путём установки **daemon_smtp_ports** или **local_interfaces** или параметра командной строки **-oX**), поскольку **tls_on_connect_ports** не добавляет дополнительного порта, скорее, она определяет иное поведение на порту определённом в другом месте.

Также, есть параметр командной строки **-tls-on-connect**. Он переопределяет **tls_on_connect_ports**; он вызывает наследование поведения для всех портов.

.. _ch39_02:

OpenSSL против GnuTLS
---------------------

Первая поддержка TLS в Exim`e была осуществлена с использованием OpenSSL. Поддержка GnuTLS последовала позднее, когда была выпущена первая версия GnuTLS. Для сборки Exim'a с использованием GnuTLS, вам необходимо установить

::

    USE_GNUTLS=yes

в *Local/Makefile*, в дополнение к

::

    SUPPORT_TLS=yes

Также, вы должны установить TLS_LIBS и TLS_INCLUDE соответственно, так, чтобы были найдены файлы заголовков и библиотеки для GnuTLS.

Есть некоторые отличия при использовании GnuTLS вместо OpenSSL:

* Параметр **tls_verify_certificates** должна содержать имя файла, а не имя директории (для OpenSSL - это может быть любым).

* Параметр **tls_dhparam** - игнорируется, поскольку ранние версии GnuTLS не имели средств для изменения параметров Diffie-Hellman. Я понимаю, что это изменилось, но Exim не был обновлён для предоставления этого средства.

* Строка “выдающегося имени” (DN) сообщаемая библиотекой OpenSSL использует слэш для разделения полей; GnuTLS использует использует запятые, в соответствии с :rfc:`2253`. Это вызываeтся значением переменной $tls_peerdn.

* OpenSSL идентифицирует шифр используя дефисы, как разделители, например: DES-CBC3-SHA. GnuTLS использует подчёркивания, например: RSA_ARCFOUR_SHA. Что хуже - OpenSSL жалуется на присутствие символов подчёркивания в списке шифров. Чтобы упростить жизнь, Exim заменяет подчёркивания на дефисы для OpenSSL, и дефисы на подчёркивания для GnuTLS при обработке списков шифров в параметре **tls_require_ciphers** (глобальный параметр и транспортный параметр **smtp**).

* Параметр **tls_require_ciphers** работают иначе, как описано в разделе :ref:`39.4 <ch39_04>` и :ref:`39.5 <ch39_05>`.

.. _ch39_03:

Вычисление параметра GnuTLS
---------------------------

GnuTLS использует параметры D-H, которые требуют для вычисления существенного времени. Неблагоразумно вычислять их заново для каждой сессии TLS. Поэтому, Exim сохраняет эти данные в файле, в своей директории спула, называемой *gnutls-params*. Файл принадлежит пользователю Exim'a и читаем лишь его владельцем. Каждый процесс Exim'a, который запускает GnuTLS читает параметры D-H из этого файла. Если файл не существует, первый процесс Exim'a, которому он нужен, вычисляет данные и записывает их во временный файл, переименовываемый по завершении. Не имеет значения, если несколько процессов Exim'a делают это одновременно (кроме траты некоторых ресурсов). Как только файл помещён на место, новый процессы Exim'a немедленно начинают его использовать.

Для максимальной безопасности, параметры, которые сохраняются в этом файле, периодически, должны быть повторно вычислены, частота зависит от уровня вашей параноидальности. Упорядочивание этого - принципиально просто; просто удалите файл, когда вы хотите вычислить новое значение. Однако, могут быть проблемы. Для вычисления новых параметров необходимы случайные числа, и они берутся из */dev/random*. Если система не очень активна, */dev/random* может задержать возврат данных, пока не будет доступно достаточно хаоса. Это может вызывать зависание Exim'a на довольно существенное время, вызывая таймауты для входящих соединений.

Решение - создавать параметры снаружи Exim'a. Они сохраняются в *gnutls-params* в формате PEM, что означает, что они могут быть созданы внешне, используя команду *certtool*, которая является частью GnuTLS.

Для замены параметров новыми, вместо удаления файла и разрешения Exim`y пересоздать его, вы можете создавать новые параметры используя *certtool*, и, после завершения, заменить файл кэша Exim'a путём переименования. Уместные команды - что то типа этого::

    # rm -f new-params
    # touch new-params
    # chown exim:exim new-params
    # chmod 0400 new-params
    # certtool --generate-privkey --bits 512 >new-params
    # echo "" >>new-params
    # certtool --generate-dh-params --bits 1024 >> new-params
    # mv new-params gnutls-params

Если Exim никогда не создает параметры самостоятельно, возможность остановки - удалена [#]_.

.. _ch39_04:

Требование специфических шифров в OpenSSL
-----------------------------------------

В библиотеке OpenSSL есть функция, которая может передавать список наборов шифров до того, как имеет место переговор о шифре. Этим определяется, какие шифры доступны. Список - разделён двоеточиями, и может содержать имена типа DES-CBC3-SHA. Exim передаёт раскрытое значение **tls_require_ciphers** напрямую этому вызову функции. Следующее цитирование документации OpenSSL определяет, какие формы элементов допустимы в строке шифра:
* Он может состоять из одного шифра, типа RC4-SHA.
* Он может представлять список шифров содержащих определённый алгоритм, или шифры определённого типа. Например, SHA1 представляет все шифры используя алгоритм SHA1 и SSLv3 представляет все алгоримы SSL v3.
* Списки наборов шифров могут быть объединены в одну строку шифра, используя символ “+”. Это используется как логическая операция “и”. Например, SHA1+DES представляет все наборы шифров содержащие алгоритмы SHA1 и DES.
  
Каждой строке шифра, произвольно, может предшествовать один из символов “!” или “-” или “+”.
* Если используется “!” - шифр удаляется из списка. Удалённые шифры не могут вновь появляться в списке, даже если они явно заявлены.
* Если используется “-”, шифр удаляется из списка, но некоторые, или все шифры могут быть добавлены последующими параметрами позднее.
* Если используется “+”, шифр перемещается в конец списка. Этот параметр не добавляет новых шифров; она лишь перемещает существующие.
* Если не присутствует ни один из этих символов, строка интерпретируется как список шифров, который будет добавлен к текущему привилегированному списку. Если список включает какие-то шифры, которые уже присутствуют, они будут проигнорированы: т.е. они не будут перемещены в конец списка.

.. _ch39_05:

Специфические шифры или другие параметры требующиеся в GnuTLS
-------------------------------------------------------------

Библиотека GnuTLS позволяет вызывающему определить список разрешённых методов обмена ключами, главный шифрующий алгоритм, алгоритмы MAC и протоколы. К несчастью, эти списки цифровые, и библиотека не имеет функций для преобразования имён в номера. Поэтому, список распознаваемых имён собран в приложение. Разрешённые методы обмена ключами, шифры, и алгоритмы MAC могут использоваться в любой комбинации с формой шифрования. Это - отличие от OpenSSL, где полное имя шифрования передаётся её управляющей функции.

Для совместимости с OpenSSL, параметр **tls_require_ciphers** может быть установлен в полное имя шифра, такое как RSA_ARCFOUR_SHA, но для GnuTLS этот параметр контролирует только алгоритм шифрования. Exim ищет каждый элемент в списке для имени доступного алгоритма. Например, если список содержит RSA_AES_SHA, тогда распознаётся AES, и поведение точно такое же как если задан просто AES.

Есть дополнительные параметры с именами **gnutls_require_kx**, **gnutls_require_mac**, и **gnutls_require_protocols** которые могут использоваться для ограничения методов обмена ключами, алгоритмов MAC, и протоколов, соответственно. При использовании OpenSSL эти параметры игнорируются.

Все четыре параметра доступны как глобальные параметры, контролирующие как Exim ведёт себя в роли сервера, и, также, как параметры транспорта **smtp** - контролирующие как Exim ведёт себя в роли клиента. Все значения - раскрываемые. После раскрытия, значение может быть списком разделённым двоеточием, разделитель может быть изменён обычным способом.

Каждый из четырёх списков начинается с набора алгоритмов по умолчанию. Если первый элемент в списке не начинается с восклицательного знака, все элементы по умолчанию удаляются. В этом случае, может использоваться только то, что точно задано. Если первый элемент в списке начинается с восклицательного знака, значения по умолчанию помещаются слева списка.

Тогда, любой элемент, начинающийся с восклицательного знака, вызывает удаление релевантных алгоритмов из списка, и любой элемент, не начинающийся с восклицательного знака, вызывает добавление релевантных алгоритмов в список. Неизвестные элементы списка - игнорируются. Таким образом,

::

    tls_require_ciphers = !ARCFOUR

разрешают все значения по умолчанию, исключая ARCFOUR, тогда как

::

    tls_require_ciphers = AES : 3DES

разрешает лишь шифрование использующее AES и 3DES.

Для **tls_require_ciphers** распознаваемые имена - AES_256, AES_128, AES (оба из предшествовавших), 3DES, ARCFOUR_128, ARCFOUR_40 и ARCFOUR (оба из предшествовавших). Список по умолчанию не содержит их всех; в нём находятся AES_256, AES_128, 3DES, и ARCFOUR_128.

Для **gnutls_require_kx** распознаваемые имена DHE_RSA, RSA (который включает DHE_RSA), DHE_DSS, и DHE (который включает оба DHE_RSA и DHE_DSS). Список по умолчанию содержит RSA, DHE_DSS, DHE_RSA.

Для **gnutls_require_mac** распознаваемые имена SHA (синоним SHA1), и MD5. Список по умолчанию содержит SHA, MD5.
                          
Для **gnutls_require_protocols** распознаваемые имена TLS1 и SSL3. Список по умолчанию содержит TLS1 и SSL3.

В сервере, порядок списка не имеет значения. Сервер будет извещать о доступности всех допустимых методов шифрования. Однако, в клиенте, порядок в списке **tls_require_ciphers** определяет предпочтительный порядок алгоритмов шифрования. Первым пробуется первый из клиентского списка, о котором, также, извещал сервер. Порядок значений по умолчанию - перечислен выше.

.. _ch39_06:

Настройка сервера Exim для использования TLS
--------------------------------------------

Когда Exim собран с поддержкой TLS, он извещает клиентские хосты, совпадающие с **tls_advertise_hosts** о доступности команды STARTTLS, но не какие-либо другие хосты. Значение по умолчанию этого параметра - не задано, что означает, что о STARTTLS никто не извещается. Такое значение по умолчанию выбрано, поскольку вы должны привести в порядок некоторые другие параметры, чтобы сделать доступным TLS, и, также, это разумно для систем, которые хотят использовать TLS лишь в роли клиента.

Если клиент выдаёт команду STARTTLS, и на сервере существует какая-то конфигурационная проблема, команда отклоняется с ошибкой 454. Если клиент упорствует в попытках подавать команды SMTP, все они, кроме QUIT, отклоняются с ошибкой::

    554 Security failure

Если команда STARTTLS подаётся в пределах существующей TLS-сессии, она отклоняется с кодом ошибки 554.

Для включения операций TLS на сервере, вы должны установить параметр **tls_advertise_hosts** в соответствие каким-то хостам. Вы можете, разумеется, установить её в “*” - для соответствия всем хостам. Однако, это не всё, что вы должны сделать. TLS-сессии на сервере не будут работать без некоторого дальнейшей настройки в конце сервера.

По слухам известно, что все существующие клиенты, которые поддерживают TLS/SSL, используют шифрование RSA. Чтобы это работало, вам необходимо установить в сервере::

    tls_certificate =/some/file/name
    tls_privatekey =/some/file/name

Фактически, эти параметры - раскрываемые строки,таким образом, вы можете сделать их зависимыми от подключенного клиента, если захотите. Первый файл содержит сертификат X509 сервера, и, второй, содержит частный ключ, который с ним идёт. Эти файлы должны быть доступны для чтения пользователем Exim'a, и, всегда должны быть даны с полным путём. Это может быть один и тот же файл, если в нём содержатся сертификат и ключ. Если параметр **tls_privatekey** не задана, или если раскрытие принудительно неудачно, или результат - пустая строка, предполагается такой случай. Файл сертификата также может содержать промежуточные сертификаты, которые необходимы для отсылки клиенту, с целью аутентифицировать сертификаты сервера.

Если вы не понимаете о ключах и сертификатах, пожалуйста, попробуйте найти источник этой вводной информации, которая не является специфической для Exim'a. (Есть несколько комментариев ниже, в разделе :ref:`39.11 <ch39_11>`.)

.. note:: Эти параметры не применяются когда Exim работает как клиент - они применяются лишь в случае сервера. Если вам необходимо использовать сертификат в Exim`e в роли клиента, вы должны установить параметры с теми же самыми названиями в транспорте **smtp**.

Только с этими параметрам, сервер Exim'a способен использовать TLS. Этим не требуется, чтобы клиент обладал сертификатом (но, смотрите ниже, как настоять на этом). Существует еще один параметр, который бывает необходим в других ситуациях. Если параметр

::

    tls_dhparam = /some/file/name

установлен, библиотека SSL инициализируется для использования шифрования Diffie-Hellman, с параметрами, содержащимися в файле. Это увеличивает набор методов шифрования, поддерживаемых сервером. Смотрите команду

::

    openssl dhparam
    
для способа генерации этих данных. В настоящее время, **tls_dhparam** используется лишь когда Exim собран с OpenSSL. При использовании GnuTLS, он игнорируется.

Строки, предоставляемые для этих трёх параметров, раскрываются при каждом подключении клиентского хоста. Поэтому возможно использовать различные сертификаты и ключи для разных хостов, если вы этого желаете, для управления раскрытием, путём использования клиентского IP-адреса в переменной $sender_host_address. Если строка раскрытия принудительно неудачна, Exim ведёт себя так, будто этот параметр не установлен.

В переменную $tls_cipher устанавливается метод шифрования, о котором договорились для входящего соединения TLS. Это включается в заголовок “Received:” входящего сообщения (по умолчанию - разумеется, вы можете это изменить), и, также, включается в в строку лога прибывающего сообщения, с ключом “X=”, если не выключен лог селектор **tls_cipher**. Условие **encrypted** может использоваться для тестирования специфического шифрования в ACL. (Для исходящих доставок SMTP переменная $tls_cipher сброшена - смотрите раздел :ref:`39.9 <ch39_09>`)

Как только соединение TLS установлено, ACL которые запускаются для последующих команд SMTP могут проверить имя метода шифрования и изменить свои действия соответствующим образом. Имена методов шифрования изменяемые, зависят от используемой библиотеки TLS. Например, OpenSSL использует имя DES-CBC3-SHA для шифрования, известного в другом контексте как TLS_RSA_WITH_3DES_EDE_CBC_SHA. Для дополнительных деталей проверьте документацию OpenSSL.


.. _ch39_07:

Запрос и проверка клиентских сертификатов
-----------------------------------------

Если вы хотите, чтобы сервер Exim'a запросил сертификат при переговорах о TLS-сессии с клиентом, вы должны установить или **tls_verify** или **tls_try_verify_hosts**. Разумеется, вы можете установить любой из них в “*”, для применения ко всем соединениям TLS. Для любого хоста, который совпадает с этими параметрами, Exim запрашивает сертификат как часть установки сессии TLS. Содержимое сертификата проверяется путём его сравнения со списком ожидаемых сертификатов. Они должны быть доступны в файле, или, только для OpenSSL (не для GnuTLS), каталоге, идентифицируемом путём  **tls_verify_certificates**.

Файл может содержать много сертификатов, связанных конец к концу. Если используется директория (только для OpenSSL), каждый сертификат должен быть в отдельном файле, с именем (или символической ссылкой) формы *<hash>.0*, где *<hash>* - значение хэша созданное из сертификата. Вы можете вычислить релевантный кэш путём запуска команды

::

    openssl x509 -hash -noout -in /cert/file

где */cert/file* - содержит один сертификат.

Различие между **tls_verify_hosts** и **tls_try_verify_hosts** - в том, что происходит если клиент не предоставляет сертификат, или если сертификат не совпадает ни с одним из сертификатов в коллекции из **tls_verify_certificates**. Если клиент совпадает с **tls_verify_hosts**, попытка установить TLS-сессию прерывается, и входящее соединение обрыватся. Если клиент совпадает с **tls_try_verify_hosts**, продолжается (шифрованная) SMTP-сессия. ACL`ы, запускаемые для последующих команд SMTP, могут детектировать факт, что сертификат не был проверен, и соответственно изменить свои действия. Например, вы можете настаивать на сертификате до принятия сообщения для доставки, но не когда сообщения предназначено для локальной доставки.
         
Когда клиент предоставляет сертификат, (проверенный, или нет), значение DN сертификата становится доступным в переменной $tls_peerdn в процессе последующей обработки сообщения.

Поскольку часто это - длинная текстовая строка, по умолчанию она не включается в строку лога или заголовок “Received:”. Вы можете принять меры для её записи в лог, установив ключ “DN=”,в лог селекторе **tls_peerdn**, и вы можете использовать **received_header_text** - для изменения заголовка “Received:”. Когда сертификат не предоставлен, переменная $tls_peerdn пуста.

.. _ch39_08:

Отменённые сертификаты
----------------------

Издатели сертификатов выпускают Списки Аннулированных Сертификатов (Certificate Revocation Lists - CRLs), когда сертификаты отменяются. Если у вас есть такой список, вы можете передать его серверу Exim'a используя глобальный параметр **tls_crl**, и клиенту Exim'a, используя параметр с идентичным названием для транспорта **smtp**. В каждом случае, значение параметра раскрывается, и должно быть именем файла содержащего CRL в формате PEM.


.. _ch39_09:

Настройка клиента Exim'a для использования TLS
----------------------------------------------

Лог селекторы **tls_ciphe** и **tls_peerdn** применяются к исходящим SMTP-доставкам также, как и ко входящим, последние вызывают запись в лог DN сертификатов сервера. Оставшаяся клиентская конфигурация для TLS - вся в транспорте **smtp**.

Нет необходимости устанавливать какие-либо параметры для работы TLS в транспорте **smtp**. Если Exim собран с поддержкой TLS, и сервер оповестил о поддержке TLS, транспорт **smtp**.всегда пробует запустить TLS-сессию. Однако, это может быть предотвращено установкой **hosts_avoid_tls** (транспортный параметр) в список серверных хостов, с которыми не используется TLS.

Если вы не хотите чтобы Exim пытался отправить сообщения незашифрованными, когда попытка установки шифрованного соединения была неудачной, вы можете установить параметр **hosts_require_tls** в список хостов, для которых шифрования является обязательным. Для этих хостов, доставка всегда задерживается, если не может быть установлено шифрованное соединение. Если для адреса есть другие хосты, они пробуются обычным способом.

Когда хост сервера не находится в **hosts_require_tls**, Exim может попробовать доставить сообщение не шифрованным. Он всегда так делает, если ответ на STARTTLS - код 5xx. Для временного кода ошибки, или для ошибки переговоров о сессии TLS после успешного кода ответа, происходящее контролируется параметром **tls_tempfail_tryclear** транспорта **smtp**. Если она ложна, доставка к хосту задерживается, и пробуются другие хосты (если доступны). Если она истинна, Exim пытается доставить не шифрованное сообщение после 4xx ответа на STARTTLS, и, если STARTTLS принимается, но последующие переговоры о TLS неудачны, Exim закрывает текущее соединение (поскольку оно в неизвестном состоянии), открывает новое к тому же самому хосту, и, затем, пытается доставить сообщение не шифрованным.

Параметры **tls_certificate** и **tls_privatekey** транспорта **smtp** предоставляют клиенту сертификат, который он передаёт на сервер, если тот его запрашивает. Если сервер - Exim, то он будет просить сертификат лишь если клиент совпадает с параметром **tls_verify_hosts** или **tls_try_verify_hosts**.

Если для транспорта **smtp** установлен параметр **tls_require_ciphers**, она должна быть именем файла, или, только для OpenSSL (не для GnuTLS), директорией, которая содержаит коллекцию ожидаемых серверных сертификатов. Клиент проверяет сертификат сервера со своей коллекцией, принимая во внимание любые отозванные сертификаты, которые находятся в списке, заданном параметром **tls_crl**.

Если для транспорта **smtp** установлен параметр **tls_require_ciphers**, он должен содержать список разрешённых методов шифрования. Если любая из этих проверок неудачна, доставка к текущему хосту прекращается, и транспорт **smtp** пробует доставить на альтернативный хост, если он есть.

.. note:: Эти параметры должны быть заданы в транспорте **smtp** Exim'a для использования TLS, когда он работает как клиент. Exim не предполагает, что сертификат сервера (установленный глобальным параметром с тем же самым именем) также должен использоваться при работе в роли клиента.

Все параметры TLS, в транспорте **smtp**, раскрываются до использования, с $host и $host_address содержащими имя и адрес сервера, на который подключился клиент. Принудительная ошибка раскрытия заставляет Exim вести себя так, как будто соответствующий параметр не задан.

До установления SMTP соединения, переменные $tls_cipher и $tls_peerdn - пусты. (В процессе первого соединения, оно содержат значения которые которые установлены при приёме сообщения) Если, в последствии, STARTTLS проходит успешно, эти переменные устанавливаются в соответствующие значения для исходящего соединения.

.. _ch39_10:

Несколько сообщений через одно шифрованное TCP/IP соединение
------------------------------------------------------------

Exim посылает много сообщений по одному TCP/IP соединению путём запуска нового процесса для каждого сообщения, передавая сокет от одного процесса следующему. Эта реализация не очень хорошо для работы с TLS, поскольку есть много информации о состоянии, ассоциированной с соединением TLS, а не только идентификатор сокета. Передача всей информации о состоянии другому процессу - невыполнима. Следовательно, Exim завершает существующую сессию TLS до передачи сокета новому процессу. Новый процесс может попробовать запустить сеанс TLS, и, в случае успеха, может попробовать заново аутентифицироваться, если используется AUTH, до посылки следующего сообщения.

Из RFC неясно, действительно или нет, SMTP сессия продолжается в чистом виде после закрытия TLS, или же TLS может быть перезапущен позже, как было описано. Однако, если сервер - Exim, эта остановка и перезапуск - работает. Не известно, каким (или обоими) образом себя ведут другие сервера, если клиент закрывает сеанс TLS, и продолжает с не шифрованным SMTP, но, разумеется, есть те, которые не работают. Для таких серверов, Exim не должен передавать сокет другому процессу, поскольку неудача последующей попытки его использования заставила бы Exim записать в логи временную ошибку хоста, и задержать иные доставки на этот хост.

Для тестирования этого случая, Exim посылает команду EHLO на сервер после закрытия TLS сессии. Если она удачна, то соединение закрывается вместо передачи новому новому процессу доставки, но информация о повторе не записывается.

Также есть ручная отмена; вы можете установить параметр **hosts_nopass_tls** транспорта **smtp** в совпадение с этими хостами, для которых Exim не должен передавать соединение новому процессу, если используется TLS.

.. _ch39_11:

Сертификаты и всё такое
-----------------------

Для полного понимания работы TLS, вам необходимо знать о сертификатах, подписании сертификатов, и авторизаторах сертификатов. Это - не место для обучения [#]_, тем более, что я не очень много знаю об этом. Некоторое полезное введение может быть найдено в FAQ дополнения SSL к Apache, в настоящее время::

    http://www.modssl.org/docs/2.7/ssl_faq.html#ToC24

Другие части документации по *modssl* - также полезны, и имеют ссылки на дальнейшие файлы. Книга Eric`a Rescorla`a - “SSL and TLS”, опубликованная Addison-Wesley (ISBN 0-201-61598-3), содержит введение и дополнительные всесторонние описания. Некотрые типовые программы, взятые из книги, доступны  по адресу::

    http: // www.rtfm.com/openssl-examples/

.. _ch39_12:

Цепочки сертификатов
--------------------

Файл указанный в **tls_certificate** может содержать более одного сертификата. Это полезно в случае, когда посылаемый сертификат проверяется промежуточным сертификатом, которого не имеет другая сторона. Несколько сертификатов должны быть в правильном порядке в файле. Вначале, хост сертифицирует сам себя, затем, следующий сертификат для проверки выданного хостом, затем следующее - для проверки предыдущего, и так далее, до (не обязательно) - корневого сертификата. Корневой сертификат уже должен быть доверенным у получателя, для успешной проверки, разумеется, если он заранее не установлен, посылка корневого сертификата вместе с остальными делает его доступным пользователю для установки, если конечный получатель - пользовательский MUA, который может взаимодействовать с пользователем.

.. _ch39_13:

Самоподписанные сертификаты
---------------------------

Вы можете создать самоподписанный сертификат, используя команду *req*, предоставляемую OpenSSL, например так::

    openssl req -x509 -newkey rsa:1024 -keyout file1 -out file2 \
                -days 9999 -nodes

*file1* и *file2* могут быть одним и тем же файлом; ключ и сертификат разграничены, и могут быть идентифицированы независимо. Параметр **-days** период, в течение которого сертификат действителен. Параметр **-nodes** - важна: если вы её не зададите, ключ шифруется с запрашиваемой у вас парольной фразой, и любое использование ключа вызывает запрос парольной фразы. Это бесполезно, если вы собираетесь использовать ключ в MTA, где запрос невозможен.

Самоподписанный сертификат, сделанный таким образом, вполне достаточен для тестирования, и может быть адекватен для всех ваших требований, если вы, главным образом, интересуетесь шифрованием передачи, а не секурной идентификацией.

Однако, многие клиенты требуют чтобы предоставленный сервером сертификат был пользовательским (также назваемый “leaf” или “site”) сертификатом, и не самоподписанным сертификатом. В этой ситуации, самоподписанный сертификат, должен быть установлен на клиентском хосте как доверенный корневой “авторитативный сертификат” (CA), и сертификат используемымй Exim`ом, должен быть пользовательским сертификатом, подписанным с этим самоподписанным сертификатом.

Для информации о создании самоподписанных сертификатов и использовании их для подписания пользовательских сертификатов, смотрите часть “General implementation overview” книги “Open-source PKI”, доступной по адресу http://ospkibook.sourceforge.net/.


.. [#] наверное, имеется ввиду задержка при генерации - прим. lissyara
.. [#] имеется ввиду - этот документ - прим. lissyara
