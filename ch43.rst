
.. _ch43_00:

Системная фильтрация сообщений
==============================

Предыдущие части (ACL и функция local scan) описывают проверки, которые могут быть применены к сообщениям до того, как они принимаются хостом. Также есть механизм для проверки сообщений после их получения, но до доставки. Он называется - “system filter”.

Системный фильтр работает подобно файлу пользовательского фильтра, но он запускается лишь один раз на сообщение (однако, у сообщения много получателей). Обычно, он не должен использоваться вместо маршрутизации, поскольку команда **deliver** в системном маршрутизаторе даёт новые адреса получателей конверта. Системный фильтр должен быть фильтром Exim`a. Он не может быть фильтром Sieve.

Системный фильтр запускается в начале попытки доставки, до какой-либо маршрутизации. Если сообщение невозможно доставить при первой попытке, системный фильтр запускается снова в начале каждого повтора. Если вы хотите чтобы фильтр работал лишь при первой доставке, вы можете использовать в фильтре условие **first_delivery** в команде **if**, для предотвращения обработки при повторах.

..warning:: Поскольку системный фильтр запускается лишь один раз, переменные являющиеся специфическими для индивидуальных адресов получателей, типа $local_part и $domain, не установлены, и условие “personal” - незначащее. Если вы хотите запускать заданный центрально фильтр независимо для каждого адреса получателя, вы можете это сделать путём установки подходящего маршрутизатора **redirect**, как описано ниже, в разделе :ref:`43.8 <ch43_08>`.

.. _ch43_01:

Установка системного фильтра
----------------------------

Имя файла, который содержит системный фильтр, должно быть задано путём установки **system_filter**. Если вы хотите запускать фильтр не под uid и gid root`a, вы, также, должны установить **system_filter_user** и **system_filter_group**, соответственно. Например::

    system_filter = /etc/mail/exim.filter
    system_filter_user = exim

Если системный фильтр создает любую доставку в файлы или трубы (через команды **save** или **pipe**), транспорты для обработки этих доставок должны быть определены путём установки **system_filter_file_transport** и **system_filter_pipe_transport**, соответственно. Точно также, **system_filter_reply_transport** должна быть установлена для обработки любых сообщений создаваемых путём команды **reply**.

.. _ch43_02:

Тестирование системного фильтра
-------------------------------

Вы можете запускать простые тесты системного фильтра точно также, как для пользовательского фильтра, но вы холжны использовать **-bF** вместо **-bf**, так, чтобы были распознаны особенности, разрешённые лишь в системных фильтрах.

Если вы хотите тестировать комбинированный эффект системного и пользовательского фильтров, вы можете использовать оба параметра - **-bF** и **-bf**, в одной командной строке.

.. _ch43_03:

Содержимое системного фильтра
-----------------------------

Язык, используемый для определения системных фильтров - точно такой же как и для файлов пользовательских фильтров. Он описан в отдельном документе для пользователя - “Exim’s interface to mail filtering”. Однако, есть некоторые дополнительные особенности, которые доступны лишь в системных фильтрах; они описаны в последующих секциях. Если они встречаются в файлах пользовательских фильтров, или при тестировании с **-bf**, они вызывают ошибки.

Есть два специальных условия, которые доступны в файлах фильтров пользователей, но проектировались для использования в системных фильтрах. Условие **first_delivery** - истинно лишь для первой попытки доставки сообщения, и **manually_thawed** - истинно лишь если сообщение было заморожено, и в последствии было разморожено административным пользователем. Явная принудительная доставка считается ручным размораживанием, но разморозка в результате установки **auto_thaw** таковой не считается.

.. warning:: Если системный фильтр использует условие **first_delivery** для создания **unseen** (невидимой) доставки, и эта доставка неуспешна, ещё одна попытка доставки не производится. Если вы хотите чтобы Exim повторял невидимые доставки до их успеха, вы должны установить её при каждом запуске фильтра.

Когда системный фильтр завершает работу, значения переменных  $n0 - $n9 копируются в $sn0 - $sn9, и, таким образом, становятся доступны в файлах пользовательских фильтров. Таким образом, системный фильтр может, например, устанавливать “баллы” для передачи пользовательским фильтрам.

.. _ch43_04:

Дополнительные переменные для системных фильтров
------------------------------------------------

Переменная раскрытия $recipients, содержащая список всех получателей сообщения (разделённых запятыми и пробелами), - доступна в системных фильтрах. Из соображений безопасности, она не доступна в пользовательских фильтрах.

.. _ch43_05:

**Defer**, **freeze**, и **fail** команды системного фильтра
------------------------------------------------------------

Существуют три дополнительные команды (**defer**, **freeze** и **fail**), которые всегда доступны в системных фильтрах, но, обычно, недопустимы в пользовательских фильтрах. (Смотрите параметры **allow_defer**, **allow_freeze** и **allow_fail** маршрутизатора **redirect**.) Эти команды, необязательно, могут сопровождаться словом **text** и строкой содержащей сообщение о ошибке, например::

    fail text "this message looks like spam to me"

Ключевое слово **text** необязательно, если следующий символ - двойная кавычка.

Команда **defer** задерживает доставку оригинальных получателей сообщения. Команда **fail** вызывает неудачу оригинальных получателей, и создание рикошета. Команда **freeze** останавливает все попытки доставки для оригинальных получателей. Во всех случаях, любые новые доставки определённые фильтром предпринимаются обычным образом после работы фильтра.

Команда **freeze** игнорируется, если сообщение было разморожено вручную, и с тех пор не было вручную заморожено.Это означает, что автоматическое замораживание путём системного фильтра может использоваться как способ проверки подозрительных сообщений.Если выясняется, что сообщение нормальное, ручная разморозка позволяет его доставку.

Текст, данный с командой **fail**, используется как часть сообщения рикошета, а также записывается в лог. Если сообщение очень длинное, они могут занимать много места в логах, если отказы происходят постоянно. Для уменьшения размера сообщений в логах, Exim специальным образом интерпретирует текст, если он начинается с “<<”, и, позднее, содержит “>>”. Текст между этими двумя строками пишется в лог, и оставшаяся часть текста используется в сообщении рикошета. Например::

    fail "<<filter test 1>>Your message is rejected \
         because it contains attachments that we are \
         not prepared to receive."

Используйте команду **fail** с большой осторожностью, когда решение о неудаче основано на содержимом сообщения, поскольку сообщение рикошета будет включать содержимое оригинального сообщения, и может снова вызвать команду **fail** (вызывая зацикливание почты), если не были приняты специальные меры для предотвращения этого. Тестирование условия **error_message** - один из путей это предотвратить. Например, вы можете использовать::

    if $message_body contains "this is spam" and not error_message
    then fail text "spam is not wanted here" endif

хотя, разумеется, могут проходить нежелательные рикошеты. Альтернатива - умная проверка тела и/или заголовков для детектирования рикошетов созданных фильтром.

Интерпретация системного фильтра прекращается немедленно после выполнения команды **defer**, **freeze** или **fail**. Однако, любые доставки, установленные ранее в фильтре - соблюдаются, таким образом, вы можете использовать последовательность типа

::

    mail ...
    freeze

для отправки заданного сообщения при заморозке системным фильтром (или задержке, или ошибке) сообщения. Нормальные доставки для сообщения, разумеется, не происходят.

.. _ch43_06:

Добавление и удаление заголовков в системном фильтре
----------------------------------------------------

Две команды фильтра, которые доступны лишь в системных фильтрах, таковы::

    headers add <string>
    headers remove <string>

Аргумент для **headers add** - строка, которая раскрывается, и, затем, добавляется к концу заголовков сообщения. Ответственностью разработчика фильтра является проследить за соответствием синтаксису :rfc:`2822`. Начальные пробелы игнорируются, и если строка пуста, или раскрытие принудительно неудачно, команда не имеет эффекта.

Вы можете использовать “\n” внутри строки, сопровождаемый пробелом, для задания продолженных строк заголовков. Более чем один заголовок может быть добавлен в одной команде, путём включения “\n” в строке без пробелов. Например::

    headers add "X-header-1: ....\n  \
                continuation of X-header-1 ...\n\
                X-header-2: ...."

Отметьте, что строки заголовков продолжающие пробелы после первого символа новой строки должны быть помещены до обратного слэша, который продолжает строку ввода, поскольку пробелы после появления продолжения игнорируются.

Аргумент для **headers remove** - список имён заголовков, разделённых двоеточиями. Эта команда применяется лишь к тем заголовкам, которые сохраняются с сообщением; те, что добавляются в процессе доставки (типа “Envelope-To:” и “Return-Path:”) не могут быть удалены этим средством. Если есть более одного заголовка с одинаковым именем, они все удаляются.

Команда **headers** в системном фильтре, делает немедленные изменения строк заголовков, полученных с сообщением (с возможными дополнениями от обработки ACL). Последующие команды системного фильтра оперируют модифицированным набором заголовков, который, также, является основой для последующей доставки. Кроме последующей модификации в процессе маршрутизации или транспортировки, этот набор заголовков используется для всех получателей сообщения.

В процессе маршрутизации и транспортировки, переменные, которые ссылаются на содержимое строк заголовков, ссылаются лишь на те строки, которые находятся в этом наборе заголовков. Таким образом, строки заголовков, добавленные системным фильтром, видны в файлах пользовательских фильтров, и во всех маршрутизаторах и транспортах. Это - противоположно манипуляциям заголовками в маршрутизаторах и транспортах, которые не немедленные, а вместо этого, сохраняются вплоть до фактической записи сообщения (смотрите раздел :ref:`44.17 <ch44_17>`).

Если сообщение не доставляется в первую попытку, строки заголовков, добавленные системным фильтром, сохраняются с сообщением, и, таким образом, остаются представленными в следующую попытку доставки. Удаленные строки заголовков остаются присутствовать, но помечены “deleted”, таким образом, они не транспортируются с сообщением. Для этого случая, обычно, команду **headers** делают зависимой от команды **first_delivery** так, чтобы строки заголовков не модифицировались более одного раза.

Поскольку модификация заголовков в системном фильтре происходит немедленно, вы должны использовать косвенный подход, если хотите изменить содержимое строки заголовка. Например::

    headers add "Old-Subject: $h_subject:"
    headers remove "Subject"
    headers add "Subject: new subject (was: $h_old-subject:)"
    headers remove "Old-Subject"

.. _ch43_07:

Установка адреса ошибок в системном фильтре
-------------------------------------------

В системном фильтре, команда **deliver** вида

::

    errors_to <some address>

может использоваться для изменения адреса отправителя конверта (и, следовательно, сообщения о ошибках) для этой доставки, может быть задан любой адрес. (В пользовательском фильтре, может быть установлен лишь текущий адрес пользователя.) Например, если какая-то почта проверяется, вы могли бы использовать

::

    unseen deliver monitor@spying.example errors_to root@local.example

для получения копии, которая не была бы послана обратно на обычный адрес ошибки, если доставка неудачна.

.. _ch43_08:

Фильтрация по адресам
---------------------

В отличие от системного фильтра, который запускается лишь один раз на сообщение для каждой попытки доставки, также возможно установить операцию фильтрации для всей системы, которая запускается один раз для каждого получателя адреса. В этом случае, могут использоваться переменные типа $local_part и $domain, и действительно, выбор файла фильтра может быть сделан зависимым от них. Это - пример маршрутизатора, который осуществляет такой фильтр::

    central_filter:
      check_local_user
      driver = redirect
      domains = +local_domains
      file = /central/filters/$local_part
      no_verify
      allow_filter
      allow_freeze

Фильтр запускается в отдельном процессе под собственным uid. Поэтому, любой параметр **check_local_user** должна быть установлен (как выше), в случае когда фильтр выполняется от локального пользователя, или параметр **user** должен определять, какой пользователь будет использоваться. Если заданы оба, **user** изменяется.
                    
Необходимо позаботится чтобы ни одна из команд в файле фильтра не определяет важную доставку, если сообщение доставляется его непосредственному получателю. Тогда маршрутизатор не будет требовать адрес, таким образом, оно будет передано последующим маршрутизаторам для доставки обычным способом.

