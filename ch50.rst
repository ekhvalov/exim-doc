
.. _ch50_00:

Утилиты Exim'a
==============

Множество скриптовых утилит и программ поставляются с Exim'ом и описано в этой части. Также, есть Exim Monitor, который описывается в следующей части. Описанные утилиты таковы:

======================  ==================  ======================
:ref:`50.1 <ch50_01>`   *exiwhat*           список, что делают процессы Exim'a
:ref:`50.2 <ch50_02>`   *exiqgrep*          выбор из очереди
:ref:`50.3 <ch50_03>`   *exiqsumm*          суммирование очереди
:ref:`50.4 <ch50_04>`   *exigrep*           поиск по главному логу
:ref:`50.5 <ch50_05>`   *exipick*           выбор сообщений по различным критериям
:ref:`50.6 <ch50_06>`   *exicyclog*         ротация лог-файлов
:ref:`50.7 <ch50_07>`   *eximstats*         выбор статистики из логов
:ref:`50.8 <ch50_08>`   *exim_checkaccess*  проверка приёма адреса с данного IP
:ref:`50.9 <ch50_09>`   *exim_dbmbuild*     сборка файла DBM
:ref:`50.10 <ch50_10>`  *exinext*           извлечение информации повторов
:ref:`50.11 <ch50_11>`  *exim_dumpdb*       дамп БД подсказок
:ref:`50.11 <ch50_11>`  *exim_tidydb*       очистка БД подсказок
:ref:`50.11 <ch50_11>`  *exim_fixdb*        правка БД подсказок
:ref:`50.15 <ch50_15>`  *exim_lock*         блокировка файла почтового ящика (mailbox)
======================  ==================  ======================

   
Другая утилита, которая могла бы использоваться на сайтах с многими MTA - *exilog* Tom Kistner’s. Он обеспечивает визуализацию логов от многих серверов Exim'a. Для деталей, смотрите http://duncanthrax.net/exilog/.

.. _ch50_01:

Поиск, что делают процессы Exim'a (exiwhat)
-------------------------------------------

На операционных системах, которые могут замещать системные вызовы после получения сигнала (большинство современных OS), процесс Exim'a отвечает на сигнал SIGUSR1, путём записи строки описывающей, что он делает в файл *exim-process.info* в директории спула Exim'a. Скрипт *exiwhat* посылает сигнал всем процессам Exim'a, которые он находит, вначале очистив файл. После чего он ждёт секунду, чтобы позволить процессам Exim'a отреагировать, до отображения результатов. Для успешного управления *exiwhat*, вы должны обладать достаточными привилегиями для посылки сигнала процессам Exim'a, таким образом, обычно, он запускается от пользователя root.

.. warning:: Это неэффективный процесс. Он предназначен для случайного использования администраторами системы. Неразумно, например, настраивать скрипт, который через короткие периоды посылает процессам Exim'a сигнал SIGUSR1.

К сожалению, команда *ps* которую *exiwhat* использует для нахождения процессов Exim'a, различна в разных операционных системах. Мало того, что используются различные параметры, но и формат вывода - различен. Для этого, есть некоторые системные конфигурационные параметры, которые настраивают работу *exiwhat*. Если вам кажется, что он не работает, проверьте следующие параметры компиляции:

* EXIWHAT_PS_CMD - команда для запуска “ps”
* EXIWHAT_PS_ARG - аргумент для “ps”
* EXIWHAT_EGREP_ARG - аргумент для “egrep”, для выбора из вывода “ps”
* EXIWHAT_KILL_ARG - аргумент для команды “kill”

Пример типичного вывода *exiwhat*::

    164 daemon: -q1h, listening on port 25
    10483 running queue: waiting for 0tAycK-0002ij-00 (10492)
    10492 delivering 0tAycK-0002ij-00 to mail.ref.example
      [10.19.42.42] (editor@ref.example)
    10592 handling incoming call from [192.168.243.242]
    10628 accepting a local non-SMTP message

Первое число в строке вывода - номер процесса. Третья строка была разделена, чтоб уместиться в странице.

.. _ch50_02:

Селективный просмотр очереди (exiqgrep)
---------------------------------------

Эта утилита - скрипт на Perl, предоставленный Matt Hubbard. Он запускает

::

    exim -bpu

для получения списка очереди, содержащего лишь недоставленных получателей, и затем выбирает из вывода сообщения, которые совпадают с заданными критериями. Доступны следующие параметры выбора:

* **-f <regex>**
  Совпадение с адресом отправителя. Проверяемое поле окружено угловыми скобками, таким образом, вы можете проверить рикошеты используя
  
  ::
  
      exiqgrep -f '^<>$'

* **-r <regex>** 
  Совпадение с адресом получателя. Проверяемое поле не окружено угловыми скобками.

* **-s <regex>**
  Совпадение с полем размера.

* **-y <seconds>**
  Совпедение сообщений, которые раньше данного времени.

* **-o <seconds>** 
  Совпедение сообщений, которые старше данного времени.

* **-z**
  Совпадение лишь с замороженными сообщениями.

* **-x**
  Совпадение лишь с незамороженными сообщениями.

Следующие параметры управляют форматированием вывода:

* **-c**
  Показ только счётчика совпавших сообщений.

* **-l**
  Длинный формат - показывает полную информацию, как в выводе Exim'a. Это - значение по умолчанию.

* **-i**
  Показывает лишь идентификаторы сообщений.
  
* **-b**
  Краткий формат - одна строка на сообщение.
  
* **-R**
  Показывает сообщения в обратном порядке.
  
Есть ещё один параметр, **-h**, которая выводит список всех паарметров.

.. _ch50_03:

Подведение итогов очереди (exiqsumm)
------------------------------------

Утилита **exiqsumm** - скрипт на Perl, который читает вывод ``exim -bp`` и сложение сообщений в очереди. Таким образом, вы можете использовать его путём запуска команды типа такой::

    exim -bp | exiqsumm

Вывод состоит из одной строки для каждого домена, который имеет ожидающие сообщения, как в следующем примере::

    3   2322   74m   66m  msn.com.example

Каждая строка перечисляет висящие доставки для домена, их полный объём, и отрезки времени, которые ожидают самое старое и самое новое сообщения. Отметьте, что число зависших доставок больше чем число сообщений, когда сообщения имеют более одного получателя.

Итоговая строка выводится в конце. По умолчанию, вывод сортируется по доменному имени, но *exiqsumm* обладает параметрами **-a** и **-c**, вызывающих сортировку вывода по наиболее старым сообщениям, и по счётчику сообщений, соответственно. Также есть три параметра, которые делят сообщения для каждого домена в два или более подсчётчика: **-b** - отделяет рикошеты, **-f** - отделяет замороженные сообщения, и, **-s** - разделяет сообщения по их отправителю.

Вывод ``exim -bp`` содержит оригинальные адреса в сообщении, таким образом, он также применяется к выводу *exiqsumm*. Домены созданные из адресов в результате перенаправления и подстановки синонима - не включаются (если не использовался параметр **one_time** маршрутизатора **redirect** для конвертации из в адреса “верхнего уровня”).

.. _ch50_04:

Извлечение специфической информации из лога (exigrep)
-----------------------------------------------------

Утилита *exigrep* - скрипт на Perl, который ищет по одному или нескольким главным логам элементы совпадающие с заданным шаблоном. Когда он находит совпадение, он извлекает все записи логов для уместного сообщения, а не только совпавшие с шаблоном. Таким образом, *exigrep* может извлекать полный лог для заданного сообщения, или всю почту для заданного пользователя, или для заданного хоста, например. Входные файлы должны быть в формате логов Exim'a или syslog. Если совпадающие строки логов не ассоциируются с определённым сообщением, то они включаются в вывод *exigrep* без каких-либо дополнительных строк. Использование::

    exigrep [-t<n>] [-I] [-l] [-v] <pattern> [<log file>] ...

Если имя лог-файла не дано в командной строке, читается стандартный ввод.

Аргумент **-t** определяет число секунд. Он добавляет дополнительное условие для выбора сообщения. Сообщения которые являются полными, показываются лишь если они провели в очереди более чем *<n>* секунд.

По умолчанию, *exigrep* ищет регистронезависимо. Параметр **-I** делает его регистрозависимым. Это может повысить производительность при поиске по большим файлам журналов. Без **-I**, шаблон Perl'a проверяется с использованием параметра “/i”; c **-I** - без неё. В обоих случаях, возможно изменить регистрозависимость внутри шаблона, используя “(?i)” или “(?-i)”

Параметр **-l** - буквальная, для обработки всех символов шаблона как они есть. Иначе шаблон должен быть регулярным выражением Perl.  Сравнение шаблона нечувствительно к регистру. Если в командной строке не задано имя файла, читается стандартный ввод.

Параметр **-v** - инвертирует совпадение. Таким образом, выбираются строки не совпадающем с шаблоном.

Если местоположение команды *zcat* известно из определения ZCAT_COMMAND в *Local/Makefile*, *exigrep* автоматически передаёт файлы, чьи имена заканчиваются на COMPRESS_SUFFIX, через *zcat* и затем ищет.

.. _ch50_05:

Отбор сообщений по различным критериям (exipick)
------------------------------------------------

Утилита John Jetmore - *exipick*, включена в дистрибутив Exim'a. Она выводит список сообщений из очереди согласно разнообразным критериям. Для детальной информации *exipick* посетите страницу http://www.exim.org/eximwiki/ToolExipickManPage, или запустите *exipick* с параметром **--help**.

.. _ch50_06:

Ротация лог-файлов (exicyclog)
------------------------------

Скрипт *exicyclog* может быть использован для ротации логов *mainlog* и *rejectlog*. В этом нет необходимости лишь если используется syslog, или если вы используете файлы логов со штампом даты в их именах (смотрите раздел :ref:`49.3 <ch49_03>`). Некоторые операционные системы имеют собственные стандартные механизмы для ротации логов, и, если предпочитаете, они могут использоваться вместо *exicyclog*. Есть два варианта параметров командной строки для *exicyclog*:

* **-k <count>** - определяет число оставляемых лог-файлов, замещает значение по умолчанию, установленное при сборке Exim'a. Значение по умолчанию этого счётчика - 10.

* **-l <path>** - определяет путь к файлам логов, в том же формате, что и в параметре Exim'a *log_file_path* (например, */var/log/exim_%slog*), замещая значение по умолчанию скрипта, который находит значение из конфигурации Exim'a.

Каждый раз при запуске *exicyclog* файлы передвигаются вниз на один. Если имя главного лока файлов - *mainlog* (по умолчанию), тогда при запуске *exicyclog* *mainlog* становиться *mainlog.01*, предыдущий *mainlog.01* в *mainlog.02* и т.д. до предела, установленного в скрипте или параметром **-k**. От файлы логов, чьи имена превысили лимит - отказываются. Лог отклонённых обрабатывается подобным образом.

Если лимит более 99, скрипт использует 3-х цифровые номера, типа *mainlog.001*, *mainlog.002*, и т.д. Если вы изменяете число менее 99 на большее чем 99, или наоборот, вы должны будете исправить имена существующих логов.

Если файл *mainlog* не существует, скрипт ничего не делает. Файлы которые достигли конца - удаляются. Все файлы чей номер более 01 - сжимаются, используя команду сжатия сконфигурированную установкой COMPRESS_COMMAND в *Local/Makefile*. Обычно, *exicyclog* запускается ежедневно из root`ового *crontab*, строкой формы::

    1 0 * * * su exim -c /usr/exim/bin/exicyclog

предполагая, что вы используете для пользователя Exim'a имя “exim”. Вы можете запускать *exicyclog* от root`a, если вы этого желаете, но в этом нет необходимости.

.. _ch50_07:

Почтовая статистика (eximstats)
-------------------------------

Скрипт на Perl с именем *eximstats* предоставлен для извлечения статистической информации из лог-файлов. Вывод - является простым текстом, или HTML. Логи Exim'a также поддерживаются системой “Lire”, сделанной LogReport Foundation http://www.logreport.org/.

Скрипт был нерабочим а течение долгого времени. Последняя версия - результат довольно большой переработки Steve Campbell. По умолчанию, даётся много информации, но есть параметры для подавления некоторых её частей. После любых параметров, аргументами должны быть файлы главного лога. Например::

    eximstats -nr /var/spool/exim/log/mainlog.01

По умолчанию, *eximstats* извлекает информацию о числе и объёме сообщений полученных или доставленных на различные хосты. Информация сортирована по обоим, счётчику сообщений и по объёму, и высшие 50 хостов, в каждой категории, перечислены в стандартном выводе. Подобная информация, основанная на почтовых адресах или доменах, может быть запрошена при помощи различных параметров. Для сообщений, доставляемых и передаваемых локально, подобная статистика делается на основании пользователей.

Вывод, также включает общий счётчик и статистику о ошибках доставки, и гистограммы, показывающие число сообщений переданных и доставленных на каждый час дня. Доставки с более чем одним адресом в конверте (например, SMTP транзакция с более чем одной командой RCPT) подсчитывается как одна доставка.

Хотя, обычно, уведомляется о большем числе доставок чем приёмов (поскольку сообщения могут иметь более одного получателя), “eximstats” может сообщить сообщить о большем числе отправленных сообщений, чем было получено, даже если очередь пуста в начале и в конце рассматриваемого периода. Если входящее сообщение не содержит допустимых получателей, для него доставки не записываются. Рикошеты обрабатываются как полностью независимые сообщения.

Скрипт *eximstats* всегда выводит полное резюме, дающее объём и число переданных и доставленных сообщений, и число хостов вовлечённых в каждый случай. Также он выводит число задержанных сообщений (т.е. которые не были полностью доставлены в первую попытку), и число тех, у которых хотя бы один ардет был неудачен.

Оставшийся вывод находится в секциях, которые могут быть независимо отключены, или модифицированы различными параметрами. Он состоит из изложения доставко по транспортам, гистограмм сообщений переданных и доставленных по интервалу времени (по умолчанию - по часу), информации р времени сообщений проведённом в очереди, списке доставленных сообщений, списке высших 50 хостов по отправке, локальных отправителей, хостов назначения, и назначении локальных пользователей по счётчику и объёму, и списку происходивших ошибок доставки.


Информация о доставке перечисляет список сообщений которые были действительно доставлены, т.е. которые прибыли с удалённого хоста и были непосредственно доставлены на некоторый другой удалённый хост, без локальной обработки (например, без перенаправления или подстановки синонима).

Есть довольно много вариантов управления параметрами *eximstats*, для точного управления его выводом. Они непосредственно задокументированы в перл-скрипте, и могут быть извлечены путём запуска команды *perldoc* для скрипта. Например::

    perldoc /usr/exim/bin/eximstats

.. _ch50_08:

Проверка политики доступа (exim_checkaccess)
--------------------------------------------

Аргумент командной строки **-bh** позволяет вам запускать поддельную SMTP сессию с отладочным выводом, для проверки, что делает Exim когда применяет управление политиками ко входящей SMTP-почте. Однако, не все достаточно знакомы с протоколом SMTP, чтобы быть в состоянии полностью использовать **-bh**, и иногда вы лишь хотите ответа на вопрос - имеет ли какой-то адрес доступ? - без получения дополнительных деталей.

Утилита *exim_checkaccess* - “упакованная” (“packaged”) версия **-bh**. Она понимает два аргумента, IP-адрес и адрес электронной почты::

   exim_checkaccess 10.9.8.7 A.User@a.domain.example

Утилита управляет вызовом Exim с параметром **-bh**, для тестирования, будет ли принят данный почтовый адрес в команде RCPT в соединении TCP/IP от хоста с заданным IP адресом. Вывод утилиты - или слово “accepted”, или ошибочный ответ SMTP, например::

    Rejected:
    550 Relay not permitted

При работе этого теста, утилита использует “<>” как отправителя конверта в команде MAIL, но вы можете это изменить, предоставляя дополнительные параметры. Их передают непосредственно команде Exim'a. Например, для задания, что тест запускается с адресом отправителя *himself@there.example*, вы можете использовать::

    exim_checkaccess 10.9.8.7 A.User@a.domain.example \
                     -f himself@there.example

Отметьте, что эти дополнительные элементы командной строки Exim'a нужно давать после двух обязательных элементов.

Поскольку *exim_checkaccess* использует **-bh**, он не выполняет обратный вызов при проведении проверки. Вы можете запустить проверку с включением обратного вызова используя **-bhc**, но это недоступно в “упакованной” (“packaged”) форме.

.. _ch50_09:

Создание файлов DBM (exim_dbmbuild)
-----------------------------------

Программа *exim_dbmbuild* читает входной файл, содержащий ключи и данные в формате используемом поиском **lsearch** (смотрите раздел :ref:`9.3 <ch09_03>`). Она пишет файлы DBM используя имена синонимов в нижнем регистре как ключи, и оставшуюся информацию - как данные. Приведение к нижнему регистру может быть предотвращено путём вызова программы с параметром **-nolc**.

Завершающий ноль включается как часть ключевой строки Это ожидается типом поиска **dbm**. Однако, если задан параметр **-nozero**, *exim_dbmbuild* создаёт файлы без завершающих нулей в строках ключей, или строках данных. Тип поиска **dbmnz** может быть использован с такими файлами.

Программа требует двух аргументов: имя входного файла (который может быть одним дефисом, для индикации стандартного ввода), и именем выходного файла. Она создаёт вывод с временным именем, и, затем, переименовывает его, если всё успешно.

Если используется родной интерфейс DB (USE_DB установлена в компиляционном конфигурационном файле - это часто бывает в свободных версиях UNIX) два имени файлов должны быть различными, поскольку в этом режиме, функции Berkeley DB создают один выходной файл, используя точно заданное имя. Например::

    exim_dbmbuild /etc/aliases /etc/aliases.db

читает файл системных синонимов, и создаёт его DBM версию в */etc/aliases.db*.

В системах, которые используют шаблоны *ndbm* (большинство проприетарных версий UNIX), используются два файла, с суффиксами *.dir* и *.pag*. В этом окружении, суффиксы добавляются ко второму аргументу *exim_dbmbuild*, таким образом он может быть как и первый. Это также имеет место, когда функции Berkeley используются в совместимом режиме (хотя это не рекомендуется), поскольку в этом случае к имени файла добавляется суффикс *.db*.

Если происходит столкновение с двойным ключом [#]_, программа выводит предупреждение, и после завершения, она возвращает код 1, а не ноль, если не задан параметр **-noduperr**. По умолчанию, используется лишь первый дубликат - это делает её совместимой с поисками **lsearch**. Также, есть параметр **-lastdup**, вызывающий использование последнего дубликата вместо первого. Ещё есть параметр **-nowarn**, который останавливает перечисление двойных ключей на “stderr”. Для других ошибок, при которых новый файл, фактически, не создаётся, код возврата - 2.

.. _ch50_10:

Нахождение индивидуальных времён повторов (exinext)
---------------------------------------------------

Утилита, называемая *exinext* (по большей части - скрипт Perl), предоставляет возможность выбрать специфическую информацию из БД повторов. Данный почтовый домен (или полный адрес) ищется в хостах для этого домена, и выводит любую информацию повторов для хоста или домена. В настоящее время, информация повторов получается путём запуска *exim_dumpdb* (смотрите ниже), и последующей обработки её вывода. Например::

    $ exinext piglet@milne.fict.example
    kanga.milne.example:192.168.8.1 error 146: Connection refused
      first failed: 21-Feb-1996 14:57:34
      last tried:   21-Feb-1996 14:57:34
      next try at:  21-Feb-1996 15:02:34
    roo.milne.example:192.168.8.3 error 146: Connection refused
      first failed: 20-Jan-1996 13:12:08
      last tried:   21-Feb-1996 11:42:03
      next try at:  21-Feb-1996 19:42:03
      past final cutoff time

Также, вы можете дать *exinext* локальную часть, без домена, и он выдаст любую информацию повторов для этой локальной части, в вашем домене по умолчанию. Идентификатор сообщения может использоваться для получения информации повторов относящейся к специфическому сообщению. Она существует лишь когда попытка доставки сообщения на удалённый зост привела к специфической для сообщения ошибки (смотрите раздел :ref:`45.2 <ch45_02>`). *exinext* - не очень эффективен, но, как ожидается, он не будет часто запускаться.

Утилита *exinext* вызывает Exim для нахождения информации, типа расположения spool-директории. Утилита имеет параметры **-C** и **-D**, передаваемые командам “exim”. Первая определяет альтернативный конфигурационный файл Exim'a, и вторая устанавливает макрос для использования в конфигурационном файле. Эти особенности должны помочь в тестировании, но они, также, могли бы быть полезны в окружении, где используется более одного конфигурационного файла.

.. _ch50_11:

Обслуживание БД подсказок
-------------------------

Три утилиты предоставляются для обслуживания файлов DBM, которые Exim использует для хранения его информации подсказок о доставках. Каждая программа требует двух аргументов. Первый определяет имя директории спула Exim'a, и второй - имя БД с которой она работает. Они, таковы:

* *retry*: БД информации повторов
* *wait-<transport name>*: БД информации о сообщениях, ожидающих удалённых хостов
* *callout*: кэш обратных вызовов
* *ratelimit*: данные для осуществления условий ACL ограничения частоты
* *misc*: иные данные подсказок

БД *misc* используется для

* Сериализации запусков ETRN (когда установлена **smtp_etrn_serialize**)
* Сериализации доставки к специфическому хосту (когда **smtp_etrn_serialize** установлена в транспорте **smtp**)

.. _ch50_12:

exim_dumpdb
-----------

Всё содержимое БД пишется на стандартный вывод, при помощи программы *exim_dumpdb*, которая не имеет параметров или аргументов кроме как имена спула и БД. Например, для дампа БД повторов::

    exim_dumpdb /var/spool/exim retry

На каждое вхождение производится две строки вывода::

   T:mail.ref.example:192.168.242.242 146 77 Connection refused
   31-Oct-1995 12:00:12 02-Nov-1995 12:21:39 02-Nov-1995 20:21:39 *

Первый элемент в первой строке - ключ записи. Он начинается с одной из букв - “R” или “T”, в зависимоти от того, ссылается ли она на повтор маршрутизации, или транспорта. Для локальной доставки, следующая часть - локальный адрес; для удалённой доставки - это имя удалённого хоста, сопровождаемое его неудачным IP-адресом (за исключением случая когда **retry_include_ip_address** установлена в “false” в транспорте **smtp**). Если удалённый порт не стандартный (порт 25), он добавляется к IP-адресу. Затем следует код ошибки, дополнительный код ошибки, и текстовое описание ошибки.

Три времени во второй строке - время первой ошибки, время последней попытки доставки, и вычисленное время для следующей попытки. Строка завершается звёздочкой, если время убывания для последнего повтора было превышено.

Каждая строка вывода *exim_dumpdb* для БД *wait-xxx* содержит имя хоста, сопровождаемое списком идентификаторов для сообщений, которые есть, или ждут доставки на этот хост. Если для какого-то хоста очень много [#]_, могут быть замечены повторяющиеся записи, с номерами последовательности добавленным к имени хоста. Данные в этих записях, часто являются устаревшими, поскольку сообщение может быть маршрутизировано к нескольким альтернативным хостам, и Exim не предпринимает усилий для ведения перекрёстных ссылок.

.. _ch50_13:

exim_tidydb
-----------

Утилита *exim_tidydb* используется для упорядочивания содержимого БД подсказок. Если она запускается без параметров, она удаляет все записи, которые старше 30 дней. Возраст вычисляется из даты и времени, когда запись была последний раз обновлена. Отметьте, что в случае БД повторов, это не время с момента первого отказа. Информация о хосте, который лежал более 30 дней останется в БД, при условии, что записи обновляются достаточно часто.

Дата сокращения может быть изменена путём параметра **-t**, который должен сопровождаться временем. Например, для удаления всех записей которые старше недели из БД повторов::

    exim_tidydb -t 7d /var/spool/exim retry

Обе БД - *wait-xxx* и *retry*, содержат элементы, которые вовлекают идентификаторы сообщений. Они фигурируют в форме данных в записях, где ключи - хосты, они были сообщениями ожидавшими этих хостов - и в последующем они - ключи для информации о сообщениях, перенёсших определённые типы ошибок. Когда *exim_tidydb* работает, производится проверка? что идентификаторы сообщений записанные в БД - это сообщения, которые всё ещё в очереди. Идентификаторы для сообщений, которые больше не существуют, удаляются из записей *wait-xxx*, и если остаются пустые записи, они удаляются. Для БД *retry*, удаляются записи чьи ключи - идентификаторы несуществующих сообщений. Утилита *exim_tidydb* выводит комментарии на стандартный вывод каждый раз, когда она удаляет информацию из БД.

Определённые записи автоматически удаляются Exim'ом когда они больше не нужны., но иные не удаляются. Например, если все MX хосты домена лежат, записи повторов создаются для каждого из них. Если первичный MX подымется первым, его запись удалится, когда Exim успешно доставит на него, но записи для других - останутся, поскольку Exim не пробовал эти хосты.

Это важно, поэтому, периодически запускайте *exim_tidydb* для всех БД подсказок. Вы должны делать это в спокойное время суток, поскольку она требует, чтобы БД была заблокирована (и, поэтому, недоступна Exim'y) когда она работает. Удаление записей из файлов DBM, обычно, не делает файл меньше, но все обычные библиотеки DBM умеют заново использовать освобождённое место. После начальной фазы увеличения в размере, БД, обычно, достигают точки, в которой они не становятся намного больше, пока они регулярно обслуживаются.

.. warning:: Если вы никогда не будете запускать *exim_tidydb*, то вероятно, используемое БД подсказок место будет продолжать увеличиваться.

.. _ch50_14:

exim_fixdb
----------

Программа *exim_fixdb* - утилита для интерактивной модификации БД. Главное её использование - для тестирования Exim'a, но, также, иногда она может быть полезна для обхода проблемы на живой системе. Она не имеет параметров, и её интерфейс несколько грубоват. На входе, она выводит подсказку в виде правой угловой скобки. В это время может быть введён ключ записи, и будут отображены данные для этой записи.

Если в следующем приглашении будет введено “d”, запись будет удалена. Для всех кроме БД *retry*, это - единственная возможная операция. Для БД *retry*, каждое поле предшествуется номером, и данные для индивидуальных полей могут быть изменены путём ввода номера поля, сопровождаемого новыми данными, например::

    > 4 951102:1000

сбросит время следующей попытки доставки. Значение времени даётся как последовательность цифровых пар для года, месяца, дня, часа, и минут. Двоеточия могут использоваться как необязательные разделители.

.. _ch50_15:

Обслуживание почтового ящика (exim_lock)
----------------------------------------

Утилита *exim_lock* блокирует файл почтового ящика, используя тот же самый алгоритм что и Exim. Для обсуждения проблем блокировки, смотрите раздел :ref:`26.3 <ch26_03>`. *exim_lock* может быть использована для предотвращения какой-либо модификации почтового ящика Exim'ом или пользовательским агентом, при исследовании проблемы. Утилита требует имя файла как её первый аргумент. Если блокировка успешна, второй аргумент запускает команду (используя функцию “system()” С); если второй аргумент не задан, используется значение переменной окружения SHELL; если она не задана или пуста, запускается */bin/sh*. Когда команда завершается, почтовый ящик разблокируется, и утилита завершается. Доступны следующие параметры:

  **-fcntl** 
    Использовать для блокировки открытого почтового ящика *fcntl()*.

  **-flock** 
    Использовать для блокировки открытого почтового ящика *flock()*, если операционная система это поддерживает.

  **-interval**
    Она должна сопровождаться числом, которое - число секунд; она устанавливает интервал засыпания между повторами (по умолчанию - 3).

  **-lockfile**
    Созавать файл блокировки до открытия почтового ящика.

  **-mbx** 
    Блокировать почтовый ящик используя правила MBX.

  **-q**
    Убрать проверочный вывод.

  **-retries** 
    Она должна сопровождаться числом; оно устанавливает сколько будет предприниматься попыток установить блокировку (по умолчанию - 10).

  **-restore_time**
    Этот параметр заставляет *exim_lock* восстанавливать время изменения и время чтения блокированного файла до выхода. Это позволяет получить вам доступ к блокированному почтовому ящику (например, чтобы получить резервную копию) не изменяя время, которое впоследствии увидит пользователь.

  **-timeout**
    Она должна сопровождаться числом, которое - число секунд; оно устанавливает таймаут который будет использоваться с блокировкой *fcntl()*. Если она не установлена (по умолчанию), используются неблокирующие вызовы.

  **-v**
    Выводить подробный вывод.

Если не заданы **-fcntl**, **-flock**, **-lockfile** или **-mbx**, по умолчанию создаётся файл блокировки, и, также, на почтовом ящике используется блокировка *fcntl()*, что делает и Exim, по умолчанию. Использование **-flock** и **-fcntl** требует чтобы было право писать в файл; использование **-lockfile** требует чтобы было право записи в директорию, содержащую файл. Блокировка путём файла не длится вечно; Exim предполагает, что блокировка истекла, если он старее 30 минут.

Параметр **-mbx** может использоваться с одной, или обоими - **-fcntl** или **-flock**. По умолчанию, предполагается **-fcntl**. Блокирока MBX вызывает отключение общей блокировки открытого почтового ящика, и эксклюзивную блокировку на файле */tmp/.n.m*, где “n” и “m” - номер устройства и номер иноды файла почтового ящика. Когда блокировка снята, если для почтового ящика может быть получена эксклюзивная блокировка, файл в */tmp* - удаляется.

Вывод по умолчанию содержит проверки имеющих место блокировок. Параметр **-v** вызывает выдачу некоторой дополнительной информации. Параметр **-q** подавляет весь вывод, исключая сообщения о ошибках.

Команда типа::

    exim_lock /var/spool/mail/spqr

запускает интерактивный shell, когда файл заблокирован, тогда как::

    exim_lock -q /var/spool/mail/spqr <<End
    <some commands>
    End

запускает определённую неинтерактивную последовательность команд, когда файл заблокирован, подавляя весь проверочный вывод. Одна команда может быть запущена командой типа::

    exim_lock -q /var/spool/mail/spqr \
      "cp /var/spool/mail/spqr /some/where"

Отметьте, что если команда предоставлена, она должна полностью находиться во втором аргументе, следовательно - в кавычках.


.. [#] повторяющимся - прим. lissyara
.. [#] идентификаторов, наверное - прим. lissyara
