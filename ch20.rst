
.. _ch20_00:

Маршрутизатор **manualroute**
=============================

Маршрутизатор **manualroute** назван таким образом потому что он предоставляет возможность “ручной” маршрутизации (manual routing) адреса в соответствии с его доменом. Главным образом он используется в случае, когда вы хотите маршрутизировать почту на удаленные узлы по собственным правилам, в обход обыкновенной DNS-маршрутизации, механизм которой выполняет поиск MX-записей. Однако, маршрутизатор **manualroute** также может выполнять маршрутизацию на локальные транспорты, такая возможность может оказаться полезной, если вы хотите сохранять сообщения для входящих (dial-in) узлов в локальных файлах.

Маршрутизатор **manualroute** сравнивает список доменных шаблонов с доменной частью адреса, который он пытается маршрутизировать. Если совпадения не найдено, то маршрутизатор отклоняется. Каждый шаблон, ассоциированный с маршрутизатором представляет собой список узлов, а также другую дополнительную информацию, в которую может входить транспорт. Комбинация шаблона и других его данных называется “правилом маршрутизации”. Для шаблонов, не имеющих ассоциированного с ними транспорта, общий параметр маршрутизаторов **transport** должн определять соответствующий транспорт, если только маршрутизатор не используется исключительно для проверки (verification) (см. параметр **verify_only**).

В случае, если маршрутизатор используется для проверки, то совпадения с доменным шаблоном достаточно для того, чтобы маршрутизатор принял адрес. В действительности, при маршрутизации адреса для доставки, доменная часть которого совпала с  доменным шаблоном, адрес помещается в очередь ассоциированного с маршрутизатором транспорта. Если транспорт не является локальным, то с шаблоном должен быть ассоциирован список узлов (host list); выполняется разрешение имен в IP-адреса, которые затем передаются транспорту вместе с почтовым адресом. Для локального транспорта список узлов (host list) является необязательным. Если он присутствует, то он передается в переменной $host как простая текстовая строка.

Список правил маршрутизации может быть определен как строка, включенная (inline string) в параметр **route_list**, либо как данные, полученные путем поиска домена в файле или базе данных, определенных параметров **route_data**. Только одна из них может быть определена в пределах одного экземпляра маршрутизатор **manualroute**. Формат правил маршрутизации описан ниже, вслед за списком частных параметров **manualroute**.

.. _ch20_01:

Частные парметры **manualroute**
--------------------------------

Частные параметры для **manualroute** таковы:

.. index::
   pair: manualroute; host_all_ignored

====================  ================  ============  ==============
**host_all_ignored**  Use: manualroute  Type: string  Default: defer
====================  ================  ============  ==============

Смотрите **host_find_failed**.

.. index::
   pair: manualroute; host_find_failed

====================  ================  ============  ===============
**host_find_failed**  Use: manualroute  Type: string  Default: freeze
====================  ================  ============  ===============

Этот параметр управляет тем, что происходит когда **manualroute** пытается найти IP-адрес узла, а его не существует. Параметру может быть дано одно из следующих значений::

    decline
    defer
    fail
    freeze
    ignore
    pass

Значение по умолчанию (freeze”) предполагает, что данное состояние - серьезная конфигурационная ошибка. Разница между значениями “pass” и “decline” состоит в том, что предыдущий пункт принудительно передает адрес следующему маршрутизатору (либо маршрутизатору, указанному в параметру **pass_router**), перекрывая параметр **no_more**, тогда как в недавнем прошлом адрес передавался следующему маршрутизатору только в случае истинности параметра **more**.

Значение “ignore” заставляет Exim полностью игнорировать хост, чей IP адрес не может быть найден. Если все хосты в списке проигнорированы, поведение контролируется параметром **host_all_ignored**. Она может принимать те же самые значения, что и **host_find_failed**, за исключением того, что этот параметр не может быть установлена в “ignore”.

Параметр **host_find_failed** применяется только к состоянию “не существует”; если поиск узла выдает временную ошибку, то доставка откладывается, только если не установлена общий параметр **pass_on_timeout**.

.. index::
   pair: manualroute; hosts_randomize

===================  ================  =============  ==============
**hosts_randomize**  Use: manualroute  Type: boolean  Default: false
===================  ================  =============  ==============

Если установлен этот параметр, то порядок элементов в списке узлов внутри правила маршрутизации каждый раз выбирается случайным образом при обращении к нему, если не перекрывается параметром в самом правиле маршрутизации (см. ниже). Выбор порядка узлов в списке случайным образом может быть использован для первичного распределения нагрузки. Однако, если один и тот же маршрутизатор маршрутизирует более одного почтового адреса на один и тот же список узлов, то списки должны быть одинаковыми (даже если они расположены в случайном порядке) для решения о том, помещать ли несколько доставок в одну SMTP-транзакцию. 

В случае если параметр **hosts_randomize** истинна, список узлов может быть разделен на группы, порядок которых отдельно устанавливается случайным образом. Это делает возможным установить MX-подобное поведение. Границы между группами помечаются символом “+” в списке узлов. Например,

::

    route_list = * host1:host2:host3:+:host4:host5

Порядок, в котором сортируются первые три узла и порядок сортировки последних двух выбирается случайным образом при каждом использовании, но первая группа всегда располагается перед второй. Если параметр **hosts_randomize** не установлена, символ разделителя “+” в списке игнорируется. Если такой список узлов со случайной внутренней сортировкой, предается транспорту **smtp**, который также имеет подобный параметр **hosts_randomize**, то список заново не создается в случайном порядке.

.. index::
   pair: manualroute; route_data

==============  ================  =============  ==============
**route_data**  Use: manualroute  Type: string†  Default: unset
==============  ================  =============  ==============

Если этот параметр определен, то ее значение должно раскрываться, т.к. она определяет данные правила маршрутизации. Обычно, раскрываемая строка включает в себя поиск на основе домена. Например::

    route_data = ${lookup{$domain}dbm{/etc/routes}}

Если раскрытие строки принудительно завершилось неудачей, либо результатом явилась пустая строка, то маршрутизатор пропускается. Другие причины неудачного раскрытия ведут к откладыванию доставки.

.. index::
   pair: manualroute; route_list

==============  ================  =================  ==============
**route_list**  Use: manualroute  Type: string list  Default: unset
==============  ================  =================  ==============

Эта строка является списком правил маршрутизации в форме, определенной ниже. Обратите внимание, что в отличие от большинства списков строк, элементы здесь разделяются символом “;”. Так сделано, потому что данный список может содержать разделенные символом “:” списки узлов.

.. index::
   pair: manualroute; same_domain_copy_routing

============================  ================  =============  ==============
**same_domain_copy_routing**  Use: manualroute  Type: boolean  Default: false
============================  ================  =============  ==============

Обычно, адреса с одинаковой доменной частью маршрутизируются маршрутизатором **manualroute** на один и тот же список узлов. Однако, это не может быть допустимо, поскольку параметр и предусловия маршрутизатора могут использовать локальную часть адреса. Поэтому по умолчанию Exim маршрутизирует каждый адрес в сообщении независимо. DNS-серверы используют кэши, поэтому повторяющиеся DNS-запросы не являются помехой, и в любом случае личные сообщения редко имеют много получателей. 

Если у вас функционируют списки рассылки с большим количеством подписчиков из одного домена, и вы используете маршрутизатор **manualroute**, который не зависит от локальной части почтового адреса, то вы можете установить параметр **same_domain_copy_routing** во избежание повторяющихся DNS-запросов для одного и того же домена получателя в сообщении. В этом случае, если маршрутизатор **manualroute** маршрутизирует адрес удаленному транспорту, то все оставшиеся несмаршрутизированные адреса в сообщении, имеющие тот же домен получателя, перенаправляются автоматически без независимой обработки. Однако, это выполняется только в том случае, если не установлены параметры **headers_add** и **headers_remove**.

.. _ch20_02:

Правила маршрутизации в параметре **route_list**
------------------------------------------------

Значением параметра **route_list** является строка, состоящая из последовательности правил маршрутизации, разделенных символом “;”. Если “;” указывается внутри самого правила, то оно должно быть представлено как “;;”. Пустые правила игнорируются. Формат каждого правила - следующий::

    <шаблон домена>  <список узлов>  <параметры>

Следующий пример состоит из двух правил, каждое из которых содержит простой доменный шаблон и не содержит параметров::

    route_list = \
           dict.ref.example  mail-1.ref.example:mail-2.ref.example ; \
           thes.ref.example  mail-3.ref.example:mail-4.ref.example

Три части правила разделяются пробелами. Шаблон домена и список узлов могут быть, если это необходимо, заключены в кавычки, и если это так, то применяются обычные правила для кавычек (quoting rules). Каждое правило параметра **route_list** должно начинаться с шаблона домена (domain pattern), единственного обязательного элемента в правиле. Шаблон должен быть указан в том же формате, что и элемент в доменном списке (domain list) (см. раздел :ref:`10.8 <ch10_08>`), за тем исключением, что он не может быть именем включаемого файла. То есть, он может содержать просто шаблон, либо регулярное выражение, либо поиск в файле или базе данных (с двойным символом “;”, из-за использования “;” как разделителя в параметре **route_list**).


Правила в **route_list** просматриваются до первого совпадения доменного шаблона с маршрутизируемым доменом. Затем, как описано ниже, используются список узлов и параметров.  Если совпадений не найдено, то маршрутизатор пропускается. Если установлен параметр **route_list**, то не должна быть определен параметр **route_data**.

.. _ch20_03:

Правила маршрутизации в параметре **route_data**
------------------------------------------------

Использование параметра **route_list** подходит в случае использования небольшого количества правил маршрутизации. Для больших объемов проще использовать файл или базу данных для хранения информации о маршрутах и вместо нее использовать параметр **route_data**. Значением параметра **route_data** является список узлов со следующими за ним необязательными параметрами. Чаще всего **route_data** определяется как строка, содержащая раскрываемый поиск (expansion lookup). Например, представьте что вы поместили 2 правила маршрутизации в файл::

    dict.ref.example:  mail-1.ref.example:mail-2.ref.example
    thes.ref.example:  mail-3.ref.example:mail-4.ref.example

Эти данные могут быть доступными путем установки::

    route_data = ${lookup{$domain}lsearch{/the/file/name}}

Не увенчавшийся успехом поиск возвращает пустую строку, вследствие этого маршрутизатор пропускается. Однако, не стоит использовать поиск в **route_data**. Единственное требование здесь, это то, что результатом преобразования строки должен быть список узлов, возможно со следующими за ним параметрами, разделенные пробелами. Если список узлов содержит пробелы, то он должен быть заключен в кавычки.

.. _ch20_04:

Формат списка узлов
-------------------

Список узлов, полученный либо через **route_data**, либо через **route_list**, всегда раскрыватся отдельно перед использованием. Если раскрытие завершается неудачно, то маршрутизатор пропускается. Результат преобразования должен быть списком имен и/или IP-адресов. IP-адреса в скобки не помещаются.

* Если список узлов получен из параметра **route_list**, то во время преобразования устанавливаются следующие переменные:

* Если домен удовлетворяет регулярному выражению, то могут быть установлены числовые переменные “$1”, “$2”, и т.д.

  ::

      route_list = ^domain(\d+) host-$1.text.example

* “$0” всегда содержит имя домена целиком.
* “$1” также устанавливается в случае неполного совпадения при поиске в файле.

* Если шаблон, с которым совпал домен, был элементом поиска (lookup item), то данные, поиск которых производился, доступны в переменной “$value”. Например::

      route_list = lsearch;;/some/file.routes $value

Заметьте, что удвоение “;” в шаблоне является обязательным, т.к. “;” - разделитель списка по умолчанию.

.. _ch20_05:

Формат одного элемента хоста
----------------------------

Каждый элемент в списке хостов является или именем хоста или адресом IP, необязательно, с номером порта. При отсутствии номера порта, адрес даётся без квадратных скобок. Когда порт задан, то это отменяет спецификацию порта на транспорте. Порт отделяется от адреса двоеточием. Это приводит к некоторым осложнениям:

* Поскольку двоеточие - разделитель по умолчанию списка хостов, то либо необходимо удвоить двоеточия отделяющие номер порта, или изменить разделитель. Следующие два примера одинаковы::
  
      route_list = * "host1.tld::1225 : host2.tld::1226"
      route_list = * "<+ host1.tld:1225 + host2.tld:1226"

* Когда используются адреса IPv6, всё ставиться ещё хуже, т.к. в них используются двоеточия. Чтобы облегчить такие случаи, разрешено помещать адрес IPv6 или IPv4 в квадратные скобки, если за ним следует номер порта. Например::
  
      route_list = * "</ [10.1.1.1]:1225 / [::1]:1226"

.. _ch20_06:

Как используется список узлов
-----------------------------

В процессе маршрутизации адреса на транспорт **smtp** при помощи **manualroute**, пробуется каждый из узлов в определенном порядке.  Однако, порядок может быть изменен параметром **hosts_randomize** либо в конфигурации маршрутизатора (см. раздел :ref:`20.1 <ch20_01>` выше), либо в конфигурации транспорта.

Узлы могут быть перечислены по именам или по IP-адресам. Имя в списке узлов интерпретируется как имя узла. Имя с последующим за ним суффиксом “/MX” интерпретируется как косвенная ссылка на подсписок узлов, полученный путем поиска MX-записей в DNS. Например, 

::

    route_list = *  x.y.z:p.q.r/MX:e.f.g

Если в списке узлов присутствует порт, он должен указываться в последнею очередь::

    route_list = * dom1.tld/mx::1225

Если установлен параметр **hosts_randomize**, то перед любым поиском порядок элементов в списке сортируется случайным образом. Затем Exim просматривает список; для всех имен без суффикса “/MX”, он выполняет поиск IP-адреса. Если им оказывается адрес интерфейса локальной машины и элемент в списке не стоит первым, то поведение определяется параметром маршрутизатора **self**.

Имя в списке с суффиксом “/MX” заменяется списком узлов, полученных в результате поиска MX-записей для имени. Это всегда выполняется посредством DNS-запроса; параметры **bydns** и **byname** здесь неуместны. Порядок этих узлов определяется, как обычно, по значениям приоритета MX-записей. Поскольку случайная сортировка выполняется перед MX-поиском, то она не влияет на порядок, определенный MX-записями DNS.

Если локальная машина присутствует в подсписке, полученном путем просмотра MX-записей, но не является наиболее предпочитаемым узлом в нем, то она и узлы равного и меньшего приоритета удаляются из подсписка перед тем, как он вставляется в главный список.

Если локальная машина - наиболее предпочтительный узел в MX-списке, то все зависит от того, где в главном списке узлов стоит элемент “/MX”. Если он не является в нем первым элементом (потому как в списке перед ним есть узлы), то Exim отвергает это имя, а также все последующие элементы в главном списке.

Если MX-элемент стоит первым в списке, и локальная машина является наиболее предпочтительным узлом, то все зависит от параметра маршрутизатора **self**.

Неудачные результаты поиска MX-записей в DNS обрабатываются так же как и при поиске IP-адресов: там где это необходимо используются параметры **pass_on_timeout** и **host_find_failed**.

Общий параметр **ignore_target_hosts** применяется ко всем узлам в списке, независимо получены ли он путем поиска MX-записей или нет.

.. _ch20_07:

Как используются параметры
--------------------------

Параметр - это последовательность слов; на практике - присутствует не более трех. Одно из слов может быть именем транспорта, перекрывая парметр маршрутизатора **transport** лишь для данного правила маршрутизации. Другие слова управляют случайной сортировкой списка узлов по каждому правилу отдельно, а также тем как ищутся IP-адреса узлов в процессе маршрутизации на удаленный транспорт. Эти параметры следующие:

* **randomize**: случайно сортировать порядок узлов в списке, перекрывая параметр **hosts_randomize** только для этого правила маршрутизации.
* **no_randomize**: не сортировать случайным образом порядок узлов в списке, перекрывая параметр **hosts_randomize** только для этого правила маршрутизации.
* **byname**: использовать *getipnodebyname()* (*gethostbyname()* на старых системах) для поиска IP-адресов. Эта функция может в конечном счете сделать DNS-запрос, хотя она может выполнить поиск в */etc/hosts* или в других источниках подобной информации.
* **bydns**: искать адресные записи для узлов в DNS, неудачный исход - в случае отсутствия таковых. Если существует временная ошибка DNS (например, таймаут), то доставка откладывается. 

Например::

    route_list = domain1  host1:host2:host3  randomize bydns;\
                 domain2  host4:host5

Если ни параметр **byname**, ни параметр **bydns** не определены, то Exim ведет себя следующим образом: Сначала выполняется DNS-запрос. Если возвращается что-либо отличное от HOST_NOT_FOUND, то используется этот результат. В противном случае, Exim пытается вызвать *getipnodebyname()* или *gethostbyname()*, и результатом поиска становится результат, возвращенный этим вызовом.

.. warning:: На некоторых системах обнаружено, что если в результате DNS-запроса, производимого через функцию *getipnodebyname()*, происходит таймаут, то возвращается HOST_NOT_FOUND вместо TRY_AGAIN. Вот почему по умолчанию сначала выполняется DNS-запрос. Локальная функция вызывается только в том случае, если ответом на него является “no such host”.

Если для узла не найдено IP-адреса, то дальнейшие действия управляются параметром **host_find_failed**.
                         

В случае, когда адрес маршрутизируется на локальный транспорт, поиск IP-адресов не производится. Список узлов передается транспорту в переменной “$host”.

.. _ch20_08:

Примеры manualroute
-------------------

В некоторых из нижеследующих примеров подразумевается присутствие транспорта **remote_smtp**, как это определено в файле конфигурации по умолчанию:

* Маршрутизатор **manualroute** может быть использован для перенаправления всей входящей почты на т.н. “быстрый узел” (“smart host”). Если в главной части конфигурации описан именованный список доменов (named domain list), содержащий к примеру,
  
  ::
  
      domainlist local_domains = my.domain.example

  то вы можете указать для всех остальных доменов отправлять почту на смартхост, при этом ваш первый маршрутизатор будет выглядеть примерно так::
  
      smart_route:
        driver = "manualroute"
        domains = !+local_domains
        transport = remote_smtp
        route_list = * smarthost.ref.example


  В результате этого все адреса, не входящие в список **local_domains**, будут направляться на узел “smarthost.ref.example”. Если указан разделенный “:” список узлов, то они пробуются все по порядку (однако вы можете использовать параметр **hosts_randomize** для того, чтобы изменять порядок каждый раз). Другой способ конфигурации той же самой задачи таков::
  
      smart_route:
        driver = "manualroute"
        transport = remote_smtp
        route_list = !+local_domains  smarthost.ref.example


  Разницы в поведении между этими маршрутизаторами нет. Однако, они ведут себя по-разному если добавить к обоим маршрутизаторам параметр **no_more**. В первом примере, маршрутизатор будет пропущен, если если домен не совпадает с предусловием **domains**; и пробуется всегда следующий маршрутизатор. Если маршрутизатор запускается, то он всегда совпадает с доменом и поэтому никогда не может быть быть отклонен. Поэтому **no_more** не будет иметь эффекта в данном случае. Во втором случае маршрутизатор никогда не пропускается; он всегда выполняется. Однако, если совпадения с доменом не происходит, то маршрутизатор отклоняется. В этом случае параметр **no_more** предотвратит запуск последующих маршрутизаторов.

* “Почтовый концентратор” - это узел, который получает почту для нескольких доменов через MX-записи в DNS и доставляет их через свой механизм маршрутизации. Часто пункты назначения находятся за брандмауэром, с “почтовым концентратором” располагающимся на одной машине, которая может соединяться с машинами внутри и снаружи брандмауэра. Маршрутизатор **manualroute** обычно используют на “почтовом концентраторе” для маршрутизации входящих сообщений на корректные узлы. Для небольшого количества доменов маршрутизация может быть включением (inline) в параметр **route_list**, но для большого количества доменов проще управлять поиском в файле и базе данных.

  Если имена доменов фактически являются именами машин, на которые отправляется почта почтовым концентратором, то конфигурация может быть простой. Например,
  
  ::
  
      hub_route:
        driver = "manualroute"
        transport = remote_smtp
        route_list = *.rhodes.tvs.example  $domain

  Эта конфигурация маршрутизирует домены, совпадающие с шаблоном “\*.rhodes.tvs.example” на узлы, чьи имена такие же как и почтовые домены. Похожий результат может быть получен если имя узла извлекается из имени домена путем манипуляции со строкой. Как альтернативный вариант, можно использовать поиск узла на основе домена::
  
      through_firewall:
        driver = "manualroute"
        transport = remote_smtp
        route_data = ${lookup {$domain} cdb {/internal/host/routes}}

  Результатом поиска должно быть имя узла(узлов) или его IP-адрес на который должен быть смаршрутизирован проверяемый адрес. Если поиск завершается неудачей, то данные о маршрутах оказываются пустыми, в результате чего маршрутизатор отклоняется. Затем адрес передается следующему маршрутизатору.

* Вы можете использовать **manualroute** для доставки сообщений в трубы (pipes) или в файлы в пакетном формате SMTP для дальнейшей транспортировки по каким-либо причинам. Это способ хранения почты для dial-up узла в течение времени когда он не подключен к сети. Запись **route_list** может быть просто доменным именем, например так::
  
        save_in_file:
          driver = "manualroute"
          transport = batchsmtp_appendfile
          route_list = saved.domain.example

  Хотя часто шаблон используется для описания более одного домена. Если есть несколько доменов или групп доменов с различными транспортными требованиями, то разные транспорты могут быть перечислены в информации о маршрутах::
  
        save_in_file:
          driver = "manualroute"
         
          route_list = \
            *.saved.domain1.example  $domain  batch_appendfile; \
            *.saved.domain2.example  \
            ${lookup{$domain}dbm{/domain2/hosts}{$value}fail} \
            batch_pipe

  Первый из них просто передает домен в переменную “$host”, которая не очень полезна (т.к. домен находится также в переменной “$domain”), но второй шаблон выполняет поиск в файле для нахождения переменной для передачи, заставляя маршрутизатор отклонять обработку адреса если поиск завершится неудачно.

* Маршрутизация почты прямиком на программный пакет UUCP - это особый вариант использования **manualroute** в роли шлюза в другое почтовое окружение. Вот пример способа как можно это сделать::
  
      # Transport
      uucp:
        driver = pipe
        user = nobody
        command = /usr/local/bin/uux -r - \
          ${substr_-5:$host}!rmail ${local_part}
        return_fail_output = true

        
      # Router
      uucphost:
        transport = uucp
        driver = "manualroute"
        route_data = \
          ${lookup{$domain}lsearch{/usr/local/exim/uucphosts}}


        
  Файл */usr/local/exim/uucphosts* состоит из записей вида::
  
      darksite.ethereal.example:           darksite.UUCP


     
  Можно описать это проще без добавления и удаления “.UUCP” но этот способ показывает различие между именем домена “darksite.ethereal.example” и именем UUCP-станции “darksite”.


