
.. _ch07_00:

==============================
Файл конфигурации по умолчанию
==============================

Конфигурационный файл по умолчанию, поставляемый с Exim`ом как *src/configure.default*, достаточен для хоста, не имеющему особых требований к почтовой системе. В качестве вводной главы, в конфигурировании Exim`а, этот раздел представляет собой “путь через значения по-умолчанию”, давая краткие пояснения параметров настройки. Детальные описания параметров, даются в последующих главах. Конфигурационный файл по умолчанию содержит много комментариев о том, как изменить значения по умолчанию. Однако, необходимо отметить, что имеется множество параметров, которые вообще не упомянуты в конфигурации по умолчанию.


.. _ch07_01:

----------------------------------
Главные конфигурационные настройки
----------------------------------

Главные (глобальные) конфигурационные параметры должны быть в начале файла. Первое, что необходимо установить, после вводных комментариев, это строка::

    # primary_hostname =
   
Это - закомментированная установка параметра **primary_hostname**. Exim должен знать официальное, полное имя вашего хоста, и тут можно его задать. Однако, в большинстве случаев, вам не нужно устанавливать этот параметр. Когда он не задан, Exim использует системную функцию *uname()*, для получения имени хоста.

Первые три раскомментированные линии таковы::

    domainlist local_domains = @
    domainlist relay_to_domains =
    hostlist   relay_from_hosts = 127.0.0.1

Фактически, они не параметры настройки. Это определения двух именованных списков доменов, и одного именованного списка хостов. Exim позволяет давать имена спискам доменов, хостов и e-mail адресов для облегчения управления конфигурационным файлом (смотрите секцию :ref:`10.5 <ch10_05>`).

Первая строка задаёт список доменов, называемый *local_domains*; он используется позже, в конфигурации, для определения доменов которые нужно доставлять на локальный хост.

Tут, в этом списке, только одно значение, строка “@”. Это специальная форма, вхождение которой означает имя локального хоста. Таким образом, если локалхост называется *a.host.example*, то почта к любому пользователю типа *any.user@a.host.example* будет доставляться локально. Поскольку на имя локалхоста ссылаются косвенно, то можно использовать одинаковый конфиг на разных хостах.

Вторая строка задаёт список доменов, называемый *relay_to_domains*, но список пуст. Позже, в конфигурации, будет часть контролирующая релеинг почты через локальный хост; он позволяет релеить любые домены из этого списка. По умолчанию, здесь, не разрешён релей на основе имён почтовых доменов.

Третья строка задаёт список хостов, называемый *relay_from_hosts*. Этот список используется позже, в конфигурации, для разрешения релея от любых хостов или IP-адресов, которые совпадают со списком. По-умолчанию, в нём содержится только IP-адрес интерфейса обратной петли, что означает, что процессы на локальном хосте могут пересылать почту к другим хостам через Exim, соединяясь с ним по TCP/IP на интерфейсе обратной петли.

Для того, чтобы не было непонимания: в этом пункте конфигурации мы не устанавливаем никаких значений директив. Мы просто задаём некоторые домены и хосты, использующиеся в директивах заданных позже.

Следующие две строки - настоящие параметры настройки::

    acl_smtp_rcpt = acl_check_rcpt
    acl_smtp_data = acl_check_data

Эти параметры задают *Access Control Lists* (списки контроля доступа - ACLs), которые используются в течение входящего SMTP-подключения для каждого получателя сообщения (на каждую команду RCPT), и после того, как сообщение было получено, соответственно. Названия списков - *acl_check_rcpt* и *acl_check_data*, и мы доберёмся до их определения ниже, в конфигурационной секции ACL. RCPT ACL контролирует, какие получатели разрешены для входящих сообщений - если конфигурация не содержит ACL для проверки получателей, то никакая почта по SMTP не принимается. DATA ACL разрешает проверку содержимого сообщения.

Следующие две закомментированные строки::

    # av_scanner = clamd:/tmp/clamd
    # spamd_address = 127.0.0.1 783

Они - пример настроек, которые могут использоваться когда Exim собран с расширением проверки контента(content-scanning extension). Первая задаёт интерфейс к сканеру вирусов, и вторая задаёт интерфейс к SpamAssassin. Дальнейшие детали даются в разделе :ref:`41 <ch41_00>`.

После них идут ещё 3 закомментированные строки::

    # tls_advertise_hosts = *
    # tls_certificate = /etc/ssl/exim.crt
    # tls_privatekey = /etc/ssl/exim.pem

Они являются примером настроек, которые могут использоваться, если Exim скомпилирован с поддержкой TLS (SSL), смотрите секцию :ref:`4.7 <ch04_07>`. Первый параметр задаёт список клиентов, которые при подключении к серверу могут использовать TLS, “*” в этом случае подразумевает любого клиента. Остальные параметры служат для указания того, где Exim должен искать свой TLS сертификат и приватный ключ (private key), которые вместе однозначно идентифицируют сервер для всех клиентов. Вы можете найти дополнительную информацию в главе :ref:`39 <ch39_00>`.

Дальше следуют две закомментированые параметры::

    # daemon_smtp_ports = 25 : 465 : 587
    # tls_on_connect_ports = 465

Эти параметры предоставляют улучшенную поддержку удалённым пользователям, которые желают использовать этот сервер для отправки почты. Они редко используются, если Вы не используете TLS (как его включать было описано в предыдущем параграфе) и аутентификацию (о которой говорится в секции :ref:`7.7 <ch07_07>`). Очень часто стандартный SMTP порт (25-ый) заблокирован для пользователей из конечных сетей (end-user network), поэтому :rfc:`4409` позволяет использовать альтернативный, 587-ой порт для передачи почты. К сожалению некоторые приложения (особенно Microsoft Outlook) не могут быть настроены на использование 587-го порта, т.к. настройки выше также включают нестандартный 465 "smtps" ("ssmtp") порт (см. секцию :ref:`13.4 <ch13_04>`).

Далее ещё две закомментированных строки::

    # qualify_domain =
    # qualify_recipient =

Первая из них задаёт домен, который Exim использует, при создании полного адреса электронной почты, из имени логина локального пользователя. Часто это необходимо при получении Exim`ом почты от локального процесса. Если вы не задали **qualify_domain**, то используется значение **primary_hostname**. Если вы задали оба этих параметра, то можно иметь разные домены для адресов получателей и отправителей. Если же используете только первую, то её значение используется для обоих директив.

Следующая строка может быть раскомментирована, если вы хотите чтобы Exim понимал адреса формы *user@[10.11.12.13]*, то есть с “буквальным доменом” (“domain literal” - IP-адрес в квадратных скобках) вместо именованного домена.

::
                                                      
    # allow_domain_literals

RFC всё ещё требуют эту форму, но много людей считают что в современном интернете посылка почты определённым хостам, указывая их IP-адрес имеет мало смысла. Этот старый формат использовался людьми рассылающими спам. Однако, некоторые полагают, что есть обстоятельства (например письма постмастеру), когда этот формат полезен.

Следующая строка конфигурации, своего рода защита::
                                                            
    never_users = root

Это определяет, что никакая доставка не должна осуществляться от имени пользователя *root*. Нормальное соглашение заключалось в том, что *root* - псевдоним системного администратора. Этот параметр - охранный. Список пользователей, определённых как **never_users** - неполный, при компиляции в *Local/Makefile* есть параметр FIXED_NEVER_USERS, задающая список, который не может быть отменён. Содержимое **never_users** добавляется к списку. По-умолчанию, FIXED_NEVER_USERS содержит пользователя *root*.

Когда удалённый хост подключается к Exim`y, чтобы послать почту, единственная информация, которую имеет Exim, о идентификации хоста - это его IP-адрес. Следующая конфигурационная строка,

::

    host_lookup = *

задаёт, что Exim должен проводить обратный поиск в DNS для всех входящих соединений, чтобы получить имя хоста. Это улучшает качество логов, но если вы чувствуете, что это обходиться слишком дорого, то вы можете удалить этот пункт вообще, или ограничить поиск хостами в соседних сетях. Отметьте, что не всегда можно найти имя хоста по его IP-адресу, поскольку не все обратные DNS-зоны обслуживаются, и некоторые DNS-сервера могут быть недоступны.

Следующие две строки занимаются вызовом *ident*, как определено в :rfc:`1413`, следовательно их имена::

    rfc1413_hosts = *
    rfc1413_query_timeout = 5s

Эти настройки заставляют Exim делать вызовы *ident* для всех входящих SMTP подключений. Вы можете ограничить список хостов, на которые делается этот вызов, или изменить таймаут, если он используется. Можно поставить таймаут в ноль, тогда все вызовы *ident* будут заблокированы. Хотя они обходятся дёшево, и могут дать полезную информацию для трассировки проблем сообщений, некоторые хосты и фаерволлы имеют проблемы с запросами *ident*. Это может привести к таймауту вместо немедленного сброса подключения, в случае отказа, приводя к задержке на старте входящего SMTP подключения.

Когда Exim получает сообщения по SMTP, то ожидается, что все хосты будут иметь полное доменное имя, как требуется по определению SNMP. Однако если на ваш сервер шлют сообщения простые пользователи, то они могут иметь неподходящие адреса. Две закомментированные параметры::

    # sender_unqualified_hosts =
    # recipient_unqualified_hosts =
                                                                           
указывают как вы можете задать хосты, которым разрешается посылать неполные адреса отправителей и получателей (имеются ввиду адреса без домена - тока имя пользователя).

Параметр **percent_hack_domains** также закомментирован::

    # percent_hack_domains =

Она обеспечивает список доменов, для которых должно работать “percent hack”. Это - почти устаревший параметр явной почтовой маршрутизации. Если вы ничего не знаете об этом - то также можете проигнорировать этот параметр. [#]_ 

Два последних параметра настройки конфигурации по умолчанию касаются сообщений, “замороженных” в очереди Exim`a. Когда сообщение заморожено, Exim не продолжает попытки доставить его. Замораживание происходит когда сообщение об отлупе сталкивается с постоянным отказом, поскольку отправитель оригинального сообщения, вызвавшего рикошет, недопустим, и таким образом отлуп нельзя доставить. Это - наиболее частая причина, но есть и другие причины заморозки, и замороженные сообщения - не всегда рикошеты.::

    ignore_bounce_errors_after = 2d
    timeout_frozen_after = 7d

Первый из этих параметров определяет, что рикошеты будут выброшены из очереди через два дня. Второй задаёт что любое замороженное сообщение (рикошет или другое) будет выброшено из очереди через неделю. При таких настройках, гарантируется, что попытки доставки рикошета никогда не будут длиться неделю. [#]_ 


.. _ch07_02:

----------------
Конфигурация ACL
----------------

В настройке по умолчанию, секция ACL следует за главной конфигурацией. Она начинается со строки::

    begin acl

и она содержит определения двух ACL, называемых *acl_check_rcpt* и *acl_check_data* на которые выше ссылались параметры настройки **acl_smtp_rcpt** и **acl_smtp_data**.

Первая ACL, используется для всех команд RCPT для входящих SMTP сообщений. Каждая команда RCPT  определяет одного получателя сообщения. Утверждения ACL рассматриваются до тех пор, пока адрес либо принимается либо отклоняется. Тогда команда RCPT либо принята, либо отклонена, согласно результату обработки ACL.::

    acl_check_rcpt:

Эта строка, состоящая из названия завершённого двоеточием, отмечает начало ACL и именует её.::

    accept  hosts = :

Это утверждение ACL принимает получателя, если хост соответствует списку. Но что означает этот странный список? Он, фактически, не содержит никаких имён хостов, или адресов IP. Присутствие двоеточия, помещает в пустой элемент в список; Exim сопоставляет его только с входящими сообщениями, которые идут не с удалённого хоста (только с локалхоста), поскольку в этом случае, имя удалённого хоста пустой. Двоеточие важно. Без него список пуст, и никогда ничему не соответствует.

То, что делает это утверждение, - разрешает безоговорочный приём всех получателей в сообщениях переданных по SMTP от локальных процессов, с использованием стандартного ввода и вывода (т.е. без использования TCP/IP). Множество MUA работает в такой манере.

::

    deny    message       = Restricted characters in address
            domains       = +local_domains
            local_parts   = ^[.] : ^.*[@%!/|]

    deny    message       = Restricted characters in address
            domains       = !+local_domains
            local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./

Это утверждение занимается тем, чтобы локальная часть адреса не содержали некоторые символы - “@”, “%”, “!”, “/”, “|”, или точки в необычных местах. Хотя эти символы могут абсолютно законно использоваться в локальной части адреса (в случае “@” и начальной точки, только если корректно заэкранировано), обычно они не встречаются в почтовых адресах.

Первые три имеют прошлые ассоциации с явной маршрутизации  адресов (символ процента используется до сих пор - смотрите параметр **percent_hack_domains**). Адреса содержащие эти символы регулярно пробуют спамеры, в попытках обойти ограничения релея почты, и программами проверяющими хост на открытый релей. Если вы в них не нуждаетесь, то самое безопасное - отклонить их на ранней стадии. Эта конфигурация отклоняет эти символы для всех удалённых хостов. Это преднамеренная политика, для достижения, насколько возможно, максимальной безопасности.

Первое правило более строгое, и оно применяется к сообщениям, которые адресованы к одному из локальных доменов, которые крутятся на этом хосте. Это осуществляется первым условием, которое ограничивает его доменами перечисленными в списке *local_domains*.  Символ “+” используется для указания ссылки на именованный список. В данной конфигурации, тут только один домен в *local_domains*, но вообще, может быть несколько.

Второе условие в первом утверждение использует два регулярных выражения, для блокирования локальных частей начинающихся с точки, или содержащих “@”, “%”, “!”, “/”, или “|”. Если у вас есть учётки использующие эти символы, то надо изменить это правило.

Пустые компоненты (две точки подряд) недопустимы по :rfc:`2822`, но Exim разрешает их, поскольку с ними столкнулись практически. (Обычно локальная часть выглядит так: *first-initial.second-initial.family-name*, но иногда бывает, что второго инициала нет, как у автора Exim) Однако, локальная часть начинающаяся с точки, или содержащая “/../” может вызывать проблемы, если она используется как часть имени (например в списке рассылки). Также это истинно для локальных частей содержащих слэши. Символ трубы “|” также может принести неприятности, если локальная часть легкомысленно включена в командную строку шелла.

Второе правило, применяемое ко всем прочим доменам менее строго. Это позволяет локальным пользователям посылать сообщения к другим серверам, использующим слэши и трубы в локальной части адреса. Оно блокирует локальные части начинающиеся с точки, слэша, или трубы, но разрешает эти символы внутри локальной части. Однако, последовательность “/../” - запрещена. Использование “@”, “%”, и “!” заблокировано. Мотивация - запретить пользователям (или пользовательским вирусам) от определённые виды атак на удалённые сервера.

::

    accept  local_parts   = postmaster
            domains       = +local_domains

Это утверждение, имеющее два условия, разрешает входящий адрес если локальная часть *postmaster* и домен - один из перечисленных в списке *local_domains*. Символ “+” используется для указания ссылки на именованный список. В данной конфигурации, тут только один домен в *local_domains*, но вообще, может быть несколько.

Присутствие этого условия означает, что почта предназначенная постмастеру не блокируется последующими проверками. Это может быть полезным, при разборе проблем в последующих проверках, где неверно запрещается доступ.

::

    require verify        = sender

Это утверждение требует, чтобы адрес отправителя был проверен до того, как будут последующие проверки ACL. Если проверка неудачна, то отказывается в доставке входящему адресу получателя.  Проверка состоит из попытки маршрутизировать адрес, с целью выяснить, можно ли по нему доставить сообщение о рикошете. В случае удалённых адресов, проверяется только домен, но для более точной проверки может использоваться *callouts*. Смотрите раздел 40.40 для получения дополнительной информации о проверке адреса.

::

    accept  hosts         = +relay_from_hosts
            control       = submission

Это утверждение принимает адрес, если сообщение приходит с одного из хостов которым разрешён релей через этот хост. Проверка получателя тут опущена, поскольку во многих случаях клиенты - тупые MUA которые не в состоянии справиться ответами об ошибке SMTP. По этой же причине, вторая строка задаёт “режим подчинения” (“submission mode”) для принятых сообщений. Это детально описано в разделе :ref:`44.1 <ch44_01>`; это заставляет Exim`a исправлять сообщения которые не доделаны (неполные или несовершенные), например, потому что у них отсутствует строка заголовка *Date:*. Если вы передаёте их наружу, с MTA, вы, вероятно, должны тут добавить проверку получателя, и отключить режим подчинения.

::

    accept  authenticated = *
            control       = submission
                                                                                                     
Это утверждение принимает адрес, если клиентский хост подтвердил свою подлинность. Снова задан режим подчинения, поскольку сообщения, вероятнее всего, будут прибывать с MUA. В конфигурации по умолчанию не заданы аутентификаторы, хотя, он включает в себя закомемнтированные примеры описанные в :ref:`7.7 <ch07_07>`. Это означает, что, фактически, клиенты не могут аутентифицировать, пока вы не завершите определение айтентификаторов.

::
                                                                                                     
    require message = relay not permitted
            domains = +local_domains : +relay_domains
                                                                                                           
Это утверждение отклоняет адреса, если их домен не является локальным или одним из доменов для которых этот хост является релеем.::

    require verify = recipient
                                                                                                              
Это утверждение требует проверки адреса отправителя; если проверка неуспешна, адрес отклоняется.

::

    # deny    message     = rejected because $sender_host_address \
    #                       is in a black list at $dnslist_domain\n\
    #                       $dnslist_text
    #         dnslists    = black.list.example
    #
    # warn    dnslists    = black.list.example
    # message     = X-Warning: $sender_host_address is in \
    #                 a black list at $dnslist_domain
    #         log_message = found in $dnslist_domain

Эти закомментированные строки - пример того как вы можете сконфигурировать Exim для проверки отправляющего хоста в блэк-листах DNS. Первое утверждение отклоняет сообщения с хостов находящихся в чёрных списках, тогда как второе только добавляет строку заголовка с предупреждением.

::

    # require verify = csa

Эта закомментированная строка - пример того, как вы можете включить проверку клиентской SMTP авторизации (CSA).

::
                                                                                                                    
    accept
    
Финальное утверждение в первой ACL безоговорочно принимает любых отправителей, которые успешно прошли предыдущие тесты.

::

    acl_check_data:

Эта строка отмечает начало второго ACL, и именует его. Большая часть содержимого этого ACL закомментирована::
                                                                                                             
    # deny    malware   = *
    #         message   = This message contains a virus \
    #                     ($malware_name).
    
Эти строки - пример того, как сделать чтобы сообщения были просканированы на вирусы, когда Exim скомпилен с поддержкой проверки контента, и установлен подходящий сканнер вирусов. Если в сообщении найден вирус, то оно отклоняется с заданным сообщением об ошибке.

::

    # warn    spam      = nobody
    #         message   = X-Spam_score: $spam_score\n\
    #                     X-Spam_score_int: $spam_score_int\n\
    #                     X-Spam_bar: $spam_bar\n\
    #                     X-Spam_report: $spam_report
    
Эти строки - пример того, как сделать, чтобы сообщения были просканированы SpamAssassin, когда Exim скомпилен с поддержкой проверки контента, и установлен SpamAssassin. Проверка SpamAssassin`ом выполняется от пользователя nobody, и результаты добавляются к сообщению как ряд дополнительных заголовков. В этом случае, сообщение не отклоняется, вне зависимости от того сколько очков ему поставлено.::

    accept
    
Это заключительная строка в DATA ACL, сообщение принимается безоговорочно.

.. _ch07_03:

---------------------------
Конфигурация маршрутизатора
---------------------------

Конфигурация маршрутизаторов в конфигурации по умолчанию, начинается со следующей линии::

     begin routers

Маршрутизаторы - это модули в Exim`e, принимающие решение о том, куда слать сообщение. Адрес передаётся каждому маршрутизатору, по очереди, и он его либо принимает, либо нет. Это значит, что порядок в котором заданы маршрутизаторы - важен. Каждый маршрутизатор, позднее, полностью описан в его разделе, в этом руководстве. Тут даны только краткие обзоры.

::

    # domain_literal:
    #   driver = ipliteral
    #   domains = !+local_domains
    #   transport = remote_smtp

Этот маршрутизатор закомментирован, поскольку большинство серверов не поддерживает буквальные адреса (вида *user@[10.9.8.7]*). Если вы раскомментируете этот маршрутизатор, также необходимо будет раскомментить параметр **allow_domain_literals** в основной части конфигурации.

::

    dnslookup:
      driver = dnslookup
      domains = ! +local_domains
      transport = remote_smtp
      ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8
      no_more

Первый незакомментированный маршрутизатор обрабатывает адреса, не относящиеся к локальным доменом. Это задано строкой::

    domains = ! +local_domains

Параметр **domains** - список доменов к которым применяется этот маршрутизатор, но восклицательный знак является признаком отрицания (несоответствия), таким образом маршрутизатор используется только для доменов, которые не находятся в списке *local_domains* (который был определён в начале конфигурации). Символ “+” используется для указания ссылки на именованный список. Адреса в других доменах передаются следующим маршрутизатором.

Имя драйвера маршрутизатора - **dnslookup**, оно задано в параметре **driver**. Вас не должно смущать то, что имя маршрутизатора такое же как и имя драйвера. Название примера может быть произвольным, но имя заданное в параметре **driver** - должен быть один из модулей драйверов из исполняемого файла Exim`a.

Маршрутизатор **dnslookup** маршрутизирует адреса, ища их домены в DNS, для получения списка хостов к которым к которым должен маршрутизироваться адрес. Если маршрутизатор успешен, адрес ставиться в очередь транспорта **remote_smtp**, как задано в параметре **transport**. Если маршрутизатор не находит домен в DNS, то никакие дальнейшие маршрутизаторы не рассматриваются из-за параметра **no_more**, таким образом адрес неудачен, и не доставляется (возвращается сообщение о ошибке).

Параметр **ignore_target_hosts** задаёт список IP-АДРЕСОВ, которые должны полностью игнорироваться. Этот параметр присутствует по причине, что было много случаев, когда MX-запись в DNS указывает на имя хоста с адресом 0.0.0.0 или из 127-й подсети (обычно, 127.0.0.1). Полное игнорирование этих адресов лишает возможности Exim маршрутизировать почту к ним, таким образом доставка срывается. Иначе, Exim писал бы в логи о проблеме маршрутизации, и продолжал пытаться доставить сообщение, с определённым таймаутом.

::

    system_aliases:
      driver = redirect
      allow_fail
      allow_defer
      data = ${lookup{$local_part}lsearch{/etc/aliases}}
      # user = exim
      file_transport = address_file
      pipe_transport = address_pipe

      
Управление передаётся этому и последующим маршрутизаторам, только если адрес в локальном домене. Этот маршрутизатор проверяет, задана ли локальная часть как синоним в */etc/aliases*, и если это так, переадресовывает адрес согласно данным найденным в этом файле. Если для локальной части не найдено никаких данных, то значение параметра **data** пустое, и адрес передаётся следующему маршрутизатору.

*/etc/aliases* - обычно это файл системных синонимов. Именно по этому на него, по-умолчанию, ссылается конфигурационный файл. Однако, это можно поменять, изменив параметры SYSTEM_ALIASES_FILE в *Local/Makefile* до сборки Exim`a.

::

    userforward:
      driver = redirect
      check_local_user
      # local_part_suffix = +* : -*
      # local_part_suffix_optional
      file = $home/.forward
      # allow_filter
      no_verify
      no_expn
      check_ancestor
      file_transport = address_file
      pipe_transport = address_pipe
      reply_transport = address_reply


Этот маршрутизатор - самый сложный в конфигурации по умолчанию. Это другой перенаправляющий маршрутизатор, но он ищет данные перенаправления установленные отдельными пользователями. Установка **check_local_user** задаёт проверку локальной части, что она логин локального пользователя. Если это не так - маршрутизатор пропускается. За параметром **check_local_user** следуют два закомментированных п, а именно::

    # local_part_suffix = +* : -*
    # local_part_suffix_optional
    
указывают, как можно задать распознание локальной части суффиксов. Если раскомментировать первое, то суффикс начинающийся с плюса или минуса, за которым идёт какая-то последовательность символов, удаляется из локальной части и помещается в переменную $local_part_suffix. Второй параметр суффикса определяет, что присутствие суффикса в локальной части является необязательным. Когда суффикс есть, проверка локального логина пользователя использует локальную часть без суффикса.

Когда найден локальный аккаунт пользователя, то просматривается файл *.forward* в домашней директории пользователя. Если он не существует, или пуст, то маршрутизатор пропускается. Иначе, содержимое *.forward* интерпретируется как данные перенаправления (для дополнительных деталей, обратитесь к главе :ref:`22 <ch22_00>`).

Традиционный файл *.forward* содержит лишь список адресов, каналов (труб), или файлов. Exim поддерживает всё это по-умолчанию. Однако, если установлен параметр **allow_filter** (по умолчанию, она закомментирована), содержимое файла интерпретируется инструкции Exim`a или sieve, если файл начинается с “#Exim filter” или “#Sieve filter”, соответственно. Фильтры пользователей обсуждаются в отдельном даокументе “Exim’s interfaces to mail filtering”.

Параметры **no_verify** и **no_expn** означают что этот маршрутизатор пропущен, когда проверяется адрес, или когда он выполняется вследствие команды SMTP EXPN. Есть две причины, чтобы это сделать:

1. В действительности, не очень важно, есть у пользователя файл *.forward* или нет, при проверке адреса на существование; это делается сознательно, чтобы не тратить ресурсы на бесполезную работу.
2. Ещё более важно, когда Exim проверяет адрес или обрабатывает команду EXPN во время SMTP сессии он работает от имени своего пользователя, а не от root. Группа - тоже его группа, и никаких дополнительных групп не установлено. Поэтому, вполне возможно, что Exim не сможет прочитать пользовательский файл *.forward* в этот момент.

Установка **check_ancestor** препятствует маршрутизатору создавать новый адрес, являющийся таким же как и предыдущий, который переадресуется. (Это связано с относительно плохим взаимодействием между перенаправлением и подстановкой синонима - смотрите раздел :ref:`22.5 <ch22_05>`)

Три финальных параметра конфигурации задают транспорты, которые должны использоваться когда в результате переадресации происходит прямую доставку в файл, или в трубу, или делает авто-ответ, соответственно. Например, если файл *.forward* содержит::

    a.nother@elsewhere.example, /home/spqr/archive

доставка в */home/spqr/archive* будет осуществлена запуском транспорта **address_file**.

::

    localuser:
      driver = accept
      check_local_user
      # local_part_suffix = +* : -*
      # local_part_suffix_optional
      transport = local_delivery
      

Последний маршрутизатор устанавливает доставку в локальные почтовые ящики, при условии, что локальная часть адреса является логином пользователя, принимая адрес и задавая его транспорту **local_delivery**. Иначе, т.к. достигнут конец маршрутизаторов, адрес возвращается отправителю. Закомментированные настройки суффиксов выполняют ту же самую роль, что и в маршрутизаторе **userforward**.


.. _ch07_04:

-------------------------
Транспортная конфигурация
-------------------------

Транспорты задают механизмы для фактической доставки сообщений. Они работают только когда на них ссылаются маршрутизаторы, таким образом порядок в котором они заданы - неважен. Раздел транспортов начинается с

::

    begin transports

Определены один удалённый и четыре локальных транспорта.

::

    remote_smtp:
      driver = smtp

Этот транспорт используется для доставки сообщений через SMTP-соединение. Все его параметры - по умолчанию. Список удалённых хостов даётся маршрутизатором.

::

    local_delivery:
      driver = appendfile
      file = /var/mail/$local_part
      delivery_date_add
      envelope_to_add
      return_path_add
      # group = mail
      # mode = 0660

Транспорт **appendfile** используется для локальной доставки в пользовательские почтовые ящики, в традиционном формате BSD mailbox. По умолчанию, он запускается под uid и gid локального пользователя, что требует установки *липкого* (*sticky*) бита на директории */var/mail*. Некоторые системы используют иной подход к запуску доставки почты, под специфической группой, вместо использования “липкого” бита. Закомментированные параметры показывают, как это может быть сделано.

При доставке, Exim добавляет к сообщению три заголовка: *Delivery-date:*, *Envelope-to:* и *Return-path:*. Это регулируется тремя параметрами, с подобными названиями.

::

    address_pipe:
      driver = pipe
      return_output

Этот транспорт используется для обработки доставки в каналы, созданных в результате переадресации (подстановка синонима или пользовательским файлом *.forward*). Параметр **return_output** определяет, что любой вывод созданный каналом, должен быть возвращён отправителю.

::

    address_file:
      driver = appendfile
      delivery_date_add
      envelope_to_add
      return_path_add
      
Это транспорт используется для обработки доставки в файлы, произведённый в результате переадресации. Имя файла не задаётся в **appendfile**, поскольку оно приходит от маршрутизатора **redirect**.

::

    address_reply:
      driver = autoreply

Этот транспорт используется для обработки автоматических ответов, созданных пользовательскими фильтрами.


.. _ch07_05:

-----------------------------
Правила повторов по умолчанию
-----------------------------

Секция повторов конфигурационного файла, содержит правила затрагивающие поведение Exim`a при повторах доставки сообщений, которые не удалось доставить с первого раза. Она начинается со строки

::

    begin retry

В конфигурации по умолчанию, есть только одно правило, применяемое ко всем ошибкам::

   *   *   F,2h,15m; G,16h,1h,1.5; F,4d,6h

Это заставляет Exim пытаться доставить любой временно неудачный адрес в течение двух часов каждые 15 минут, затем интервал начинается с часа и увеличивается с фактором полтора пока не пройдёт 16 часов, затем каждые 6 часов, до срока в 4 дня. Если адрес не удаётся доставить после 4-х дней временного отказа, то происходит создание рикошета (письмо возвращается отправителю).

Если секция повторов удалена из конфигурации, или она пуста (т.е. - не задано никаких правил повторов), Exim не предпринимает попыток повторных доставок. Это превращает временные ошибки в постоянные.

.. _ch07_06:

-----------------------
Конфигурация перезаписи
-----------------------

Раздел конфигурации перезаписи, начинаемый с

::

    begin rewrite

содержит правила для перезаписи адресов в прибывших сообщениях. В конфигурации по умолчанию нет правил перезаписи.

.. _ch07_07:

-----------------------------
Конфигурация аутентификаторов
-----------------------------

Секция аутентификаторов файла конфигурации, начинаемая с

::

    begin authenticators

задаёт механизмы для использования в команде SMTP AUTH. В файле конфигурации по умолчанию содержаться два закомментированных примера аутентификаторов, которые поддерживают аутентификацию пользователь/пароль открытым текстом, используя стандартный механизм PLAIN, и традиционный, но нестандартный механизм LOGIN, в которых Exim выступает в роли сервера. PLAIN и LOGIN поддерживаются большинством MUA.

Пример аутентификатора PLAIN выглядит так::

   #PLAIN:
   #  driver                  = plaintext
   #  server_set_id           = $auth2
   #  server_prompts          = :
   #  server_condition        = Authentication is not yet configured
   #  server_advertise_condition = ${if def:tls_cipher }

И пример аутентификатора LOGIN::

   #LOGIN:
   #  driver                  = plaintext
   #  server_set_id           = $auth1
   #  server_prompts          = <| Username: | Password:
   #  server_condition        = Authentication is not yet configured
   #  server_advertise_condition = ${if def:tls_cipher }

Параметр **server_set_id** заставляет Exim запомнить авторизованное имя пользователя в $authenticated_id, которая может быть использована позднее, в ACL или маршрутизаторах. Параметр **server_prompts** настраивает аутентификатор **plaintext** таким образом, что он реализует детали специфического аутентификационного механизма, т.е. - PLAIN или LOGIN. Установка **server_advertise_condition** контролирует, когда Exim посылает клиентам приглашение аутентифицироваться; в примере, это происходит лишь при запуске TLS или SSL, таким образом, для включения этих аутентификаторов вам также необходимо добавить поддержку TLS, как описано в разделе :ref:`7.1 <ch07_01>`.

Установка **server_condition** определяет как проверить корректность пользователя и пароля. В примерах, она просто выводит сообщение о ошибке. Чтобы аутентификаторы заработали, вы должны использовать выражение раскрытия стоки, похожее на примеры в главе :ref:`34 <ch34_00>`.

Помните, что последовательность параметров для PLAIN и LOGIN различна; пользователь и пароль находятся в различных позициях. В главе :ref:`34 <ch34_00>` описаны оба.


.. [#] А вообще имеются ввиду адреса, типа user%domain1.su@domain2.su - когда письмо приходит на сервер domain2.su, а тот уже пересылает его на domain1.su. Но лучше это не использовать - переводчик.
.. [#] (потому как через два дня их выкинут :)))) - кто-то.
