
.. _ch11_00:

Раскрываемые строки
===================

Многие строки, конфигурации Exim, раскрываются перед использованием. Одни раскрываются каждый раз, при использовании, другие же, раскрываются лишь один раз.

Раскрытие строки - дословное копирование её слева направо, исключая символы доллара (“$”) и обратного слэша. Символ “$” задаёт начало части строки, которая интерпретируется и заменяется, как описано ниже, в разделе :ref:`11.5 <ch11_05>`. Обратный слэш используется как экранирующий символ, как описано в следующем разделе.

.. _ch11_01:

Дословный текст в раскрываемых строках
--------------------------------------

Не интерпретируемый “$” может быть включен в раскрываемую строку, путём помещения перед ним обратного слэша. Обратные слэш может быть использован для экранировки любого специального символа, который может быть развёрнут, включая экранирование самого себя, обратного слша. Если используется строка в кавычках, должны использоваться два обратных слэша, поскольку кавычки сами вызывают интерпретацию обратного слэша, при чтении строки (смотрите раздел `6.16 <ch06_16>`).

Часть строки может быть определена как не раскрываемая, при помощи помещения её между двумя символами ``\N``. Это необходимо для защиты регулярных выражений, которые часто содержат символы “$” и “\”. Например::

    deny senders = \N^\d{8}[a-z]@some\.site\.example$\N
    
При достижении первого символа ``\N`` во время раскрытия строки последующие символы копируются без интерпретации, пока не встречается следующий символ ``\N`` или новая строка. 


.. _ch11_02:

Последовательности с обратным слэшем, в расширенных строках
-----------------------------------------------------------

Обратный слэш, с последующим за ним символом “n”, “r”, или “t” - это специальная последовательность, означающая новую строку, возврат каретки, и табуляцию, соответственно. Если за обратным слешем следует три восьмеричных цифры, то это расшифровывается как восьмеричная запись единичного символа, а если за обратным слешем следует символ “x” и до двух шестнадцатеричных цифр - то это трактуется как шестнадцатеричная запись символа.

Эти последовательности распознаются и внутри кавычек. Их интерпретация, как есть, полезна в строках без кавычек, и в других случаях поиска строк, которые могут быть раскрыты.

.. _ch11_03:

Тестирование раскрываемых строк
-------------------------------

Очень многие, раскрываемые, строки могут быть проверены, путём вызова Exim с параметром **-be**. В этом случае принимаются параметры команды, или строки со стандартного ввода, если аргументов нет, выполняет их через код раскрытия строк, и пишет результат на стандартный вывод. Переменные, основанные на конфигурации, установлены, но т.к. не обрабатывается никакое сообщение, переменные типа ``$local_part`` не имеют никакого значения. Однако, параметр **-be** можно применять для проверки файлов и обращений к БД, а также для проверки раскрытия операторов раскрытия, типа **sg**, **substr** и **nhash**.

Exim управляет root`овыми привилегиями, при вызове его с параметром **-be**, и выполняется под uid и gid пользователя, вызвавшего его, для того чтобы пользователь использующий параметр **-be** не смог получить доступ к файлам, которые ему не принадлежат.

Если Вы хотите протестировать раскрытие, которое содержит переменные, значения которых берутся из сообщения, существуют две иные параметры, которые могут использоваться. Параметр **-bem** - такой же как и **-be**, за исключением что он сопровождается именем файла. Файл читается как сообщение, до осуществления тестирования раскрытия. Например::

    exim -bem /tmp/test.message '$h_subject:'

Параметр **-Mset** используется совместно с **-be**, и сопровождается идентификатором сообщения Exim'a. Например::

    exim -be -Mset 1GrA8W-0004WS-LQ '$recipients'

Этим загружается сообщение из спула Exim'a, до осуществления тестирования раскрытия, и её использование ограничено списком административных пользователей.

.. _ch11_04:

Принудительный отказ от раскрытия строки
----------------------------------------

Множество раскрытий, описанных в следующем разделе, имеют подстроки “true” и “false”, помещённые в в символах фигурных скобок. То, какая из двух строк используется, зависит от условия, которое тоже раскрывается. Если вместо “false” используется слово “fail” (не в фигурных скобках), раскрытие строки происходит неудачно, и может быть обнаружено кодом, который запрашивал раскрытие. Это называют “принудительным отказом раскрытия” и его последствия зависят от обстоятельств. В одних случаях это неотличимо от любой другой ошибки раскрытия, но в отдельных случаях может быть предпринять иное действие. Такие изменения упомянуты в документации раскрывемого параметра.

.. _ch11_05:

Элементы раскрытия
------------------

Следующие элементы распознаются в раскрываемых строках. Пустое пространство может использоваться между подпунктами, которые являются ключевыми словами, или подстроками снаружи фигурных скобок, для улучшения читабельности. Внимание: Внутри фигурных скобок, пустое пространство имеет значение.

  **$<имя переменной> или ${<имя переменной>}**
    Замена содержимым, переменной, например::
    
        $local_part
        ${domain}
        
    Вторая форма записи может быть использована для отделения, от имени переменной, последующих алфавитно-цифровых символов. Эта форма (с использованием фигурных скобок) доступна только для переменных; её нельзя применять для заголовков сообщений. Имена переменных приведены в разделе :ref:`11.9 <ch11_09>`. Если используется имя несуществующей переменной, то раскрытие терпит неудачу.

  **${<op>:<строка>}**
    Вначале раскрывается строка, а затем производится заданная <op> операция. Например::

        ${lc:$local_part}

    Строка начинается с первого символа после двоеточия, которое может предворяется пустым пространством. Список операторов приведен в разделе :ref:`11.6 <ch11_06>`. Нотация оператора использует простое раскрытие элементов, которые могут иметь один аргумент, поскольку это уменьшает число фигурных скобок, и позволяет легче понимать итоговую строку.

  **$bheader_<header name>: или $bh_<header name>:**
    Этот элемент вставялет “базовые” строки заголовков. Он описан ниже, вместе с элементом раскрытия **header**.

  **${dlfunc{<file>}{<function>}{<arg>}{<arg>}...}**
  

        EXPAND_DLFUNC=yes

    заданным в *Local/Makefile*. Однажды загруженный, Exim запоминает динамически загруженный объект, так что не требуется перезагружать файлы объектов при работе того же процесса Exim (но сам Exim, часто запускает свои новые копии, при работе).

    У функции может быть от нуля до восьми аргументов. Собирая локальную функцию, вызываемую таким образом, необходимо включить *local_scan.h*. Переменные и функции Exim`a, определённые в API также доступны для динамически загружаемых функций. Сама функция должна иметь следующий вид::

        int dlfunction(uschar **yield, int argc, uschar *argv[])

    Где ``uschar`` является typedef для ``unsigned char`` в *local_scan.h*. Функция должна возвратить одно из следующих значений:

    ``OK``: Успех. Строка, помещённая в переменную *yield* помещена в раскрытую строку и будет построена.
      
    ``FAIL``: Непринудительная неудача раскрытия, с сообщением об ошибках взятых из *yield*, если такое задано.

    ``FAIL_FORCED``: Принудительный отказ раскрытия, с сообщением об ошибках из *yield*, если такое задано.

    ``ERROR``: Тоже что и ``FAIL``, за исключением, что пишутся ошибки в лог.

    При использовании gcc для сборки такой функции, необходимо добавить ключ **-shared** к строке запуска gcc. Также в при сборке Exim`a необходимо добавить **-export-dynamic** в EXTRALIBS.

  **${extract{<key>}{<string1>}{<string2>}{<string3>}}**
    Вначале раздельно раскрываются *key* и *<string1>*. Начальные и замыкающие пустые символы (пробелы, табуляции) удаляются из *key* (но не из строк). Ключ (key) не должен состоять полностью из цифр. Раскрытая строка *<string1>* должна иметь форму::

        <key1> = <value1>  <key2> = <value2> ...

    где знак равенства и пробел (но не оба одновременно) необязательны. Если любое из значений содержит пустые символы, они должны быть помещены в двойные кавычки, чтобы быть обработанными, как описано в разделе :ref:`6.16 <ch06_16>`. Раскрытие *<string1>* - поиск значения соответствующего ключу. Поиск нечувствителен к регистру. Если ключ найден, *<string2>* раскрывается, и заменяет элемент, иначе используется *<string3>*. В процессе раскрытия *<string2>* переменная ``$value`` содержит значение, которое было извлечено. Впоследствии, оно восстанавливается до предыдущего значение, которое, возможно, было.
            
    Если *{<string3>}* отсутствует, элемент заменяется пустой строкой, если ключ не найден. Если *{<string2>}* также отсутствует, то используется значение, которое было извлечено. Таким образом, например, эти два раскрытия идентичны и уступают (видимо, соответствуют) “2001”::

        ${extract{gid}{uid=1984 gid=2001}}
        ${extract{gid}{uid=1984 gid=2001}{$value}}
        Вместо “{<string3>}” может быть слово “fail” (не в фигурных скобках), например:
        ${extract{Z}{A=... B=...}{$value} fail }

    Это вызывает “принудительный отказ раскрытия” (смотрите раздел :ref:`11.4 <ch11_04>`); *{<string2>}* должна присутствовать, чтобы “fail” был распознан.


  **${extract{<number>}{<separators>}{<string1>}{<string2>}{<string3>}}**
    Аргумент *<number>* (число, в смысле цифра) должен полностью состоять из десятичных цифр, кроме начальных и конечных пустых символов, которые игнорируются. Это то, что отличает эту форму **extract** от предыдущего вида. Она ведёт себя точно также, за тем исключением, что вместо того, чтобы извлечь названное поле, оно извлекает из *<string1>* поле, номер которого даётся как первый аргумент. Вы можете использовать ``$value`` в ``<string2>`` или ``fail`` вместо *<string3>* как и прежде.
      
    Поля в строке разделены любым из символов в строке разделителя. Они могут включать пустые символы и символы табуляции. Первое поле имеет номер один. Если номер отрицательный, то поля считаются с конца строки, считая что самое правое имеет номер -1. Если задано номер 0, то возвращается вся строка, целиком. Если модуль числа (видимо, всё-таки, не модуль числа, а само число) больше чем число полей в строке, то результат - раскрытие строки *<string3>* или пустая строка, если *<string1>* отсутствует. Например::

        ${extract{2}{:}{x:42:99:& Mailer::/bin/bash}}

    вернёт “42” и ::
               
        ${extract{-4}{:}{x:42:99:& Mailer::/bin/bash}}
               
    вернёт “99”. Два последовательных разделителя означают, что область между ними пуста (например пятое поле, в предыдущем примере).

               
  **${filter{<string>}{<condition>}}**
    После раскрытия, *<string>* интерпретируется как список, по умолчанию - разделённый двоеточиями, но, разделитель может быть изменён обычным образом. Для каждого элемента в этом списке, его значение помещается в *$item*, и, затем, условие оценивается. Если условие истинно, *$item* добавляется к выводу, как элемент в новом списке; если условие ложно, элемент отбрасывается. Для списка на выходе используется такой же разделитель как и для входного списка, но, настройки разделителя не включены в выходные данные. Например::

        ${filter{a:b:c}{!eq{$item}{b}}

    вернёт ``a:c``. В конце раскрытия, значение *$item* восстанавливается до его начального состояния. Также, смотрите элементы раскрытия *map* и *reduce*.

  **${hash{<string1>}{<string2>}{<string3>}}**
    Это - текстовая функция хэширования, и она была первой, осуществлённой в ранних версиях Exim. В нынешних релизах добавлены другие функции работы с хэшами (числовой, MD5, и SHA-1), описанные ниже.

    Первые две строки, после раскрытия, должны быть числами. Зовите их *<m>* и *<n>*. Если вы используете фиксированные значения для этих чисел, т.е. *<string1>* и *<string2>* не изменяются при раскрытии, вы можете использовать более простой синтаксис оператора, без использования некоторых фигурных скобок::

        ${hash_<n>_<m>:<string>}
        
    Второе число является необязательным (в обоих нотациях). Если *<n>* больше или равно длине строки, раскрытие строки вернёт саму строку. Иначе, будет вычислена новая строка с длинной *<n>*, с помощью применения функции хэширования к строке. Новая строка состоит из *<m>* символов взятых от начала строки::

    
        abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQWRSTUVWXYZ0123456789
        
    Если *<m>* не задана, то используется значение 26, с целью, чтобы были тока строчные буквы. Например::
        
        $hash{3}{monty}}              результат  jmg
        $hash{5}{monty}}              результат  monty
        $hash{4}{62}{monty python}}   результат  fbWx

  **$header_<header name>:** или **$h_<header name>:** 

  **$bheader_<header name>:** или **$bh_<header name>:**

  **$rheader_<header name>:** или **$rh_<header name>:**
    Замена заголовка содержанием названной строки. Например::
        
        $header_reply-to:
        
    Символ новой строки, который завершает строку заголовка не включен в раскрытие, но внутренние символы новой строки (разделяющие заголовок на на несколько строк) могут присутствовать.
                                 
    Различие между **rheader**, **bheader**, и **header** в способе интерпретации данных в строке заголовка.

    * **rheader** - выдаёт оригинальное содержимое (“raw”) заголовка, вообще без обработки, без удаления начального и конечного пустого пространства.
    * **bheader** - удаляет пустые символы в начале и конце строки, затем декодирует base64 или экранированные кавычками MIME “слова” в пределах заголовка, но не производит трансляции символов. Если расшифровка MIME “слов” неудачна, возвращается “raw” строка. Если в результате расшифровки появляется символ двоичного нуля, он заменяется вопросительным знаком, это то, что делает Exim с бинарными нулями, переданными в строке заголовка.
    * **header** - пробует транслировать строку как **bheader**, к стандартному набору символов. Это - попытка воспроизвести ту же строку, которая была бы отображена MUA пользователю. Если трансляция неудачна, возвращается строка **bheader**. Попытки трансляции предпринимаются только на OC которые поддерживают функцию *iconv()*. Это указано при компиляции макросом ``HAVE_ICONV`` в системном *Makefile* или *Local/Makefile*.
                                  
    В файле фильтра, целевой набор символов для заголовка может быть определен командой следующей формы::

        headers charset "UTF-8"
          
    
    Эта команда затрагивает все ссылки на расширения ``$h_`` (или ``$header_``) в командах фильтра. В отсутствии этой команды, итоговый набор символов устанавливается из параметра **headers_charset** в текущей конфигурации. Значения по умолчанию этих опий - значение ``HEADERS_CHARSET`` *Local/Makefile*. Окончательное значение по-умолчанию - ISO-8859-1.

    Имена заголовков следуют синтаксису :rfc:`2822`, в котором говориться, что они могут содержать любые символы, кроме пробелов и двоеточий. Следовательно, фигурные скобки, не заканчивают имена заголовков, и не могут использоваться для помещения в начале и конце, как в переменных. Попытка сделать такое - ошибка синтаксиса.

    Только заголовки, являющиеся общими для всех копий сообщения видны этому механизму. Тут фигурируют только оригинальные заголовки, переданные с сообщением, и некоторые, добавленные правилами ACL, или системным фильтром. Заголовки, добавленные маршрутизатором или транспортом к отдельной копии сообщения - недоступны.

    Для входящих SMTP сообщений, никакие заголовки не видны в ACL, в правилах до DATA ACL, поскольку структура заголовка не установлена, пока сообщение не получено. Заголовки, добавленные, например в RCPT ACL, сохраняются до тех пор пока, недоступны заголовки входящего сообщения, в какой точке они добавлены. Однако, когда выполняются DATA ACL, заголовки добавленные другими ACL - видны.

    В именах заголовков не имеет значения, какие используются буквы - заглавные, или строчные. Если следующий символ - пробел, то завершающее доеточие может быть пропущено, но это не рекомендуется, поскольку вы можете забыть об этом, когда оно понадобиться. Когда имя заголовка завершается пробелом, оно включается в раскрываемую строку. Если сообщение не содержит данный заголовок, раскрытие заменяется пустой строкой. (Смотрите условие определения в разделе :ref:`11.7 <ch11_07>` для проверки существования заголовка.)

    Если есть более чем один заголовок с одинаковым именем, то все они объединяются для формирования строки замены, максимальной длинны 64k. За исключением случая использования **rheader**, до конкатенации удаляются начальные и конечные пустые символы, полностью пустые заголовки игнорируются. Символ новой сроки вставляется между непустыми заголовками, но в самом конце сивол новой строки не вставляется. Для раскрытия **header** и **bheader**, для тех заголовков, которые содержат список адресов, также вставляется запятая, между строками. Это не происходит с раскрытием **rheader**.


  **${hmac{<hashname>}{<secret>}{<string>}}**
    Эта функция использует криптографическое хэширование (либо MD5 либо SHA-1), для конвертации пароля и текста, в код идентификации сообщения, как определено в :rfc:`2104`. Это отличается от ``“${sha1:secret_text...}`` или ``${sha1:secret_text...}``, в этом шаге ``hmac`` добавляет в подпись криптографический хэш допустимый для аутентификации, что невозможно только с MD5 or SHA-1. Имя хэша, в настоящее время, должно быть либо MD5 либо SHA-1. Например::

        ${hmac{md5}{somesecret}{$primary_hostname $tod_log}}
        
    Для имени хоста *mail.example.com* и времени 2002-10-17 11:30:59, это будет::

        dd97e3ba5d1a61b5006108f8c8252953
                                                         
    Как пример, где это можно использовать, вы могли бы поместить в основной части конфигурации экзима::

        SPAMSCAN_SECRET=cohgheeLei2thahw
                                                         
    В маршрутизаторе или транспорте можно было бы иметь::
                                                  
        headers_add = \
          X-Spam-Scanned: ${primary_hostname} ${message_exim_id} \
          ${hmac{md5}{SPAMSCAN_SECRET}\
           {${primary_hostname},${message_exim_id},$h_message-id:}}
          
    Тогда данное сообщение, вы могли бы проверить, где оно было проверено, по заголовкам *X-Spam-Scanned:*. Если вы знаете секретную строку, то можно проверить подлинность этой строки, повторно вычислив опознавательный код из имени хоста, message ID и заголовка *Message-id:*. Это может быть сделано с использованием параметра Exim **-be**, или другими средствами, например использованием функции *hmac_md5_hex()* в Perl.

  **${if <condition> {<string1>}{<string2>}}**
    Если *<condition>* (*условие*) - истинно, то раскрывается *<string1>* и заменяет весь элемент; иначе используется *<string2>*. Доступные условия описаны в раздел :ref:`11.7 <ch11_07>`. Например::

        ${if eq {$local_part}{postmaster} {yes}{no} }
       
    Вторая строка может не присутствовать, если условие не соответствует, и условие не истинно, элемент ничем не заменяется. Аналогично, слово “fail” может быть вместо второй строки (без фигурных скобок). В этом случае происходит принудительный отказ раскрытия, если условие не истинно (смотрите раздел :ref:`11.4 <ch11_04>`).

    Если отсутствуют обе строки, результат - строка ``true`` если условие истинно, и пустая строка если условие ложно. Это облегчает написание своих ACL и условий для маршрутизаторов. Например, вместо::

        condition = ${if >{$acl_m4}{3}{true}{false}}
       
    вы можете использовать::
                            
        condition = ${if >{$acl_m4}{3}}
        
  **${length{<string1>}{<string2>}}**
    Элемент **length** используется для извлечения начальной части строки. Обе строки раскрываются, и первая должна вернуть число *<n>*. Если вы используете жёстко заданное число, т.е. строка *<string1>* при раскрытии не изменяется, вы можете использовать более простую нотацию оператора, без некоторых фигурных скобок::

        ${length_<n>:<string>}

    Результатом будет или первые *<n>* символов, или вся строка *<string2>*, смотря что короче. Не путайте **length** со **strlen**, возвращающей длину строки.


  **${lookup{<key>} <search type> {<file>} {<string1>} {<string2>}}**
    Это первый из двух различных типов поиска отдельных элементов, оба которых описаны в следующем пункте.
   
  **${lookup <search type> {<query>} {<string1>} {<string2>}}**
    Две формы поиска определяют поиск данных в БД и файлах, как обсуждается в главе :ref:`9 <ch09_00>`. Первая форма использует поиск по одному ключу поиск, а вторая использует стиль запросов для поиска. Строки *<key>*, *<file>*, и *<query>* раскрываются перед использованием.

    Если есть пустые символы в элементе поиска как часть команды фильтра, правила повтора или перезаписи, правила маршрутизации для **manualroute**, или любого другого мета, где пустое пространство существенно, то элемент поиска должен быть заключён в двойные кавычки. Использование поиска данных в файлах фильтров пользователей может быть заблокировано системным администратором.

    Если поиск успешен, *<string1>* раскрывается и замещает весь элемент. В процессе его раскрытия переменная $value содержит данные, возвращённые поиском. Впоследствии оно возвращается к предыдущему своему значению (внешне оно пустое). Если поиск неудачен, раскрывается *<string2>* и замещает элемент. Если *<string2>* пропущена, то замена - пустая строка, в случае неудачного поиска. Если *<string2>* присутствует, то она может быть самостоятельным вложенным поиском, таким образом обеспечивая механизм поиска значения по-умолчанию, в случае неудачи основного поиска.

    Если вложенный поиск используется как часть *<string1>*, $value содержит данные для внешнего поиска, когда параметры второго поиска раскрыты, и также когда *<string2>* второго поиска раскрыта, второй поиск будет неудачен [#]_. Вместо *<string2>* можно использовать “fail”, и в этом случае, если поиск неудачен, с раскрытием происходит “принудительный отказ при раскрытии строки” (смотрите раздел :ref:`11.4 <ch11_04>`). Если пропущены обе строки - *<string1>* и *<string2>* то результат - искомое значение в случае успешного поиска, и ничего в случае неудачи.

    Для одноключевого поиска “неполной” строке разрешается предшествовать типу поиска, чтобы сделать частичное соответствие и \* или \*@ могут быть вместе со строкой поиска, для поиска по-умолчанию, если ключ не совпадает (смотрите разделах :ref:`9.6 <ch09_06>` и :ref:`9.7 <ch09_07>` для деталей).

    Если используется частичный поиск, переменные $1 и $2 содержат части ключа в процессе раскрытия текста замены. Они возвращаются к их предыдущим значениям после окончания поиска.

    Вот пример поиска синонима postmaster`a в обычном файле синонимов::

        ${lookup {postmaster} lsearch {/etc/aliases} {$value}}
        
    Этот пример использует NIS+ для поиска полного имени пользователя, соответствующего локальной части адреса, с принудительным отказом раскрытия, в случае неудачи::

        ${lookup nisplus {[name=$local_part],passwd.org_dir:gcos} \
          {$value}fail}

  **${map{<string1>}{<string2>}}**
    После раскрытия, *<string1>* интерпретируется как список, по умолчанию - разделённый двоеточием, но, разделитель может быть изменён обычным способом. Для каждого элемента в этом списке, его значение помещается в $item, затем раскрывается *<string2>* и добавляется к выводу, как элемент в новом списке. Для выходного списка используется тот же самый разделитель, но, настройки разделителя не включаются в вывод. Например::

       ${map{a:b:c}{[$item]}} ${map{<- x-y-z}{($item)}}
       
    раскроется в ``[a]:[b]:[c] (x)-(y)-(z)``. В конце раскрытия, значение $item восстанавливается в исходное. Также, смотрите параметры раскрытия *filter* и *reduce*.


  **${nhash{<string1>}{<string2>}{<string3>}}**
    Три строки раскрываются; первые две должны вернуть числа. Зовите их *<n>* и *<m>*. Если вы используете жёско заданные значения этих чисел, т.е. если *<string1>* и *<string2>* не изменяются при раскрытии, то вы можете использовать более простую форму этого оператора, без использования некоторых фигурных скобок::
                                                                                                        
       ${nhash_<n>_<m>:<string>}


    Второе число является необязательным (в обоих нотациях). Если тут только одно число, результатом будет число из диапазона *0-<n>-1*. Иначе строка, обработанная функцией хэшрования, вернёт два числа, разделённых слэшем, в диапазонах *0-<n>-1* и *0-<m>-1*, соответственно. Например::

       ${nhash{8}{64}{supercalifragilisticexpialidocious}}
       
    вернёт строку “6/33”.

    
  **${perl{<subroutine>}{<arg>}{<arg>}...}**
    Этот элемент доступен лишь в том случае, если Exim собран с встроенным интерпретатором perl. Имя подпрограммы и параметры, вначале, раздельно раскрываются, а затем вызывается подпрограмма perl с этими параметрами. Никакие дополнительные параметры передаваться не должны; максимальное разрешённое число аргументов, включая имя подпрограммы - девять.

    Значение возвращённое подпрограммой вставляется в раскрываемую строку, за тем исключением, если возвращённое значение **undef**. В этом случае, раскрытие неудачно, точно также как при “fail” в поиске. Возвращённое значение - скалярная величина. Независимо от того, что вы возвращаете, оно будет скалярной величиной. Например, если вы вернёте имя вектора perl, возвращённое значение будет размер вектора, а не содержимое.

    Если подпрограмма выполняется с вызовом функции perl **die**, раскрытие неудачно, с сообщенем об ошибках, которые были переданы функцией **die**. Больше информации, о встроенном perl можно получить из главы :ref:`12 <ch12_00>`.

    Маршрутизатор **redirect** имеет параметр вызывающий **forbid_filter_perl**, которая блокирует использование этого пункта в файлах фильтра.

                                                                                                       
  **${prvs{<address>}{<secret>}{<keynumber>}}**
    Первый параметр - полный e-mail адрес, и второй - секретная ключевая строка. В третьем аргументе задаётся номер ключа, и он является необязательным. При его отсутствии значение по умолчанию - ноль. Результат раскрытия - prsv-подписанный адрес e-mail, типичное его использование - с параметром **return_path** транспорта **smtp** как часть проверки схемы адреса возврата (BATV). За дополнительной информацией и примерами обратитесь к разделу :ref:`40.47 <ch40_47>`.

  **${prvscheck{<address>}{<secret>}{<string>}}**
     Этот пункт - дополнение пункта **prvs**. Он используется для проверки prsv-подписанных адресов. Если раскрытие первого параметра не приводит к синтаксически правильному prsv-подписанному адресу, то всё раскрывается в пустую строку. Когда первый параметр раскрывается в синтаксически правильный prsv-подписанный адрес, второй аргумент раскрывается с prvs-расшифрованным адресом и ключевым числом, в переменных $prvscheck_address`` и $prvscheck_keynum соответственно.

     Эти две переменные могут использоваться в раскрытии второго аргумента, для отыскания секретного слова. Тогда действительность prsv-подписанного адреса проверяется по нему. Результат сохраняется в переменную $prvscheck_result, пустую при ошибке и “1” при соответствии.

     Третий параметр является дополнительным, если он отсутствует, то пустая строка - значение по умолчанию. Теперь этот параметр раскрыт. Если результат - пустая строка, то результат раскрытия - расшифрованная версия адреса. Проверяется, была ли сигнатура верной. Иначе, результат раскрытия - раскрытие третьего аргумента.
                                                                             
     Все три переменные могут использоваться в раскрытии третьего параметра. Однако, по завершении раскрытия остаётся только $prvscheck_result. За дополнительной информацией и примерами обратитесь к секции :ref:`40.47 <ch40_47>`.
                                                                                                                                      

  **${readfile{<file name>}{<eol string>}}**
    Вначале, раздельно раскрываются имя файла и набор символов конца строки. Затем читается файл, и его содержимое заменяет весь пункт. Символы новой строки в файле, заменяются строкой символы конца строки, если они есть. Иначе, символы перевода строк оставляют на месте. Раскрытие строки не применяется к содержимому файла. Если же вы хотите этого, то необходимо поместить элемент в оператор **expand**. Если файл не может быть прочитан, раскрытие строки неудачно.

    Маршрутизатор **redirect** имеет параметр **forbid_filter_readfile** которая блокирует использование этого пункта в пределах файлов фильтра.
                                                                                                                                            
  **${readsocket{<name>}{<request>}{<timeout>}{<eol string>}{<fail string>}}**
    Этот пункт вставляет данные из UNIX или Internet-сокета в раскрываемую строку. Минимальный способ использования требует только два аргумента, как в этих примерах::

        ${readsocket{/socket/name}{request string}}
        ${readsocket{inet:some.host:1234}{request string}}
        
    Для UNIX-сокета, первая подстрока должна быть путём к сокету. Для Internet-сокета, первая подстрока должна содержать подстроку ``inet:`` сопровождаемую именем хоста или IP адресом, через двоеточие порт, или имя сервиса, которое должно быть в */etc/services*. Необязательно, IP-адрес может заключаться в квадратные скобки. Адреса IPv6 лучше записывать именно так. Например::
                                                                                                                                               
        ${readsocket{inet:[::1]:1234}{request string}}

    Можно задать только одно имя хоста, но если поиск по нему приведёт более чем к одному IP-адресу, будут сделаны попытки соединиться с каждым из них, по очереди, пока не получиться подключиться. Для обоих видов сокетов, Exim осуществляет подключение, пишет строку запроса (если она не пустая), и читает из сокета пока не наступит конец файла. Применяется таймаут в 5 секунд. Дополнительные аргументы могут продлить это время. Во-первых, можно изменить таймаут::

        ${readsocket{/socket/name}{request string}{3s}}

    Четвёртый аргумент позволяет изменить символ перевода строки в читаемых данных, таким же образом как и в **readfile** (смотрите выше). Этот пример превращает их в пробелы::

        ${readsocket{inet:127.0.0.1:3294}{request string}{3s}{ }}

    Как и во всех раскрытиях, подстроки раскрываются до начала обработки. Ошибки в под-раскрытиях приводят к ошибке самого раскрытия. Кроме того, могут встречаться такие ошибки:

    * Ошибка создания дескриптора файла сокета.
    * Ошибка соединения с сокетом.
    * Ошибка записи строки запроса.
    * Таймаут чтения из сокета.

    По умолчанию, любая из этих ошибок приводит к ошибке раскрытия. Однако, если вы используете пятый аргумент, раскрытие происходит, если встречается любая из вышеупомянутых ошибок. Например::

        ${readsocket{/socket/name}{request-string}{3s}{\n}\
          {socket failure}}

    Вы можете проверить существование Unix-сокета, поместив раскрытие в ``${if exists``, но получается проверка кто отработает быстрей - открытие сокета, или проверка его существования. Таким образом, более корректно использовать пятый параметр, чтобы быть уверенным в том что будет корректно обработана ошибка раскрытия несуществующего Unix-сокета, или ошибка соединения с интернет-сокетом.

    Маршрутизатор **redirect** имеет параметр **forbid_filter_readsocket** которая блокирует использование этого пункта в пределах файлов фильтра.


  **${reduce{<string1>}{<string2>}{<string3>}}**
    Эта операция сворачивает список до одной, скалярной строки. После раскрытия, *<string1>* интерпретируется как список - по умолчанию разделённый двоеточиями, но, разделитель может быть изменён обычным способом. Затем, раскрывается *<string2>* и назанчается в переменную $value. После этого, каждый элемент в списке *<string1>*, по очереди, назначается в $item, и *<string3>* раскрывается для каждого из них. Результат этого раскрытия назначается в $value до следующей итерации. Когда достигается конец списка, финальное значение $value добавляется к выводу раскрытия. Элемент раскрытия *reduce* может использоватсья несколькими способами. Например, для увеличения списка цифр::

        ${reduce {<, 1,2,3}{0}{${eval:$value+$item}}}

    Результат этого раскрытия будет ``6``. Может быть найден максимум из списка цифр::

        ${reduce {3:0:9:4:6}{0}{${if >{$item}{$value}{$item}{$value}}}}

    В конце раскрытия *reduce*, значения $item и $value восстанавливаются в их исходное состояние. Смотрите также параметры раскрытия *filter* и *map*.

  **$rheader_<header name>: or $rh_<header name>**:
    Этот пункт вставляет необработанные (“raw”) строки заголовка. Это описано в пункте **header**, выше.

  **${run{<command> <args>}{<string1>}{<string2>}}**
    Вначале, отдельно, раскрываются команда и её параметры, затем команда запускается отдельным процессом, но под теми же gid и uid. Как и во всех других командах, выполняемых Exim, по умолчанию shell не используется. Если вы хотите его использовать, то нужно явно указать это в коде.

    Стандартный ввод для команды существует, но он пуст. Стандартный вывод и поток ошибок устанавливаются в тот же самый файловый дескриптор. Если команда выполняется успешно (возвращённый код равен нулю), то *<string1>* раскрывается и замещает строку; в процессе раскрытия, стандартный вывод и поток ошибок команды находятся в переменной $value. Если команда неудачна, то раскрывается и используется *<string2>*. Ещё раз, стандартный вывод команды, в процессе раскрытия находиться в переменной $value.

    Если *<string2>* отсутствует, то результат пуст. Альтернативно, *<string2>* может быть словом “fail” (не в фигурных скобках), для принудительной ошибки раскрытия, если команда не была успешно выполнена. Если пусты обе строки, то результат содержит стандартный вывод, в случае успеха и ничего не содержит в случае неудачи.

    Код возврата команды помещается в переменную $runrc, и впоследствии остаётся установленным, поэтому, в файле фильтра можно делать так::
                                                                                                                                           
        if "${run{x y z}{}}$runrc" is 1 then ...
          elif $runrc is 2 then ...
          ...
        endif
        
    Если выполнение команды неудачно (например, команда не существет), то код возврата равен 127 - тот же самый код, который шеллы используют для несуществующих команд.

    .. warning:: В маршрутизаторе или транспорте вы не можете установить порядок раскрытия переменных, за исключением тех предварительный условий, чей порядок задокументирован. Поэтому нельзя быть уверенным в том что находиться в $runrc, запуская команду в одной переменной и используя эту переменную в другой.

    Маршрутизатор **redirect** имеет параметр **forbid_filter_run** которая блокирует использование этого пункта в пределах файлов фильтра.

  **${sg{<subject>}{<regex>}{<replacement>}}**
    Этот пункт работает как оператор замены в Perl, с глобальным параметром (/g). Однако, в отличие от Perl, Exim не изменяет строку, вместо этого он возвращает строку для вставки в общее раскрытие. Есть три парааметра: строка объекта, регулярное выражение, строка замены. Например::

        {sg{abcdefabcdef}{abc}{xyz}}
       
    результат - “xyzdefxyzdef”. Поскольку все три параметра раскрываются перед использованием, то если в регулярном выражении необходимы символы ``$`` или символы содержащие обратный слэш, то они должны быть экранированы. Например::

    
        ${sg{abcdef}{^(...)(...)\$}{\$2\$1}}

    вернёт “defabc”, и ::
       
        ${sg{1=A 4=D 3=C}{\N(\d+)=\N}{K\$1=}}
    
    вернёт “K1=A K4=D K3=C”. Отметтьте использование ``\N`` для защиты регулярного выражения от раскрытия.

  **${substr{<string1>}{<string2>}{<string3>}}**
    Три строки раскрываются, первые две должны вернуть числа. Зовите их *<m>* и *<n>*. Если вы используете фиксированные значения для этих чисел, т.е. *<string1>* и *<string2>* не изменяются при раскрытии, вы можете использовать более простой синтаксис оператора, без использования некоторых фигурных скобок::

        ${substr_<n>_<m>:<string>}


    Второе число необязательно (в обоих нотациях). Если, в более простом формате, оно отсутствует, то предваряющее подчёркивание также должно быть опущено.

    Элемент **substr** может использоваться для извлечения более коротких подстрок из более длинной. Первое число *<n>*, является смещением точки начала, второе - *<m>* - требуемая длинна. Например::

        ${substr{3}{2}{$local_part}}
                                                                                                                                                                                                                      
    Если стартовое смещение - больше длинны строки - то результатом будет пустая строка; если сумма старта плюс длинна смещения - результатом будет правая часть строки начинающаяся с точки старта.Первый символ строки имеет позицию ноль.
    
    Элемент **substr** может иметь отрицательные значения смещения, чтобы рассчитать позицию с правой стороны строки. Последний символ имеет значение смещения -1, предпоследний -2 и так далее. Вот пример::

        ${substr{-5}{2}{1234567}}

    результат - “34”. Если абсолютное значение отрицательного смещения больше, чем длинна строки, то подстрока начинается с начала строки и её длинна уменьшается на величину проскакивания. Например::
        
        ${substr{-5}{2}{12}}

    вернёт пустую строку, но ::

        ${substr{-3}{2}{12}}

    вернёт “1”.
        
    Когда второй параметр **substr** опущен, то берётся остаток строки, при положительном смещении. Если же смещение отрицательно, то берутся все символы строки, предшествующие точке смещения. Например, смещение -1 и никакая (нулевая) длинна, в этих одинаковых примерах::

        ${substr_-1:abcde}
        ${substr{-1}{abcde}}

    вернёт всю строку, кроме последнего символа, т.е. “abcd”.

  **${tr{<subject>}{<characters>}{<replacements>}}**
    Этот элемент - посимвольная замена строки объекта. Второй аргумент - список символов, которые будут заменены в строке объекта. Каждый совпадающий символ заменяется соответствующим символом из списка замены. Например::

        ${tr{abcdea}{ac}{13}}

    вернёт ``1b3de1``. Если во второй строке символов есть повторения, то используется последний из символов. Если третья строка короче чем вторая, последний символ копируется. Однако, если она пуста, то замена не производиться.

.. _ch11_06:

Операторы раскрытия
-------------------

Для раскрывающихся элементов, которые выполняют преобразования на одном аргументе строки, используется нотация “оператора”, поскольку это проще, и используется меньше фигурных скобок. Подстрока раскрывается до того, как над ней будет проведена операция. Следующие операции могут быть выполнены:
   
  **${address:<string>}**
    Строка интерпретируется как адрес, согласно :rfc:`2822`, и поскольку это может фигурировать в строках заголовков, то из неё извлекается эффективный адрес. Если строку не удаётся успешно разобрать, то результат пуст.

  **${addresses:<string>}**
    Строка (после раскрытия) интерпретируется как список адресов в формате :rfc:`2822`, как они могли бы быть найдены в заголовках *To:* или *Cc:*. Рабочий (оперативный) адрес (*local-part@domain*) извлкарется из каждого элемента, результатом будет список разделённый двоеточиями, с удвоенными двоеточиями встеченными в адресах. Синтаксически неверные :rfc:`2822` адреса пропускаются в выводе.

    Можно задать иной разделитель, не двоеточие, в качестве выходного разделителя, начав строку с символа ``>``, сопровождаемого символом новго разделителя. Например::

        ${addresses:>& Chief <ceo@up.stairs>, sec@base.ment (dogsbody)}

    раскроется в *ceo@up.stairs&sec@base.ment*. Сравните с раскрытием *address*, которое извлекает адрес из одного адреса :rfc:`2822`. Для способов обработки списков, смотрите элементы *filter*, *map*, и *reduce*.

  **${base62:<digits>}**
    Строка должна полностью состоять из десятичных цифр. Число конвертируется к основанию 62 выводится как строка из шасти символов, включая ведущие нули. В некоторых окружениях, где Exim использует основание 36 вместо 62 для идентификаторов сообщений (поскольку эти системы не учитывают регистр символов в имени файла), основание 36 используется этим оператором несмотря на его название. 

    .. note:: Чтобы было абсолютно ясно: это не кодирование base64.

  **${base62d:<base-62 digits>}**
    Строка должна полностью состоять из цифр с основанием 62, или, в операционных системах где Exim использует основание 36 вместо 62, из цифр с основанием 36. Число преобразуется в десятичные цифры, и выводится как строка.

  **${domain:<string>}**
    Строка интерпретируется как адрес, в соответствии с :rfc:`2822`, и из нёё извлекается домен. Если строка не может быть корректно разобрана, то результат пуст.


  **${escape:<string>}**
    Если строка содержит какие-то непечатные символы [#]_, то они будут преобразованы к их escape-последовательностям, начинающимся с символа обратного слэша (“\”). Символы, с установленным битом значимости (так называемые “8-ми битные символы”) считаются “печатными” и не контролируются параметром **print_topbitchars**.
                        
  **${eval:<string>} и ${eval10:<string>}**
    Эти элементы поддерживают простейшие арифметические и поразрядные логические операции в раскрываемых строках. Строка (после раскрытия) должна быть обычным арифметическим выражением, но оно ограничено базовыми арифметическими операторами, поразрядными логическими операциями, и скобками. Все операции выполняются с использованием арифметики целых чисел. Приоритет операторов таков (такой же как и в языке программирования С):

    ========  ==========
    highest:  not (~), negate (-)
    \         multiply (*), divide (/), remainder (%)
    \         plus (+), minus (-)
    \         shift-left (<<), shift-right (>>)
    \         and (&)
    \         xor (^)
    lowest:   or (|)
    ========  ==========
    
    Бинарные операторы с тем же самым приоритетом оцениваются слева направо. Пустые символы разрешены до или после операторов.

    В **eval** числа могут быть десятичными, восьмеричными (начинаются с “0”) или шестнадцатеричными (начинаются с “0x”). В **eval10** все числа считаются десятичными, даже если они начинаются с нуля; шестнадцатеричные цифры не разрешены. Это может оказаться полезным при обработке чисел извлечённых из дат и времени, они часто содержат ведущие нули.

    Число может сопровождаться “K” или “M” для умножения его на 1024 или 1024*1024, соответственно. Поддерживаются отрицательные числа. Результат вычисления - десятичное число (без “K” или “M”). Например::

        ${eval:1+1}              yields 2
        ${eval:1+2*3}            yields 7
        ${eval:(1+2)*3}          yields 9
        ${eval:2+42%5}           yields 4
        ${eval:0xc&5}            yields 4
        ${eval:0xc|5}            yields 13
        ${eval:0xc^5}            yields 9
        ${eval:0xc>>1}           yields 6
        ${eval:0xc<<1}           yields 24
        ${eval:~255&0x1234}      yields 4608
        ${eval:-(~255&0x1234)}   yields -4608
        
    Как более реалистичный пример, в ACL можно использовать так::

        deny   message = Too many bad recipients
               condition =                    \
                 ${if and {                   \
                   {>{$rcpt_count}{10}}       \
                   {                          \
                   <                          \
                     {$recipients_count}      \
                     {${eval:$rcpt_count/2}}  \
                   }                          \
                 }{yes}{no}}

    Условие верно в случае, если было более 10 команд RCPT и меньше половины из них привели к правильному получателю.

                   
  **${expand:<string>}**
    Оператор “expand” заставляет раскрывать строку по второму разу. Например::
    
        ${expand:${lookup{$domain}dbm{/some/file}{$value}}}

    вначале ищет строку в файле, в процессе раскрытия оператора **expand**, а затем снова раскрывает то, что было найдёно.

  **${from_utf8:<string>}**
    Мир медленно двигается в сторону Unicode, и хотя для электронной почты стандартов нет, она тоже двигается туда же.  Многие другие приложения (включая некоторые БД) начинают сохранять данные в Unicode, используя кодировку UTF-8. Этот оператор конвертирует строку UTF-8 в строки ISO-8859-1. Коды символов UTF-8 более 255 преобразовываются в подчёркивания. Ввод должен быть корректной строкой UTF-8. Если это не так, то результатом будет неопределённая последовательность символов.

    Точки кодов Unicode со значениями меньше 256 совместимы с ASCII и ISO-8859-1 (также известной как Latin-1). Для примера, символ 169 - символ копирайта (“©”)в обоих случаях, хотя способ которым он закодирован - различен. В режиме UTF-8, более чем один байт необходим для символов  кодом более 127, тогда как в ISO-8859-1 используется однобайтное кодирование (таким образом, оно ограничено 256 символами). Это позволяет сделать прямой перевод из UTF-8 в ISO-8859-1.

  **${hash_<n>_<m>:<string>}**
    Оператор **hash** - это более простой интерфейс к функции хэширования, которая может использоваться, когда два её параметра - фиксированные числа (в противоположность строкам, динамически строящимся при раскрытии). Эффект, тоже самое, что и::
                     
        ${hash{<n>}{<m>}{<string>}}
        
    Для дополнительных подробностей, смотрите описание главного оператора **hash** выше. Аббревиатура **h** может использоваться, когда **hash** используется как оператор.

  **${hex2b64:<hexstring>}**
    Этот оператор используется для преобразования шестнадцатеричной строки в кодировку base64. Это бывает полезно при обработке вывода функций хэширования md5 и sha-1.

  **${lc:<string>}**
    Это переводит буквы в нижний регистр. Например::

        ${lc:$local_part}
        
  **${length_<number>:<string>}**
    Оператор **length** - это более простой интерфейс к функции **length**, которая может использоваться, когда её параметр - фиксированное число (в противоположность строкам, динамически строящимся при раскрытии). Эффект, тоже самое, что и::

        ${length{<number>}{<string>}}

    Для получения дополнительной информации, смотрите примечания к к основной функции **length**. Заметьте, **length** не тоже самое что и **strlen**. Аббревиатура **l** может применяться при использовании **length** в качестве оператора.

  **${local_part:<string>}**
    Строка интерпретируется как адрес, в соответствии с :rfc:`2822`, и из неё извлекается локальная часть адреса. Если строка не может быть корректно разобрана, то результат пуст.


  **${mask:<IP address>/<bit count>}**
    Если формат строки не соответсвует адресу IP и маске через слэш (т.е. сервой адрес в CIDR-нотации), раскрытие будет неудачным. Иначе, этот оператор преобразует IP-адрес в двоичный вид, маску, от наименьших битов, и проеобразует результат обратно в текстовый вид, с прилагаемой маской. Например::

        ${mask:10.111.131.206/28}

    вернёт строку “10.111.131.192/28”. Так как предполагается, что эта операция, главным образом, будет использоваться для поиска адресов в файлах, результат для IPv6 использует точчки для разделения компонентов адреса, вместо двоеточий, поскольку двоеточия используются для разделения ключевых строк в **lsearch** файлах. Например::

        ${mask:3ffe:ffff:836f:0a00:000a:0800:200a:c031/99}

    вернёт строку::

        3ffe.ffff.836f.0a00.000a.0800.2000.0000/99

    Буквы, в адресах IPv6 всегда выводятся в строчном виде.

  **${md5:<string>}**
    Оператор **md5** вычисляет значение хэша MD5 строки, и возвращает его как шестнадцатеричное число с 32 цифрами, в котором все буквы в строчном виде.

  **${nhash_<n>_<m>:<string>}**
    Оператор **nhash**, это простой интерфейс к функции числового хэширования, которая может использоваться, когда оба параметра - фиксированные числа (в противоположность строкам, динамически строящимся при раскрытии). Эффект точно такой же как от::

        ${nhash{<n>}{<m>}{<string>}}
        
    Для дополнительных подробностей, смотрите описание главного оператора **nhash** выше.

  **${quote:<string>}**
    Оператор **quote** помещает переданный ему параметр в двойные кавычки, если это пустая строка, или содержит что-либо кроме букв, цифр, символа подчёркивания, точек или дефисов. Любые вхождения двойных кавычек и обратного слэша, экранируются обратным слэшем. Символы новой строки и возврата каретки преобразуются в ``\n`` и ``\r`` соответственно. Например::

        ${quote:ab"*"cd}

    становиться::

        "ab\"*\"cd"

    Это полезно в местах, где агрумент - замена из переменной или заголовок сообщения.

        
  **${quote_local_part:<string>}**
    Этот оператор похож на предыдущий, **quote**, за тем исключением, что в кавычки она заключается по правилам :rfc:`2822` для локальных частей адреса. Например символ “+” не вызвал бы заключение в кавычки (но при использовании **quote** строка была бы помещена в кавычки). Если вы создаёте новый адрес e-mail из содержимого *$local_part* (или других неизвестных данных), то вы всегда должны использовать этот оператор.

  **${quote_<lookup-type>:<string>}**
    Этот оператор применяет специфические правила экранирования, помещения в кавычки и замены к строке. Каждый тип запроса имеет свои правила, описанные в главе :ref:`9 <ch09_00>`. Например::

        ${quote_ldap:two * two}
        
    вернёт::
            
        two%20%5C2A%20two
        
    Для одноключевых поисков нет необходимости в кавычках, и этот оператор вернёт неизменную строку.

                                 
  **${rfc2047:<string>}**
    Этот оператор шифрует текст согласно :rfc:`2047`. Это кодирование используется в строках заголовков, для кодирования символов не-ASCII. Предполагается, что входная строка находиться в кодировке, определённой параметром **headers_charset**, с ISO-8859-1 по умолчанию. Строки содержащие символы только в диапазоне 33–126, и не содержащие символов типа::

        ? = ( ) < > @ , ; : \ " . [ ] _
        
    не модифицирутся. В противном случае, разультат - строка закодированная в соответствии с :rfc:`2047`, содержащая так много закодированных букв, сколько нужно для кодирования строки.


  **${rfc2047d:<string>}**
    Этот оператор декодирует строки закодированные как описано в :rfc:`2047`. Бинарные нули заменяются знаками вопроса. Символы конвертируются в кодировку заданную в **headers_charset**. Слишком длинные “слова” :rfc:`2047` не распознаются, пока **check_rfc2047_length** установлена в ложь.

    .. note:: Если для доступа к заголовкам вы используете **$header_xxx:** (или **$h_xxx:**), то декодирование :rfc:`2047` происходит автоматически. Вам не нужно использовать этот оператор.

  **${rxquote:<string>}**
    Оператор **rxquote** прослэшивает все символы не являющиеся алфавитно-цифровыми. Это применяется, например, для замены значений переменных или заголовков внутри регулярных выражений.

  **${sha1:<string>}**
    Оператор **sha1** вычисляет хэш SHA-1 строки, и возвращает это значение как шестнадцатеричное число с 40 цифрами, в котором все буквы находятся в прописном регистре.

  **${stat:<string>}**
    Строка, после раскрытия, должна представлять собой путь к файлу. Для этого пути делается вызов функции *stat()*. Если она (*stat()*) вернёт ошибку, то происходит ошибка раскрытия. Если же она отрабатывает успешно, то данные от *stat()* заменяют элемент, в виде ряда пар *<name>=<value>* где все значения числовые, за исключением значения “smode”.  Имена: “mode” (даёт режим в виде восьмеричного числа, с четырьмя цифрами), “smode” (даёт режим в символическом формате, как 10-ти символьную строку, как команда *ls*), “inode”, “device”, “links”, “uid”, “gid”, “size”, “atime”, “mtime”, и “ctime”. Вы можете извлечь отдельные поля с использованием оператора **extract**.

    Использование функции **stat** в файлах фильтров пользователей может быть блокировано системным администратором.
    
    .. warning:: размер файла может быть неправильным на 32-х разрядных системах, для файлов больше 2Gb размером.

  **${str2b64:<string>}**
    Этот оператор кодирует строку в кодировку base64.

  **${strlen:<string>}**
    Этот пункт - заменяется длинной строки, в десятичном виде.
    
    .. note:: не путайте **strlen** с **length**.

  **${substr_<start>_<length>:<string>}**
    Оператор **substr** - это простой интерфейс к функции **substr**, который может использоваться, когда оба параметра функции - фиксированные числа (в отличие от раскрываемых строк). Эффект очно такой же как::

        ${substr{<start>}{<length>}{<string>}}
    
    За дополнительными деталями обратитесь к описанию функции **substr**. Аббревиатура **s** может использоваться, когда **substr** используется как оператор.

  **${time_eval:<string>}**
    Этот элемент преобразует временные интервалы Exim, типа ``2d4h5m`` в число секунд.

  **${time_interval:<string>}**
    Параметр (после раскрытия подстроки) должен представлять собой последовательность десятичных цифр, которая представляет собой временной интервал в секундах. Число преобразуется к формату времени Exim, например ``1w3d4h2m6s``.

  **${uc:<string>}**
    Преобразует буквы в верхний регистр.

.. _ch11_07:

Условия раскрытия
-----------------

Следующие условия доступны для проверки конструкции **${if**, при раскрытиии строк:

  **!<condition>**
    Восклицательный знак перед любым условием, приводит результат условия к противоположному.

  **<symbolic operator> {<string1>}{<string2>}**
    Есть несколько символических операторов для проведения операций стравнения::

        “=”        равно
        “==”       равно
        “>”        больше
        “>=”       больше или равно
        “<”        меньше
        “<=”       меньше или равно

    Например::

        ${if >{$message_size}{10M} ...

    Заметьте, что можно проверять неравенство, оператором отрицания (“!”). Обе строки должны принимать форму десятичных чисел, необязательно используемо “K” или “M” (в заглавном или строчном виде), что будет означать умножение на 1024 или 1024*1024 соответственно. В специальном случае, числовое значение пустой строки берётся как ноль.

  **bool {<string>}**
    Это условие возвращает строку содержащую истину или ложь, в булевом представлении. Она обрабатывается как “true”, “false”, “yes” и “no” (регистронезависимо); также, положительные числа мапяться на истину - если они ненулевые, ноль - на ложь. Начальные пробелы игнорируются. Все прочие строковые значения приводят к ошибке раскрытия.

    При комбинировании с переменными ACL, это условие раскрытия позволяет вам одном месте и действии выполнять действия в иных местах. Например::

        ${if bool{$acl_m_privileged_sender} ...

        
  **crypteq {<string1>}{<string2>}**
    Это сравнение включено в бинарный файл Exim, если он собран с поддержкой механизмов аутентификации (смотрите главу :ref:`33 <ch33_00>`). Иначе, необходимо определить ``SUPPORT_CRYPTEQ`` в *Local/Makefile* для включения **crypteq** в исполняемый файл Exim.

    Условие **crypteq** имеет два аргумента. Содержимого первого шифруется, и сравнивается со вторым, который уже зашифрован. Вторая строка может быть в форме хранения шифрованных строк в LDAP, которые начинаются с фигурных скобок, содержащих условие (алгоритм). Если вторая строка не начинается с “{”, то предполагается что алгоритм шифрования *crypt()* или *crypt16()* (смотрите ниже), т.к. такие строки не могут начинаться на “{”. Обычно это поле из файла паролей. Пример зашифрованной строки в формате LDAP::

        {md5}CY9rzUYh03PK3k6DJie09g==

    Если такая строка появляется непосредственно, в раскрытой строке, то фигурные скобки должны быть указаны, поскольку они - часть синтаксиса. Например::

        ${if crypteq {test}{\{md5\}CY9rzUYh03PK3k6DJie09g==}{yes}{no}}
        
    Следующие типы шифрования (их имена не зависят от регистра) поддерживаются:

      * **{md5}** - вычисляет MD5 сумму первой строки, и и представляет её в виде набора “печатных” символов, для сравнения с остатком от второй строки. Если длинна сравниваемой строки 24 символа, то Exim предполагает что она закодирована base64 (как в примере выше). Если длинна 32 символа, txim предполагает что это шестнадцатеричное кодирование MD5. Если же длинна не 24 и не 32 то сравнение оканчивается неудачей.
              
      * **{sha1}** - вычисляет SHA-1 сумму первой строки, представляет её в “печатном” виде, и сравнивает с отатком от второй строки. Если длинна сравнения 28 символов, то Exim предполагает чтоэто закодированно base64. Если длинна 40 символов, то предполагается что это шастнадцатеричное кодирование суммы SHA-1. Если же длинна не 28 и не 40 то сравнение оканчивается неудачей.
                     
      * **{crypt}** - вызывает функцию *crypt()*, которая традиционно, использовала только первые восемь символов пароля. Однако, во многих современных ОС это уже не так, и используется весь пароль, несмотря на его длинну.

      * **{crypt16}** - вызывает функцию *crypt16()*, которая, изначально, была создана для использования первых 16-ти символов пароля в некоторых операционных системах. Опять-таки, в современных ОС может использоваться больше символов.

    Exim имеет собственную версию *crypt16()*, которая является просто двойным вызовом функции *crypt()*. Для ОС которые имеют свою версию, установка ``HAVE_CRYPT16`` в *Local/Makefile* при сборке Exim, заставляет его использовать версию из ОС, а не его собственную. Этот параметр включена, по-умолчанию, в ОС-зависимом *Makefile*, для тех операционных систем, про которые известно, что они поддерживают *crypt16()*.

    Через несколько лет после создания *crypt16()* в Exim, пользователи обнаружили, что алгоритм не совпадает в некоторых версиях операционных систем. Это происходит потому, что *crypt16()* в некоторых системах называется *bigcrypt()*. Она может использовать тот же самый или иной алгоритм, и оба они могут быть иными, нежели встроенный в Exim алгоритм *crypt16()*.

    Однако, поскольку в настоящее время осуществляется уход от традиционных функций *crypt()* к использованию SHA1 и иных алгортмов, очистка этой области Exim рассматривается с низким приоритетом.

    Если вы не помещаете тип криптования в фигурные скобки, при *crypteq* сравнении, то значение по-умолчанию также ``{crypt}`` или ``{crypt16}``, как определено установкой параметра ``DEFAULT_CRYPT`` в *Local/Makefile*. Значение по умолчанию - ``{crypt}``. Вне зависимости от значения по умолчанию, вы можете использовать любую функцию, явно указав её в фигурных скобках.

  **def:<variable name>**
    Условие **def** может содержать имя одной из раскрываемых переменных, заданных в разделе :ref:`11.9 <ch11_09>`. Условие истинно, если переменная не содержит пустую строку. Например::

        ${if def:sender_ident {from $sender_ident}}

    Заметьте, что имя переменной даётся без начального символа *$*. Если переменная не существует, то раскрытие неудачно.

  **def:header_<header name>: или def:h_<header name>:**
    Это условие истинно, если сообщение обрабатывается, и указанный заголовок в нём существует. Например::

        ${if def:header_reply-to:{$h_reply-to:}{$h_from:}}

    .. note:: Символ “$” появляется в условии до **header_** или **h_**, и имя заголовка должно оканчиваться заголовком, если за ним не идёт пустое место (пробелы и прочее).


  **eq {<string1>}{<string2>}, eqi {<string1>}{<string2>}**
    Вначале раскрываются подстроки. Условие истинно, если получившиеся подстроки идентичны. Для **eq** сравнение включает и регистр букв, тогда как для **eqi** сравнение регистронезависимо.

  **exists {<file name>}**
    Подстрока раскрывается, затем интерпретируется как абсолюный путь. Условие истинно, если существует указанный файл, или директория. Проверка существования осуществляется вызовом функции *stat()*. Использование проверки **exists** в пользовательских фильтрах может быть отключено системным администратором.


  **first_delivery**
    Это условие, не имеющее никаких данных, является истинным в течение первой попытки доставки сообщения. Во время любых последующих попыток доставки оно будет ложным.


  **forall{<a list>}{<a condition>}, forany{<a list>}{<a condition>}**
    Эти условия производят обработку элементов списка. Превый аргумент раскрывается в форме списка. По умолчанию, разделитель списка - двоеточие, но он может быть изменён обычным способом. Второй аргумент интерпретируется как условие, которео будет применено к каждому элементу в списке, по кругу. В процессе интпретации условия, текущий элемент списка помещается в переменную с именем $item.

    * Для *forany*, интерпретация останавливается если условие истинно для любого элемента, и, результат всего условия - истина. Если условие ложно для всех элементов списка, общее выражение ложно.

    * Для *forall*, интерпретация останаливается если условие ложно для любого элемента, и результат всего выражения ложен. Если условие истино для всех элементов списка, общее выражение - истинно.
           
    Заметьте, что отрицание *forany* - условие должно быть ложно для всех его элементов, и общее условие будет успешным; и отрицание *forall* - условие должно быть ложным для каждого из его элементов. В этом примере, разделитель списка меняется на запятую::

        ${if forany{<, $recipients}{match{$item}{^user3@}}{yes}{no}}

    Значение $item сохраняется и востанавливается во время обработки *forany* или *forall*, для разрешения вложения этих элементов раскрытия.

  **ge {<string1>}{<string2>}, gei {<string1>}{<string2>}**
    Вначале раскрываются обе подстроки. Условие истинно, если первая строка лексически больше второй, или равна ей. Для **ge** сравнение производиться с учётом регистра, а для **gei** сравнение не зависит от регистра букв.


  **gt {<string1>}{<string2>}, gti {<string1>}{<string2>}**
    Вначале раскрываются обе подстроки. Условие истинно, если первая строка лексически больше второй. Для **gt** сравнение производиться с учётом регистра, а для **gti** сравнение не зависит от регистра букв.


  **isip {<string>}, isip4 {<string>}, isip6 {<string>}**
    Вначале подстрока раскрывается, затем проверяется, имеет ли она форму адреса IP. Оба адреса, IPv4 и IPv6 действительны для **isip**, тогда как **isip4** и **isip6** проверяют лишь адреса IPv4 и IPv6 соответственно.

    Для адресов IPv4, тестируются четыре разделённых точкой компонента, каждый из которых содержит содержит от одной до трёх цифр. для адреса IPv6, разрешено до восьми компонентов разделённых двоеточиями, каждый может содержать от одной до четырйх шестнадцатеричных цифр. Может быть меньше восьми компонентов, если есть пустые компоненты (смежные двоеточия). Допустим только один пустой компонент.

    .. note:: Проверяется только форма адреса; числовые значения не проверяются. Таким образом, “999.999.999.999” пройдёт проверку на IPv4. основное назначение этих проверок - различение между IP адресами и именами узлов, или между адресами IPv4 и IPv6. Например, можно использовать::

          ${if isip4{$sender_host_address}...
          
      для проверки, какая версия IP используется входящим SMTP подключением.


  **ldapauth {<ldap query>}**
    Это условие поддерживает пользовательскую аутентификацию, с использованием LDAP. Смотрите раздел :ref:`9.13 <ch09_13>` для получения дополнительных деталей как использовать LDAP в поисках, и каков синтаксис запросов. Для этого использования, запрос должен содержать имя пользователя и пароль. Сам запрос не используется, он может быть пустым. Условие истинно, если пароль не пуст, и имя пользователя и пароль приняты сервером LDAP. Пустой пароль отбрасысается, без вызова LDAP, поскольку LDAP считает соединения с пустым паролем анонимными, вне зависимости от имени пользователя, согласно настройкам в большинстве конфигураций. Смотрите главу :ref:`33 <ch33_00>` для получения дополнительных деталей о SMTP аутентификации, и главу :ref:`34 <ch34_00>` для примеров использования.

  **le {<string1>}{<string2>}, lei {<string1>}{<string2>}**
    Вначале раскрываются обе подстроки. Условие истинно, если первая строка лексически меньше или равна второй. Для **le** сравнение производиться с учётом регистра, а для **lei** сравнение не зависит от регистра букв.

  **lt {<string1>}{<string2>}, lti {<string1>}{<string2>}**
    Вначале раскрываются обе подстроки. Условие истинно, если первая строка лексически меньше второй. Для **lt** сравнение производиться с учётом регистра, а для **lti** сравнение не зависит от регистра букв.

  **match {<string1>}{<string2>}**
    Вначале раскрываются обе подстроки. Вначале, вторая обрабатывается как регулярное выражение. Из-за предварительного раскрытия, если регулярное выражение содержит символ “$”, или символы начинающиеся с обратного слэша, они должны быть экранированы. Также следует проявить внимание, если регулярное выражение содержит фигурные скобки. Закрывающая скобка должна стоять так, чтобы не вызывать преждевременного завершения *<string2>*. Самый лёгкий подход заключается в использовании ``\N``, для отключения раскрытия регулярного выражения. Например::

        ${if match {$local_part}{\N^\d{3}\N} ...

    Если вся раскрываемая строка находиться в двойных кавычках, то требуется дальнейшее экранирование обратных слэшей.

    Условие истинно, если регулярное выражение срабатывает. Регулярное выражение не обязано начинаться с метасимвола крышки (“^”), но если его нет, то выражение не поставлено на якорь и может соответствовать не только вначале строки, но и где-то в другом месте. Если вы хотите добиться соответствия шаблона в конце объекта, то необходимо включить метасимвол “$” в соответствующем месте.

    Вначале раскрытия **if** запоминаются значения числовых переменных (“$1”). Удовлетворение условия **match** сбрасывает их к подстрокам этого условия, и они будут иметь эти значения в процессе раскрытия успешной подстроки. В конце **if** предыдущие значения будут восстановлены. После проверки комбинации использования условий **or**, последующие значения числовых переменных - таковые из условия, которое было успешным.


  **match_address {<string1>}{<string2>}**
    Смотрите **match_local_part**.

  **match_domain {<string1>}{<string2>}**
    Смотрите “match_local_part”.

  **match_ip {<string1>}{<string2>}**
    Это условие проверяет IP-адрес на соответствие списку шаблонов IP-адресов. Оно должно содержать два параметра. Первый параметр, после раскрытия, должен быть IP-адресом или пустой строкой. Второй (после раскрытия) ограниченным списком хостов, который может соответствовать только IP-АДРЕСУ, но не имени хоста. Например::

        ${if match_ip{$sender_host_address}{1.2.3.4:5.6.7.8}{...}{...}}
        
    В списке разрешаются определённые типы элементов, согласно списку:

    * Адрес IP, необязательно с маской CIDR.

    * Отдельная звёздочка, соответствующая любому IP-адресу.

    * Пустой пункт, который совпадает с только в случае если IP-адрес пуст. Это может быть полезным, для проверки локально отправленных сообщений, или одного из специфических хостов, в одной проверке, типа::

        ${if match_ip{$sender_host_address}{:4.3.2.1:...}{...}{...}}

      где первый элемент в списке - пустая строка.

    * Элемент “@[]” совпадает с любым из адресов, на интерфейсах локальной машины.
    
    * Одноключевые поиски предполагают стиль поиска “net-” в списках хостов, даже если ``net-`` не задан. Попытки превратить IP адрес в имя хоста отсутствуют. Наиболее распространённый тип поиска для *match_ip*, вероятно, будет *iplsearch*, в случае которого файл содержит маски CIDR. Например::

          ${if match_ip{$sender_host_address}{iplsearch;/some/file}...
                                                                                                               
      Разумеется, возможно использовать другие виды поиска, и в этом случае, вам необходимо задать префикс ``net-``, если вы хотите задать определённую маску, например::

          ${if match_ip{$sender_host_address}{net24-dbm;/some/file}...
          
      Однако, если вы объединяете условие **match_ip** с другими, вы можете легко использовать тот факт что поиск - сам по себе условие, и написать::

          ${lookup{${mask:$sender_host_address/24}}dbm{/a/file}...
          
      Просмотрите раздел :ref:`10.11 <ch10_11>` для получения дополнительных деталей по этим шаблонам.


  **match_local_part {<string1>}{<string2>}**
    Это условие, вместе с **match_address** и **match_domain**, позволяет проверить домен, адрес, и локальную часть. Каждое условие требует двух аргументов: элемент и список соответствия. Тривиальный пример::

        ${if match_domain{a.b.c}{x.y.z:a.b.c:p.q.r}{yes}{no}}
       
    В каждом случае, второй аргумент может содержать любой из допустимых пунктов для списка соответсвующего типа. Кроме того, поскольку второй параметр (после раскрытия) представляет собой список стандартной формы, то можно обратиться к именованному списку. Таким образом, можно использовать такие условия::

        ${if match_domain{$domain}{+local_domains}{...

    Для списка адресов, совпадения не зависят от регистра, но может использоваться элемент ``+caseful`` как во всех списках, если захотите чтобы локальная часть совпадала регистрозависимо. Имя домена всегда сравнивается регистронезависмо.

    .. note:: Списки хостов (видимо, имеется ввиду - IP-адресов хостов) тут не поддерживаются. Причина в том, что хост имеет два идентификатора: имя и IP-адрес, и не ясно какой из них бы тут использовался для проверки. Тем не менее, проверку IP-адресов можно провести используя “match_ip”.


  **pam {<string1>:<string2>:...}**
    Подключаемые Модули Аутентификации (Pluggable Authentication Modules - http://www.kernel.org/pub/linux/libs/pam/) - это средство, которое стало доступно в последних выпусках Solaris, и в некоторых реализациях GNU/Linux [#]_. Exim поддерживает PAM, для использования с командой “SMTP AUTH”, только в случае, если он собран с:: 

        SUPPORT_PAM=yes
       
    в *Local/Makefile*. Вероятно, будет необходимо добавить **-lpam** к ``EXTRALIBS``, а в некоторох реализациях GNU/Linux, также будет необходим **-ldl**.

    Вначале раскрываются аргументы строки, и  результатом должен быть спсок, разделённый двоеточиями. Начальное и конечное пустое пространство игнорируется. Модуль PAM инициализируется с сервисным именем “exim” и именем пользователя взятым из первого элемента списка в строке разделённой двоеточиями (“<string1>”). Остающиеся в строке пункты передаются в ответ на запросы функции опознавания. В простом случае будет лишь один запрос, для пароля, и таким образом данные будут содержать лишь две строки.

    Могут быть проблемы, если в любой из строк разрешено содержаться двоеточию. Обычно, они должны быть удвоены, чтобы избежать возможности быть разделителями. Если данные вставляются из переменной, может использоваться функция **sg**, для удвоения любых существующих двоеточий. Например, конфигурация аутентификатора LOGIN может содержать эти настройки::

        server_condition = ${if pam{$auth1:${sg{$auth2}{:}{::}}}}
        
    Для PLAIN-аутентификатора можно использовать::

        server_condition = ${if pam{$auth2:${sg{$auth3}{:}{::}}}}

    В некоторых операционных системах PAM-аутентификация может быть сделана только от процесса работающего от пользователя root. Так как Exim выполняется от пользователя “exim”, при приёме сообщений, то это означает что PAM не может непосредствено использоваться в таких системах. Пропатченная версия модуля “pam_unix”, который идёт с пакетом Linux PAM, доступна на http://www.e-admin.de/pam_exim/. Пропатченный модуль разрешает одной специальной комбинации uid/gid, дополнительно root, аутентифицироваться. Если вы собираете пропатченный модуль для того, чтобы разрешить пользователя и группу Exim, PAM сможет использоватся в аутентификаторе Exim.


  **pwcheck {<string1>:<string2>}**
    Это условие поддерживает аутентификацию пользователей с использованием даемона аутентификации Cyrus pwcheck. Это один из способов проверить пароли процессу не запущенному от root. 
    
    .. note:: сейчас, использование pwcheck не рекомендуется. Его замена - saslauthd (смотрите ниже).

    Поддержка **pwcheck** не включена в Exim по-умолчанию. Вы должны задать местоположение сокета даемона **pwcheck** в *Local/Makefile* до сборки Exim. Например::

        CYRUS_PWCHECK_SOCKET=/var/pwcheck/pwcheck

    Нет необходимости устанавливать всё программное обеспечение Cyrus для использования даемона **pwcheck**. Вы можете собрать и установить только даемона из библиотеки Cyrus SASL. Обеспечьте, чтобы пользоваетель Exim`a был единственным пользователем, имеющим доступ к директории где лежит сокет даемона **pwcheck**.

    У условия **pwcheck** один аргумент, которое является и именем пользователя, и паролем, разделёнными двоеточием. Например, для аутентификации типа LOGIN, можно сделать так::

        server_condition = ${if pwcheck{$auth1:$auth2}}

    Снова, для конфигурации аутентификатора PLAIN, это было бы::

         server_condition = ${if pwcheck{$auth2:$auth3}}

  **queue_running**
    Это условие не имеет данных, и является истинным в течение попыток доставки сообщения инициированными процессо доставки, и ложным в другие моменты.

  **radius {<authentication string>}**
    Аутентификация Radius (:rfc:`2865`) поддерживается похожим на PAM способом.  Вы должны определить параметр RADIUS_CONFIG_FILE в *Local/Makefile* для задания местоположения конфигурационного файла Radius, при сборке Exim.

    При установке только этого параметра, Exim ожидает что будет слинкован с библиотекой **radiusclient**, с использованием оригинального API. Если же используется релиз этой библиотеки 0.4.0 или более поздний, то нужно установить параметр::

        RADIUS_LIB_TYPE=RADIUSCLIENTNEW

    в *Local/Makefile* при сборке Exim. Также можно слинковать Exim с библиотекой **libradius**, идущей в составе FreeBSD. Для использования этого, установите::

        RADIUS_LIB_TYPE=RADLIB

    в *Local/Makefile*, в дополнение к установленным параметром RADIUS_CONFIG_FILE. Также, вероятно, надо будет настроить EXTRALIBS чтобы библиотека Radius`a была найдена при линковке Exim.

    Строка, определённая в RADIUS_CONFIG_FILE раскрывается, и передаётся клиентской библиотеке Radius`a, которая связывается с сервером Radius. Условие истинно, если аутентификация успешнаю Например::

        server_condition = ${if radius{<arguments>}}

  **saslauthd {{<user>}{<password>}{<service>}{<realm>}}**
    Это условте поддерживает аутентификацию пользователей с использованием даемона Cyrus **saslauthd**. Он заменяет даемона pwcheck, который больше не поддерживается. Использование этого даемона - один из способов проверки паролей процессом работающим не от рута.

    Поддержка **saslauthd** не включена в Exim по-умолчанию. Вы должны указать местоположение сокета даемона **saslauthd** в *Local/Makefile*, до сборки Exim`a. Например::

        CYRUS_SASLAUTHD_SOCKET=/var/state/saslauthd/mux
        
    Нет необходимости устанавливать всё программное обеспечение Cyrus для использования даемона **saslauthd**. Вы можете собрать и установить только даемона из библиотеки Cyrus SASL. 

    До четырёх аргументов могут использоваться с условием **saslauthd**, но только два обязательны. Например::

        server_condition = ${if saslauthd{{$auth1}{$auth2}}}

    Сервис и окружение(?) являются необязательными параметрами (поэтому их параметры находятся в собственной паре фигурных скобок). Для деталей по этой службе, и как запустить даемона, обратитесь к документации по Cyrus.


.. _ch11_08:

Комбинирование условий раскрытия
--------------------------------

Несколько условий могут быть проверены за один раз, объединив их условиями **and** и **or**. Заметьте, что условия **and** и **or** самостоятельные, полноценные условия, и предшествуют своим спискам субшаблонов. Каждое подусловие должно находиться внутри фигурных скобок, вместе с общими фигурными скобками в которых находиться список. Не должно быть повторений, если используется условие **if**.

  **or {{<cond1>}{<cond2>}...}**
    Подусловия оцениваются слева направо. Условие истинно, если одно из подусловий истинно. Например::

        ${if or {{eq{$local_part}{spqr}}{eq{$domain}{testing.com}}}...
      
    Когда находиться истинное подусловие, то остальные парсятся, но не оцениваются. Если тут несколько подусловий **match**, то значения числовых переменных берутся от того, которое первым будет успешно.

      
  **and {{<cond1>}{<cond2>}...}**
    Подусловия оцениваются слева направо. Условие исинно, если все подусловия верны. Если тут несколько подусловий **match**, то значения числовых переменных берутся от последнего. Если найдено ложное подусловие, то остальные парсятся, но не оцениваются.


.. _ch11_09:

Переменные раскрытия
--------------------

Этот раздел содержит алфавитный список всех переменных раскрытия. Некоторые из них доступны только тогда, когда Exim собран со специфическими параметрами, типа поддержки TLS или параметром контентного сканирования.

  **$0, $1, и т.д.**
    Когда успешно условие **match**, эти переменные содержат фиксированные подстроки идентифицированные по регулярному выражению в течение последующего процесса успешной строки содержащей элемент **if**. Однако, они не сохраняют свои значения в последующем; фактически, их предыдущие значения восстанавливаются после окончания обработки элемента **if**. Числовые переменные, также, могут быть установлены внешне, путём некоторых процессов сравнения, которые предшествовали раскрытию строки. Например, команды доступные в файлах фильтрa Exim`a  включают команду **if** с её собственным регулярным выражением, соответствующим условию.

  **$acl_c...**
    Значения могут быть помещены в эти переменные, при помощи модификатора **set** в ACL. Им могут быть даны любые имена начинающиеся с ``$acl_c`` и не менее шести символов длинной, но, шестой символ должен быть подчёркиванием или цифрой. Например: ``$acl_c5``, ``$acl_c_mycount``. Значения переменных ``$acl_c...`` сохраняются на протяжении всей жизни SMTP подключения. Они могут использоваться для передачи информации между ACL, и различными запросами того же самого ACL. После получения сообщения, значения переменных сохраняются вместе с сообщением, и могут использоваться в фильтрах, маршрутизаторах, и транспортах в течение последующей доставки.

  **$acl_m...**
    Это такие же переменные как и ``$acl_c...``, за исключением того, что их значения сбрасываются после получения сообщения. Таким образом, если несколько сообщений передано в одном соединении SMTP, значения переменных ``$acl_m...`` не передаются от одного сообщения к следующему, как значения ``$acl_c...``. Также, переменные ``$acl_m...`` сбрасываются командами MAIL, RSET, EHLO, HELO, и после начала сессии TLS. После получения сообщения, значения переменных сохраняются вместе с сообщением, и могут использоваться в фильтрах, маршрутизаторах, и транспортах в течение последующей доставки.

  **$acl_verify_message**
    После неудачной проверки адреса, эта переменная содержит сообщение об отказе. Она сохраняет своё значение для использования в последующих модификаторах.Сообщение может быть использовано в коде, типа такого::

        warn !verify = sender
             set acl_m0 = $acl_verify_message

    Вы можете использовать $acl_verify_message в процессе раскрытия модификаторов **message** или **log_message**, для всключения информации о причине отказа.

  **$address_data**
    Эта переменная устанавливается посредством параметра **address_data** в маршрутизаторе. В процессе обработки последующими маршрутизаторами и транспортами значение остаётся с адресом. Если транспорт обрабатывает много адресов, используется значение первого адреса. Смотрите главу :ref:`15 <ch15_00>` для получения дополнительных деталей. Отметтьте: Содержимое переменной $address_data видимо (в смысле, доступно) в файлах пользовательских фильтров.

    Если $address_data установлена когда маршрутизатор вызывает ACL для проверки адреса получателя, конечное значение всё ещё находиться в переменной для последующих условий и модификаторов ACL. Если маршрутизатор сделал переадресацию только к одному адресу, дочерний адрес также маршрутизируется как часть проверки, и в этом случае окончательное содержимое $address_data получено из дочернего процесса.

    Если $address_data установлена когда маршрутизатор вызывает ACL для проверки адреса отправителя, окончательное значение также сохраняется, но на этот раз в переменной $sender_address_data, чтобы можно было отличить от данных адреса получателя.

    В обоих случаях (проверки получателя и отправителя), значение не сохраняется после конца текущей проверки ACL. Если необходимо сохранить их дальше, то можно сохранить их переменных ACL.

    
  **$address_file**
    Когда в результате перенаправления, подстановки синонима или фильтрации сообщение направлено в специфический файл, эта переменная содержит имя файла, пока выполняется транспортировка. В другое время, переменная пуста. Например, используя конфигурацию по умолчаию, у пользователя **r2d2** [#]_  в файле *.forward* содержится::

        /home/r2d2/savemail

    Тогда когда работает транспорт **address_file**, переменная $address_file содержит текстовую строку ``/home/r2d2/savemail``.

    Для фильтров Sieve, значение может быть “inbox” или относительным именем директории. Так продолжается до запуска транспорта, который построит абсолютный путь к необходимому файлу.

  **$address_pipe**
    Когда в результате перенаправления или подстановки синонима сообщение направляется в трубу (по другому - pipe, или именованный канал), переменная содержит команду трубы, пока работает транспорт.

  **$auth1 - $auth3**
    Эти переменные используются в SMTP аутентификаторах (смотрите главы :ref:`34 <ch34_00>`-:ref:`38 <ch38_00>`). В других местах они пусты.

  **$authenticated_id**
    Когда сервер полностью аутентифицирует клиента, то это (видимо, в этот момент) может быть настроено для сохранения части аутентификационной информации в переменной $authenticated_id (смотрите главу :ref:`33 <ch33_00>`). Например, конфигурация аутентификатора user/password могла бы сохранить имя пользователя, для использования в маршрутизаторах. Отметьте, что это не таже самая информация, которая сохраняется в $sender_host_authenticated. Когда сообщение посылается локально, не через TCP соединение, переменная $authenticated_id обычно содержит имя пользователя вызвавшего процесса. Однако, доверенный пользователь может переопределить это, используя параметр командной строки **-oMai**.

  **$authenticated_sender**
    Когда Exim работает как сервер, он берёт во внимание параметр AUTH= для поступающей SMTP команды MAIL, если отправителю можно доверять, как описано в разделе :ref:`33.2 <ch33_02>`. Если данные, не являются строкой “<>” [#]_ , то устанавливается что сообщение шлёт аутентифицированный отправитель, и значение доступно в процессе доставки в переменной $authenticated_sender. Если отправитель не доверенный, то Exim принимает синтаксис “AUTH=”, но игнорирует данные.

    Когда сообщение отправляется локально (т.е. не через TCP соединение), значение переменной $authenticated_sender является адресом, сконструированным из имени пользователя, и значения переменной $qualify_domain, за исключением переопределения доверенным пользователем, с использованием параметра **-oMai** командной строки.

  **$authentication_failed**
    Эта переменная устанавливается в “1”, в серевере Exim, если клиент использует команду AUTH которая неуспешна. Иначе она устанавливается в “0”. Это позволяет различить  “did not try to authenticate” (не пробовал провести аутентификацию - $sender_host_authenticated - пуста, $authentication_failed равна нулю) и “tried to authenticate but failed” (пробовал провести аутентификацию, но неуспешно - $sender_host_authenticated -пуста, $authentication_failed равна единице). Отказ включает любой отрицательный ответ на команду AUTH, включая (к примеру) попытку использовать неизвестный/неопределённый аутентификационный механизм.

  **$body_linecount**
    Когда сообщение передаётся или принимается, эта переменная содержит число строк тела сообщения. Смотрите также $message_linecount.

  **$body_zerocount**
    Когда сообщение передаётся или принимается, эта переменная содержит число бинарных нулевых байт в теле сообщения.

  **$bounce_recipient**
    В этой переменной устанавливатеся адрес получателя рикошета, когда Exim его создаёт. Полезно, если используется используется настраиваемый текстовый файл рикошетов (смотрите главу :ref:`46 <ch46_00>`).

  **$bounce_return_size_limit**
    Эта переменная содержит значение параметра **bounce_return_size_limit**, округлённой к числу кратному 1000. Полезно, если используется используется настраиваемый текстовый файл ошибок сообщений (смотрите главу :ref:`46 <ch46_00>`).

  **$caller_gid**
    Содержится реальный id той группы, под которой выполнялся процесс Exim. Это не тоже самое что и gid создателя сообщения (смотрите $originator_gid). Если Exim перезапускает себя, эта переменная в нормальнос состоянии, содержит gid Exim.

  **$caller_uid**
    Реальный uid пользователя, под которым выполняется процесс Exim. Это не тоже самое что и uid создателя сообщения (смотрите $originator_uid). Если Exim перезапускает себя, эта переменная в нормальнос состоянии, содержит uid Exim.

  **$compile_date**
    Дата, когда был скомпилен бинарник Exim.

  **$compile_number**
    Прочесс сборки Exim сохраняет число раз, сколько он был скомпилен. Это позволяет отличить другие компиляции одной и той же версии программы.

  **$demime_errorlevel**
    Эта переменная доступна когда Exim собран с поддержкой content-scanning и вышедшим из употребления условием **demime**. Детали смотрите в разделе :ref:`41.6 <ch41_06>`.

  **$demime_reason**
    Эта переменная доступна когда Exim собран с поддержкой content-scanning и вышедшим из употребления условием **demime**. Детали смотрите в разделе :ref:`41.6 <ch41_06>`.

  **$dnslist_domain, $dnslist_matched, $dnslist_text, $dnslist_value**
    Когда  успешен поиск по DNS (блэк-листы), содержимое этих переменные устанавливаются в данные из поиска: имя списка доменных имён, ключ поиска, содержимое соответствующей записи TXT, и значение из главной А записи. Для дополнительных деталей, смотрите раздел :ref:`40.29 <ch40_29>`.

  **$domain**
    Когда адрес маршрутизируется, или самостоятельно доставляется, эта переменная содержит имя домена. Символы верхнего регистра в имени домена конвертируются в символы нижнего регистра, в переменной $domain.

    При получении сообщения происходит глобальная перезапись адреса, таким образом, значение $domain при маршрутизации и доставке - значение после перезаписи. $domain устанавливается при обработке пользовательских фильтров, но не в системном фильтре, поскольку сообщение может именть много получатеелй, и системный фильтр вызывается лишь один раз.

    Когда доставляется больше одного адреса за раз, (например, несколько команд RCPT в одном SMTP соединении) $domain установлена лишь в случае, если все они имеют один и тот же домен. Транспорты могут быть ограничены обработкой только одного домена за раз, если значение $domain требуется во время работы транспорта - это, значение по-умолчанию для локальных транспортов. Для дополнительных деталей о переменных окружения во время выполнения транспортировки, смотрите главу :ref:`23 <ch23_00>`.

    В конце доставки, если все отсроченные адреса имеют один домен, он помещается в $domain в процессе раскрытия **delay_warning_condition**.

    Переменная $domain также используется при некоторых других обстоятельствах:

    * Когда выполняется ACL для команды RCPT, переменная $domain содержит домен адреса получателя. Домен адреса отправителя находиться в $sender_address_domain во время команд MAIL и RCPT. Переменная $domain, обычно не устанавливается во время работы MAIL ACL. Однако, если адрес отправителя проверен при помощи callout в процессе MAIL ACL, домен отправителя помещается в $domain в процессе раскрытия **hosts**, **interface**, and **port** и в **smtp** транспорте.

    * Во время обработки перезаписи (смотрите главу :ref:`31 <ch31_00>`), переменная $domain содержит доменную часть адреса, который перезаписывается. Это может быть использовано в в раскрытии адреса замены, например, для замены домена поиском по файлу.

    * Каждый раз когда просматривается список доменов, за одним исключением, $domain содержит обрабатываемый домен. Исключение: Когда список доменов в условии **sender_domains** обрабатывается в ACL, обрабатываемый домен содержится в $sender_address_domain, а не в $domain. Так сделано для того, чтобы в RCPT ACL список доменов отправителя мог зависеть от домена получателя (который в это время содержится в $domain).

    * Когда раскрывается параметр **smtp_etrn_command**, переменная $domain содержит полный параметр команды ERTN (смотрите раздел :ref:`45.8 <ch45_08>`)

  **$domain_data**
    Когда параметр **domains** на маршрутизаторе совпадает с доменом найденным поиском, данные прочитанные поиском, доступны в течение работы маршрутизатора как $domain_data. Кроме того, если драйвер направляет адрес в транспорт, то значение доступно и в транспорте. Если транспорт обрабатывает много адресов, используется значение из первого адреса.

    Переменная $domain_data также устанавливается когда условие **domains** в ACL совпадает с доменом найденным поиском. Данные прочитанные поиском доступны в течение остальной части условия ACL. Во всех других случаях, эта переменная ничего не содержит.

  **$exim_gid**
    Эта переменная содержит числовое значение gid группы от которой работает Exim.

  **$exim_path**
    Эта переменная содержит путь к бинарному файлу Exim.

  **$exim_uid**
    Эта переменная содержит числовое значение uid пользователя от которого работает Exim.

  **$found_extension**
    Эта переменная доступна, когда Exim собран с поддержкой content-scanning (сканирования содержимого, на вирусы, например), и устаревшим условием - **demime**. За дополнительными деталями, обратитесь к разделу :ref:`41.6 <ch41_06>`.

  **$header_<name>**
    Это не строгая переменная раскрытия. Это - синтаксис раскрытия для вставки строки заголовка сообщения с указанным именем. Заметьте, что имя может оканчиваться двоеточием или пробелом, поскольку оно может содержать разнообразные символы. Также заметьте, что фигурные скобки не должны использоваться.

  **$home**
    Когда в маршрутизаторе установлена параметр **check_local_user**, в случае успешной проверки, домашняя директория пользователя помещается в переменную $home.  В частности, это означает, что она установлена в процессе выполнения фалов фильтров пользователей. Маршрутизатор, также может явно установить основную домашнюю директорию для использования транспортом. Это может быть отменено непосредственной установкой транспорта.

    Когда работает тест фильтра, через параметр **-bf**, в $home устанваливается значение перемeнной окружения HOME.

  **$host**
    Если маршрутизатор назначает адрес транспорту (любому транспорту), и передаёт список хостов с адресами, значение $host при запуске транспорта - имя первого хоста из списка. Отметьте, что это применяется к обоим - локальному и удалённому транспортам.

    Для транспорта SMTP, если в списке более одного хоста, значение $host меняется в процессе обработки списка. В частности, когда транспорт **smtp** раскрывает свои параметры для шифрования TLS, или для определения транспортного фильтра (смотрите раздел :ref:`24 <ch24_00>`), переменная $host содержит имя сервера к которому подключился клиент.

    Когда используется клиентская часть конфигурации аутентификаторов (смотрите главу :ref:`33 <ch33_00>`), переменная $host содержит имя сервера к которому подключился клиент.

  **$host_address**
    Эта переменная содержит IP-адрес удалённого хоста каждый раз, когда устанавливается $host для удалённого соединения. Также в неё устанавливается адрес IP проверяемый в параметре **ignore_target_hosts**.

  **$host_data**
    Если условие **hosts** в ACL удовлетворяется посредством поиска, результат поиска становиться доступен в переменной $host_data. Это позволяет делать, например, такие вещи::

        deny  hosts = net-lsearch;/some/file
              message = $host_data
              $host_lookup_deferred

    В нормальном состоянии, эта переменная содержит “0”, что делает $host_lookup_failed. Когда сообщение приходит с удалённого хоста и производиться попытка поиска имени хоста по его IP-адресу, и если попытка безуспешна, эта переменная устанавливается в “1”.

    Если поиск получает какой-то отрицательный ответ (например, поиск в DNS успешен, но записей не найдено), $host_lookup_failed устанавливается в “1”.

    Если во время поиска происходят какие-то проблемы, такие, что в итоге Exim не может утверждать задано ли имя хоста (например, таймаут поиска в DNS), $host_lookup_failed устанавливается в “1”.

    Поиск имени хоста по его IP-адресу содержит больше чем просто один обратный поиск. Exim проверяет полученное имя в обратную сторону - приведёт ли оно к оригинальному IP-адресу. Если это не так, Exim не принимает найденное имя, и переменная $host_lookup_failed устанавливается в “1”. Таким образом, возможность находить имя по IP-адресу (например PTR запись в DNS) не является достаточным условием для успешного поиска имени хоста. Если обратный поиск успешен, но есть проблемы с прямым поиском, например таймаут, то имя не принимается, и $host_lookup_deferred устанавливается в “1”. Смотрите также, $sender_host_name.

  **$host_lookup_failed**
    Смотрите $host_lookup_deferred.

  **$inode**
    Единственный момент времени, когда эта переменная установлена - при раскрытии параметра **directory_file** в транспорте **appendfile**. Переменная содержит номер иноды временного файла который должен быть переименован. Это может использоваться для создания уникального имени файла.

  **$interface_address**
    Это устаревшее имя для $received_ip_address.

  **$interface_port**
    Это устаревшее имя для $received_port.

  **$item**
    Эта переменная используется в процессе раскрытия условий **forall** и **forany** (смотрите раздел :ref:`11.7 <ch11_07>`), и **filter**, **map**, элементов **reduce** (смотрите раздел :ref:`11.7 <ch11_07>`). В других ситуациях - она пуста.

  **$ldap_dn**
    Эта переменная доступна лишь если Exim собран с поддержкой LDAP, и содержит DN для последнего успешного поиска в LDAP.

  **$load_average**
    Эта переменная содержит среднюю загрузку системы, умноженную на 1000, и является целым числом. Например, если загрузка 0.21, то значение переменной 210. Значение пересчитывается каждый раз, когда ссылаются на эту переменную.

  **$local_part**
    Когда адрес маршрутизируется или доставляется владельцу, эта переменная содержит локальную часть адреса. Когда идёт одновременная доставка нескольких адресов (например, несколько RCPT команд в SMTP сессии), переменная $local_part не задана.

    Глобальная перезапись адресов происходит при получении сообщения, таким образом значение $local_part в течение маршрутизации и доставки - значение после перезаписи. $local_part устанавливается во время работы пользовательского фильтра, но не во время системного, потому что сообщение может иметь много получателей, и системный фильтр вызывается лишь один раз.

    Если локальная часть префикса или суффикса была успешно разобрана, то это не включается в значение $local_part в процессе маршрутизации и последующей доставки. Значения любой приставки или суффикса находятся в $local_part_prefix и $local_part_suffix соотвественно.

    Когда сообщение доставляется в файл, трубу или транспорт автоответа, в результате перенаправления или подстановки синонима, $local_part устанавливается в локальную часть родительского адреса, не к имени файла или команды (смотрите $address_file и $address_pipe).

    Когда ACl запускается для команды RCPT, $local_part содержит локальную часть адреса получателя.

    Когда срабатывает перезапись (смотрите глава :ref:`31 <ch31_00>`), $local_part содержит локальную часть адреса который перезаписывается, это может быть использовано, например, в раскрытиях замены адреса.

    Во всех регистрах, все кавычки удаляются из локальной части. Например, оба адреса::

        "abc:xyz"@test.example
        abc\:xyz@test.example

    дадут значение $local_part::

        abc:xyz
        
    Если вы используете $local_part для создания других адресов, вы всегда должны обрабатывать его в операторе **quote**. Например, в переадресовывающем маршрутизаторе, можно сделать так::

        data = ${quote_local_part:$local_part}@new.domain.example
                                          
    .. note:: Обычно, значение $local_part в нижнем регисте, если вы хотите обрабатывать локальные части в маршрутизаторе в регистрозависимой манере, вы должны установить параметр **caseful_local_part** (смотрите главу :ref:`15 <ch15_00>`).

  **$local_part_data**
    Когда параметр **local_part** на маршрутизаторе совпадает с локальной частью найденной поиском, данные прочитанные поиском доступны в течение выполнения маршрутизатора, как $local_part_data. Кроме того, если драйвер маршрутизирует адрес в транспорт, значение доступно и в транспорте. Если транспорт обрабатывает много адресов, используется значение первого адреса.

    Переменная $local_part_data также устанавливается когда условие **local_part** в ACL совпадает с локальной частью найденной поиском. Данные прочитанные поиском доступны в течение остальной части ACL. Во всех других ситуациях, значение переменной пустое.

  **$local_part_prefix**
    Когда адрес маршрутизируется или доставляется владельцу, и распознан специфический преффикс для локальной части, он доступен в этой переменной, удалённой из $local_part.

  **$local_part_suffix**
    Когда адрес маршрутизируется или доставляется владельцу, и распознан специфический суффикс для локальной части, он доступен в этой переменной, удалённой из $local_part.

  **$local_scan_data**
    Эта переменная содержит текст, возвращённый функцией *local_scan()*, при получении сообщения. За дополнительными деталями, обратитесь к главе :ref:`42 <ch42_00>`.

  **$local_user_gid**
    Смотрите $local_user_uid.

  **$local_user_uid**
    В эту переменную, и $local_user_gid устанавливаются значения uid и gid после успешного предварительного условия **check_local_user** в маршрутизаторе. Это означает, что их значения доступны для остальных, неотработавших, предварительных условий (**senders**, **require_files**, и **condition**), для раскрытия **address_data**, и для других, специфичных для маршрутизатора условий. В любой другой момент времени, значения в этих переменных ``(uid_t)(-1)`` и ``(gid_t)(-1)``, соответственно.

  **$localhost_number**
    Тут содержится раскрытое значение параметра **localhost_number**. Это раскрытие происходит после прочтения основных параметров.

  **$log_inodes**
    Число свободных inode в дисковом разделе, куда пишутся логи Exim`a. Это значение пересчитывается каждый раз, когда ссылаются на эту переменную. Если файловая система не знает, что такое inode, то значение переменной равно “-1”. Также смотрите параметр **check_log_inodes**.

  **$log_space**
    Размер свободного места (в килобайтах) на дисковом разделе, в который пишутся логи Exim`a. Это значение пересчитывается каждый раз, когда ссылаются на эту переменную. Если операционная система не способна вычислять размер свободного пространства (истинно только для экспериментальных систем), то значение переменной равно “-1”. Также смотрите параметр **check_log_space**.

  **$mailstore_basename**
    Эта переменная устанавливается только при работе доставки в формате “mailstore” в транспорт **appendfile**. В процессе раскрытия параметра **mailstore_prefix**, **mailstore_suffix**, **message_prefix**, и **message_suffix** она содержит имена записываемых файлов, т.е. имя без суффикса “.tmp”, “.env”, или “.msg”. В любое другое время переменная пуста.

  **$malware_name**
    Эта переменная доступна когда Exim скомпилен с поддержкой контентного сканирования. Она устанавливается в имя вируса, который был найден, когда условие “malware” ACL истинно (:ref:`41.1 <ch41_01>`).

  **$max_received_linelength**
    Эта переменная содержит число байт в самой длинной строке, которая была передана как часть сообщения, не считая символа завершения строки.

  **$message_age**
    Эта переменная устанавливается в начале попытки доставки сообщения, в число секунд с тех пор как сообщение было получено. Оно не изменяется в течение одной (видимо, текущей) попытки доставки.

  **$message_body**
    Во время доставки, эта переменная содержит начальную часть сообщения, и предназначена, главным образом, для файлов фильтра пользователей. Максимальное число символов тела сообщения, помещаемое в переменную, устанавливается конфигурационным параметром **message_body_visible**; по умолчанию - 500.

     По умолчанию, символы новой строки в $message_body преобразуются в пробелы, для облегчения поиска фраз, которые были бы разбиты по переводу строки. Однако, это может быть отключено, установкой **message_body_newlines** в истину. Двоичные нули также преобразовываются в пробелы.

  **$message_body_end**
    Во время доставки, эта переменная содержит конец тела сообщения. Формат и максимальный размер такой же как и у $message_body.

  **$message_body_size**
    Во время доставки, эта переменная содержит размер тела сообщения в байтах. Счёт начинается после с символа после пустой линии, отделяющей заголовки от сообщения. Смотрите также $message_size, $body_linecount и $body_zerocount.

  **$message_exim_id**
    Когда сообщение получается или доставляется, эта переменная содержит уникальный идентификатор сообщения, созданный и используемый Exim`ом для идентификации сообщения. Идентификатор не создаётся для сообщения до тех пор, пока его заголовок не получен. 
     
    .. note:: Это не содержимое стрки заголовка “Message-ID:”, это локальный идентификатор назначаемый Exim`ом сообщению, например ``1BXTIK-0001yO-VA``.

  **$message_headers**
    Эта переменная содержит все строки заголовка, во время обработки сообщения, за исключением строк добавленных маршрутизатором и транспортами. Строки заголовка разделены символами новой строки.

  **$message_headers_raw**
    Эта переменная подобна $message_headers, за тем исключением что обработка содержимого заголовков не производиться.

  **$message_id**
    Это старое название $message_exim_id, которое теперь не используется.

  **$message_linecount**
    Эта переменная содержит общее количество строк в заголовке и теле сообщения. Сравните с $body_linecount содержащей лишь число строк в теле сообщения. В процессе DATA и ACL занимающихся контентным сканированием $message_linecount содержит число полученных строк. До доставки (т.е. перед фильтрами, маршрутизаторами и транспортами) счётчик увеличен, чтобы включить строку заголовка “Received:”, стандартно добавляемую Exim`ом, и любые другие заголовки, добавляемый ACL`ами. Пустая строка, отделяющая заголовки от тела сообщения не подсчитывается. Вот пример использования этой переменной в DATA ACL::

        deny message   = Too many lines in message header
             condition = \
               ${if <{250}{${eval:$message_linecount - $body_linecount}}}
               
    В MAIL и RCPT ACL`ах значение этой переменной - ноль, поскольку на этих стадиях сообщение ещё не получено.

  **$message_size**
    Когда сообщение находится в процессе обработки, эта переменная содержит число байт. В большинстве случаев, размер включает те заголовки, которые были получены с сообщением, но не те (типа “Envelope-to:”), которые были добавлены индивидуальными доставкми.Однако, есть один специальный случай: в процессе раскрытия параметра **maildir_tag** в транспорте **appendfile**, когда доставка происходит в формате “maildir”, значение $message_size - точный размер файла, который был записан (на диск). Смотрите также $message_body_size, $body_linecount и $body_zerocount.

    При выполнении ACL зависимых от сообщения (mail/rcpt/predata), $message_size содержит размер предоставленный командой MAIL, или “-1”, если он не был предоставлен. Разумеется, значение может быть неверным или заведомо ложным.

  **$mime_xxx**
    Множество переменных, с именами начинающимися на $mime доступны, в случае, если Exim собран с поддержкой контентного сканирования. Для дополнительных делалей, смотрите раздел :ref:`41.4 <ch41_04>`.

  **$n0 – $n9**
    Эти переменные - счётчики, которые могут быть увеличены при помощи команды add в файлах фильтров.

  **$original_domain**
    Когда адрес верхнего уровня обрабатывается для доставки, эта переменная содержит тоже самое значение, что и $domain. Однако, если “дочерний” адрес (например, созданный в результате подстановки синонима, перенаправления или выполнения фильтра) обрабатывается, эта переменная содержит доменную часть оригинального адреса (в нижнем регистре). Это отличается от $parent_domain только когда здесь больше одного уровня перенаправления или подстановки синонима. Когда происходит доставка более чем по одному адресу в одном транспорте, переменная $original_domain не установлена.

    Если новый адрес создан с помощью команды **deliver** в системном фильтре, то она (эта переменная) установлена с искуственным “родительским” адресом. В таком случае локальная часть “system-filter” и доменная - домен по умолчанию, из конфигурации.


  **$original_local_part**
    Когда адрес верхнего уровня обрабатывается для доставки, эта переменная содержит тоже самое значение, что и $local_part, за исключением, если суффикс или преффикс были удалены из локальной части, поскольку $original_local_part всегда содержит полную локальную часть. Когда “дочерний” адрес (например, созданный в результате подстановки синонима, перенаправлением или выполнения фильтра) обрабатывается, эта переменная содержит полную локальную часть оригинального адреса.

    Если маршрутизатор (процесс переназначения) нечувствителен к регистру локальной части адреса, значение $original_local_part в нижнем регистре букв. Эта переменная отличается от $parent_local_part только в случае, если больше одного уровня перенаправления или подстановки синонима. Когда происходит доставка более чем по одному адресу в одном транспорте, переменная $original_local_part не установлена.

    Если новый адрес создан с помощью команды **deliver** в системном фильтре, то она (эта переменная) установлена с искусственным “родительским” адресом. В таком случае локальная часть “system-filter” и доменная - домен по умолчанию, из конфигурации.


  **$originator_gid**
    Эта переменная содержит значение переменной $caller_uid, установленной при получении сообщения. Для сообщений полученных через командную строку, это gid пославшего его пользователя. Для сообщений полученных через TCP/IP, это, обычно, gid пользователя от которого работает Exim.

  **$parent_domain**
    Эта переменная подобна $original_domain (смотрите выше), за исключением того, что  относится непосредственно к предыдущему родительскому адресу.

  **$parent_local_part**
    Эта переменная подобна $original_local_part (смотрите выше), за исключением того, что  относится непосредственно к предыдущему родительскому адресу.

  **$pid**
    Эта переменная содержит идентификатор процесса текущего процесса.

  **$pipe_addresses**
    Это не раскрываемая переменная, но она упомянута тут, поскольку строка $pipe_addresses обрабатывается специально в командной спецификации для транспорта “pipe” (главу :ref:`29 <ch29_00>`) и в транспортных фильтрах (описанных как **transport_filter** в главе :ref:`24 <ch24_00>`). Она не может использоваться в основных строках раскрытия и вызывает ошибку “неизвестная переменная” если с ней там сталкиваются.


  **$primary_hostname**
    Эта переменная содержит значение установленное пунктом **primary_hostname** в конфигурационном файле, или прочитанное функцией *uname()*. Если *uname()* возвращает однокомпонентное имя, то Exim вызывает функцию *gethostbyname()* (или *getipnodebyname()* - какая доступна) в попытке получить полное имя хоста. Смотрите также $smtp_active_hostname.

  **$prvscheck_address**
    Эта переменная используется вместе с элементом раскрытия “prvscheck”, который описан в разделах :ref:`11.5 <ch11_05>` и :ref:`40.47 <ch40_47>`.

  **$prvscheck_keynum**
    Эта переменная используется вместе с элементом раскрытия “prvscheck”, который описан в разделах :ref:`11.5 <ch11_05>` и :ref:`40.47 <ch40_47>`.

  **$prvscheck_result**
    Эта переменная используется вместе с элементом раскрытия “prvscheck”, который описан в разделах :ref:`11.5 <ch11_05>` и :ref:`40.47 <ch40_47>`.

  **$qualify_domain**
    Значение этой переменной устанавливается параметром **qualify_domain** из конфигурационного файла.

  **$qualify_recipient**
    Значение этой переменной устанавливается параметром **qualify_recipient** из конфигурационного файла, или, если там не задано, значением $qualify_domain.

  **$rcpt_count**
    Когда сообщение получается по SMTP, эта переменная содержит число команд RCPT переданных для текущего сообшения. Если эта переменная используется в RCPT ACL, то её значение включает текущую команду.

  **$rcpt_defer_count**
    Когда сообщение получается по SMTP, эта переменная содержит число команд RCPT в текущем сообщении, которые были ранее отклонены с временным (4xx) ответом.

  **$rcpt_fail_count**
    Когда сообщение получается по SMTP, эта переменная содержит число команд RCPT в текущем сообщении, которые были ранее отклонены с постоянным (4xx) ответом.

  **$received_count**
    Эта переменная содержит число заголовков “Received:” в сообщении, включая один, добавленный Exim`ом (таким образом, это значение всегда больше нуля). Оно доступно в DATA ACL, в не-SMTP ACL, и во время маршрутизации и доставки.


  **$received_for**
    Если во входящем сообщении только один адрес получателя, то эта переменная содержит адрес, из строки заголовка “Received:”, после её получения. Значение копируется после перезаписи адреса получателя, но до запуска функции *local_scan()*.

  **$received_ip_address**
    Как только Exim запускает обработку входящего TCP/IP соединения, эта переменная устанавливается в адрес локального IP интерфейса, а $received_port - в номер локального порта. (удалённый IP адрес и порт находяться в $sender_host_address и $sender_host_port) При тестировании с использованием параметра **-bh**, значение порта - “-1”, если он не задан параметром **-oMi**.

    Будучи полезной в ACL (включая “connect” ACL), эти переменные могут быть использованы, например, для создания имени файла для сертификата TLS, зависимого от интерфейса и/или порта, используемого для входящего соединения. Значения $received_ip_address и $received_port сохраняются с любым принятым сообщением, таким образом, становясь доступными во время доставки.

    .. note:: Эквивалентные переменные для исходящего соединения отсутствуют, поскольку значения неизвестны (за исключением случая, когда они явно заданы транспортом **smtp**).

  **$received_port**
    Смотрите $received_ip_address.

  **$received_protocol**
    При обработке сообщения, эта переменная содержит имя протокола по которому получено сообщение. Большинство имён, используемых Exim, определено :rfc:`821`, :rfc:`2821`, и :rfc:`3848`. Они начинаются с “smtp” (клиент использовал HELO) или “esmtp” (клиент использовал EHLO). Они могут содержать “s” если было безопасное (шифрованное) соединение и/или “a” для аутентифицированных. таким образом, если получается протокол “esmtpsa”, то сообщение было передано по шифрованному SMTP соединению, и клиент был успешно аутентифицирован.

    Exim использует имя протокола “smtps” для случая, когда шифрование автоматически включается при соединении без использования STARTTLS (смотрите **tls_on_connect_ports**), и клиент использует HELO для начала шифрованного сеанса SMTP. Имя “smtps” также используется для редкой ситуации, когда клиент первоначально использует EHLO, устанавливает шифрованное соединение, используя STARTTLS, и затем использует HELO.

    Параметр **-oMr** обеспечивает возможность определить имя протокола для сообщений которые отправлены локально, от доверенных отправителей. Обычно это используется для идентификации сообщений, которые повторно инжектятся после сканирования.

  **$received_time**
    Эта переменная содержит дату и время, когда текущее сообщение было получено, в виде секунд с начала эпохи Unix.

  **$recipient_data**
    Эта переменная устанавливается после успешного индексного поиска в ACL условии **recipients**. Она содержит данные из поиска, и значение остаётся установленным до следующей проверки **recipients**. Таким образом, можно делать такие вещи::

        require recipients  = cdb*@;/some/file
        deny    some further test involving $recipient_data
        
    .. warning:: Эта переменная установлена только в случае, если поиск как метод индексации в списке адресов, с использованием синткаксиса точки с запятой, как в примере. Переменная не установлена для поиска, который используется как часть раскрытия строки, которому все такие списки подвергаются до интерпретации.


  **$recipient_verify_failure**
    В ACL, когда проверка получателя неудачна, эта переменная содержит информацию о ошибке. Это может быть одно из следующих слов:

    * “qualify”: Адрес был неполный (нет домена), и сообщение не являлось ни локальным, ни прибывшим от неучтённого хоста.
    * “route”: Неудачная маршрутизация.
    * “mail”: Маршрутизация была удачной, и был предпринят обратный вызов; отклонение произошло до команды MAIL (n/t при начальном подключении, HELO, или MAIL)
    * “recipient”: Команда RCPT в обратном вызове была отклонена.
    * “postmaster”: Была отклонена проверка postmaster`а в обратном вызове.
    
    Ожидаемое главное использование этой переменной, для различения реджектов MAIL и реджектов RCPT.

  **$recipients**
    Эта переменная содержит список получателей сообщения. Адреса разделяютя запятыми и пробелами в тексте замены. Однако, перменная не является общедоступной, для предотвращения просмотра “Bcc” получателей  в непривелигированных пользовательских фильтрах. Вы можете использовать $recipients только в этих случаях:

    1. В файле системного фильтра.
    2. В ACL ассоциированных с командой DATA, и с не-SMTP сообщениями, т.е. ACL заданными путём **acl_smtp_predata**, **acl_smtp_data**, **acl_smtp_mime**, **acl_not_smtp_start**, **acl_not_smtp**, и **acl_not_smtp_mime**.
    3. Из функции *local_scan()*.

  **$recipients_count**
    В процессе обработки сообщения эта переменная содержит число получателей сообщения, которые шли с сообщением (имеется ввиду, что тут не учтены получатели, добавленные в процессе обработки). Дубликаты не исключаются из подсчёта. Во время приёма сообщения по SMTP, число увеличивается, для каждого принятого получателя. Её можно использовать в ACL.

  **$regex_match_string**
    Эта переменная содержит соответствующее регулярное выражение, после совпадения условия “regex” ACL (смотрите раздел :ref:`41.5 <ch41_05>`).


  **$reply_address**
    В процессе обработки сообщения, в этой переменной находится содержимое строки заголовка “Reply-To:”, если она существует и непуста, иначе она содержит значение из строки заголовка “From:”. Кроме удаления начального пустого пространства, эта переемнная никак не обрабатывается. В частности, не производится расшифровка по :rfc:`2047` или символьная замена кода.

  **$return_path**
    Во время доставки сообщения, эта переменная содержит обратный путь - поле отправителя, посылаемую как часть конверта. Оно не заключено в символы “<>”. В начале маршрутизации адреса, $return_path установлена в тоже значение, что и $sender_address, но если, например, входящее сообщение листа рассылки раскрыто маршрутизатором, определяющим другой адрес для возврата, то впоследствии $return_path содержит другой адрес возврата, тогда как $sender_address всегда содержит оригинальный адрес отправителя, полученный с сообщением. Если сказать по-другому, $sender_address содержит адрес отправителя входящего конверта, и $return_path содержит адрес исходящего конверта.

  **$return_size_limit**
    Это устаревшее название $bounce_return_size_limit.

  **$runrc**
    Эта переменная содержит код возврата команды, выполненой в элементе раскрытия **${run...}**. 
    
    .. warning:: В маршрутизаторе или транспорте, вы не можете предположить порядок раскрытия параметров, за исключением тех предварительных условий, чей порядок тестирования задокументирован. Поэтому невозможно ожидать установки $runrc в раскрытии одного параметра, и использовать её в другой.

  **$self_hostname**
    Когда адрес направлен к возможному удалённому хосту, тут устанавливается локальный хост, этот случай контролируется общей **self** настройкой маршрутизатора. Одно из его значений заставляет передать адрес другому маршрутизатору. Когда такое происходит, значение $self_hostname будет именем локального хоста, с которым столкнулся маршрутизатор. При других обстоятельствах оно будет пустым (null).

  **$sender_address**
    При обработке сообщения, эта переменная содержит адрес отправителя, полученный в конверте сообщения. Регистр букв адреса сохраняется, и в локальной части, и в домене. Для рикошетов, значение будет пустой строкой. Смотрите также $return_path.

  **$sender_address_data**
    Если переменная $address_data установлена, когда маршрутизаторы вызываются из ACL для проверки адреса отправителя, то окончательное значение сохраняется в $sender_address_data, для возможности отличить его от адреса получателя. Значение не сохраняется после окончания текущей ACL. Если необходимо сохранять его дольше, то вы можете сохранить его в переменных ACL.

  **$sender_address_domain**
    Доменная часть $sender_address.

  **$sender_address_local_part**
    Локальная часть $sender_address.

  **$sender_data**
    Эта переменная устанавливается после успешного поиска в условии ACL **senders**, или в параметре **senders**, маршрутизатора. Оно содержит данные поиска, и и значение остаётся установленным до следующей проверки **senders**. Таким образом, можно делать такие вещи::

        require senders      = cdb*@;/some/file
        deny    some further test involving $sender_data
        
    .. warning::  Эта переменная установлена тольков случае, если поиск используется как метод индексации в списке адресов, используя синтаксис точки с запятой, как в примере выше. Переменная не установлена для поиска который использует часть строки раскрытия, которому подвергаются все списки, до интерпретации.

  **$sender_fullhost**
    Когда сообщение получено от удалённого хоста, эта переменная содержит имя хоста и адрес IP в одной строке. Она заканчиватся IP-адресом в квадратных скобках, с номером порта через двоеточие, если включено логирование портов. Формат остальной части строки зависит от того, какая была SMTP команда хоста - HELO или EHLO, и было ли подверждено имя хоста поиском по его IP-адресу. (Поиск IP-адреса модет быть вызыван параметром **host_lookup**, независимой от проверки). Простое имя хоста в начале строки - провереное имя хоста; если оно отсутствует, проверка или не проводилась, или не требовалась. Имя хоста в круглых скобках - параметр команды HELO или EHLO. Оно пропущено, если оно идентично проверенному имени хоста или IP-адресу в квадратных скобках.


  **$sender_helo_name**
    Когда сообщение получено с удалённого хоста, давшего команду HELO или EHLO, аргумент этой команды помещается в эту переменную. Также оно устанавливается если HELO или EHLO использовалось при локальном SMTP с параметрами **-bs** или **-bS**.

  **$sender_host_address**
    Когда сообщение получено от удалённого хоста, эта переменная содержит IP-адрес удалённого хоста. Для локальных сообщений значение пустое.

  **$sender_host_authenticated**
    Эта переменная содержит имя (не публичное имя) драйвера аутентификации, который успешно подтвердил подлинность клиента, от которого получено сообщение. Оно пустое, если аутентификации не было. Смотрите также $authenticated_id.

  **$sender_host_name**
    Когда сообщение передаётся с удалённого хоста, эта переменная содержит имя хоста, полученное поиском по его IP-адресу. Для сообщений полученных другими способами, эта переменная пуста.

    Если имя хоста предварительно не искалось, ссылка на $sender_host_name вызывает поиск (для сообщений с удалённых хостов). Найденное имя принимвается, только если оно, при прямом поиске по нему, возвращает оригинальный IP. Если или прямой, или обратный поискне могут найти какие-то данные, или если прямой поиск не приводит к первоначальному IP, то $sender_host_name остаётся пустым, и $host_lookup_failed устанавливается в “1”.

    Однако, если любой из поисков не может быть завершён (например, произошёл таймаут DNS), $host_lookup_deferred устанавливается в  “1”,  и $host_lookup_failed остаётся установленным в  “0”.

    Когда $host_lookup_failed установлена в “1”, Exim не пробует снова найти имя хоста при наличии информации о $sender_host_name в другом процессе Exim`a, но он пробует ещё раз, если $host_lookup_deferred установлена в “1”.

    Exim не ищет, автоматически, каждое имя хоста. Если вы хотите максимальной эффективности, вы должны упорядочить вашу конфигурацию так, чтобы вообще избежать этого поиска. Поиск происходит лишь в случае, если одно или больше условий истинны:

    * Строка содержащая $sender_host_name раскрыта.
      
    * Хост с которого идёт запрос, совпадает со списком “host_lookup”. В конфигурации по умолчанию, этот параметр установлена в \*, для устранения поиска надо этот пункт изменить (закомментить - в самом коде этот параметр по умолчанию не включена).
    
    * Экзим нуждается в имени хоста, для проверки элемента в списке хостов. Пункты, которые требуют этого, описаны в разделах :ref:`10.13 <ch10_13>` and :ref:`10.16 <ch10_16>`.
    
    * Хост запроса соответствует **helo_try_verify_hosts** или **helo_verify_hosts**. В этом случае, имя хоста требует сравнения с именем, указанным в командах EHLO или HELO, отданных клиентом. 
    
    * Удалённый хост даёт команду EHLO или HELO, которая содержит один из доменов в **helo_lookup_domains**. Значение по умолчанию этого параметра::

          helo_lookup_domains = @ : @[]

      и она вызывает поиск лишь в случае, если удалённый хост некорректно отдал имя сервера или IP-адрес в команде EHLO или HELO.

  **$sender_host_port**
    Когда сообщение получено с удалённого хоста, эта переменная содержит номер порта использовавшегося удалённым хостом.

  **$sender_ident**
    Когда сообщение получено с удалённого хоста, эта переменная содержит идентификацию перезанную в ответ на запрос по :rfc:`1413`. Когда сообщение получено локально, эта переменная содержит имя пользователя вызвавшего Exim.

  **$sender_rate_xxx**
    Множество переменных, имена которых начинаются с “$sender_rate_”, установленных как часть условия ACL “ratelimit”. Детали смотрите в разделе :ref:`40.35 <ch40_35>`.

  **$sender_rcvhost**
    Это необходимо для использования в заголовках “Received:”. Она начинается с любого проверенного имени хоста (полученного от обратным поиском в DNS) или, если нет проверенного имени, IP-адресом в квадратных скобках. После этого, в круглых скобках может быть текст. Когда первый пункт - проверенное имя хоста, первый элемент в круглых скобках - IP-адрес в квадратных скобках, с номером порта через двоеточие, если разрешено логирование портов. Когда первый элемент - IP-адрес, то порт записывается внутри круглых скобок, в виде “port=xxxx”.

    Также могут быть пункты вида “helo=xxxx”, если использовались HELO или EHLO, и их параметр не был идентичен реальному имени хоста или IP, и “ident=xxxx” если доступна строка ident из :rfc:1413. Если все три элемента присутствуют в круглых скобках, то в строку вставляется символ новой линии и символ табуляции для улучшения читабельности заголовка “Received:”.

  **$sender_verify_failure**
    В ACL, когда проверка отправителя неудачна, эта переменная содержит информацию об ошибке. Детали такие же как и у $recipient_verify_failure.

  **$sending_ip_address**
    Эта переменная устанавливается всякий раз когда устанавливается исходящее SMTP соединение к другому хосту. Она содержит используемый IP адрес локального интерфейса. Это полезно, если хост имеющий более одного IP адреса хочет по разному вести себя, в зависимости от используемого адреса. Для входящих соединений, смотрите переменную $received_ip_address.

  **$sending_port**
    Эта переменная устанавливается всякий раз когда устанавливается исходящее SMTP соединение к другому хосту. Она содержит используемый локальный порт. Для входящих соединений, смотрите переменную $received_port.

  **$smtp_active_hostname**
    Во время входящего сеанса SMTP, эта переменная содержит значение имени активного хоста, определённого параметром **smtp_active_hostname**. Значение $smtp_active_hostname сохраняется с любым принятым сообщением, и его значение можно использовать во время маршрутизации и доставки.

  **$smtp_command**
    В процессе обработки входящей SMTP команды, эта переменная содержит всю команду. Это позволяет различать HELO и EHLO в ACL, а иакже различать команды, типа::

        MAIL FROM:<>
        MAIL FROM: <>

    Для команды MAIL, могут быть просмотрены дополнительный параметры, типа SIZE. Для команды RCPT, адрес в $smtp_command - оригинальный адрес, до любой перезаписи, тогда как значения в $local_part и $domain взяты из адреса после SMTP-перезаписи.

  **$smtp_count_at_connection_start**
    Эта переменная устанавливается в значение больше нуля лишь в процессе порождения Exim'ом даемона для обработки входящего SMTP соединения. Имя её умышленно сделано длинным, с целью подчеркнуть содержимое. Когда даемон принимает новое соединение, он увеличивает эту переменную. Копия переменной передаётся дочернему процессу, обрабатывающему соединение, но это значение - фиксировано, и никогда не меняется. Это лишь приближенное значение - как много входящих соединений, поскольку многие другие соединения могут начаться и закончиться в процесе обработки этого. Когда дочерний процесс завершается, даемон уменьшает свою копию переменной.

  **$sn0 - $sn9**
    Эти переменные - копии значений “$n0”-“$n9”, сумматоры бывшие в конце файла системного фильтра. Это позволяет системному фильтру устанавливать значения, которые могут быть проверены в файлах фильтров пользователей. Например, системный фильтр мог установить значение, указывающее, что это сообщение, вероятно, является спамом.

  **$spam_xxx**
    Множество переменных с именами начинающимися с “$spam” доступны, если Exim скомпилен с расширением контентного сканирования. Для дополнительных деталей, смотрите раздел :ref:`41.2 <ch41_02>`.

  **$spool_directory**
    Имя директории спула для Exim`a.

  **$spool_inodes**
    Число свободных inоde в дисковом разделе, где Exim держит свои spool-файлы. Значение пересчитывается каждый раз, когда к нему обращаются. Если файловая система не имеет понятия inode, то значение будет -1. Также смотрите параметр **check_spool_inodes**.


  **$spool_space**
    Количество свободного места (как число килобайт) в дисковом разделе, где пишутся spool-файлы Exim`a. Значение пересчитывается каждый раз, когда на переменную ссылаются. Если операционная система не может подсчитать количество свободного места (истинно для экспериментальных систем), то значение будет -1. Например, чтобы проверит в ACL, что есть хотябы 50 мегабайт свободного места в спуле, можно написать::

        condition = ${if > {$spool_space}{50000}}
                                                                                                      
    Также смотрите параметр **check_spool_space**.

  **$thisaddress**
    Эта переменная установлена только в процессе обработки команды **foranyaddress** в файле фильтра. Её использование объясняется в описании той команды, которая может быть найдена в документации на интерфейс фильтрации почты Exim`a.

  **$tls_certificate_verified** 
    Эта переменная установлена в “1”, если при приёме сообщения сертификат TLS проверен, и “0” в обратном случае.

  **$tls_cipher**
    Когда сообщение получено с удалённого хоста по шифрованному SMTP-подключению, эта переменная содержит использовавшийся тип шифрования, например DES-CBC3-SHA. При других обстоятельствах, в частности, для сообщения полученного по незашифрованным подключениям, переменная пуста. Проверка что переменная “$tls_cipher” пуста - один из способов различить шифрованное и нешифрованное соединение при обработке ACL.

    Переменная $tls_cipher сохраняет своё значение в процесе доставки сообщения, за исключением случая когда исходящая SMTP доставка происходит через транспорт **smtp**. В этом случае, $tls_cipher очищается до того как произойдут какие-либо исходящие SMTP соединения, и затем устанавливается в шифрование исходящего соединения, если оно происходит. Смотрите главу :ref:`38 <ch38_00>` для подробностей о поддержке TLS, и главу :ref:`30 <ch30_00>` - подробности о транспорте **smtp**.

  **$tls_peerdn**
    Когда сообщение получено с удалённого хоста по шифрованному SMTP-подключению, и Exim настроен для запроса сертификата с клиента, значение переменной - имя сертификата, доступное в $tls_peerdn в процессе последующей обработки. Как и $tls_cipher, значение сохраняется в процессе доставки сообщения, за исключением исходящих SMTP доставок.

  **$tod_bsdinbox**
    Время и дата в формате BSD-майлбокса, например: Thu Oct 17 17:14:09 1995.

  **$tod_epoch**
    Время и дата в виде числа секунд с начала эпохи Unix.

  **$tod_full**
    Полная версия времени и даты, например: Wed, 16 Oct 1995 09:51:40 +0100. Временной пояс всегд даётся как часово смещение от UTC, с положительными значениями для поясов которые впереди (к востоку), и отрицательных значений для тех, которые позади (на западе).

  **$tod_log**
    Время и дата в формате используемом Exim`ом в его лог-файлах, например: 1995-10-12 15:32:29, но без временной зоны.

  **$tod_logfile**
    Эта переменная содержит дату в формате yyyymmdd. Этот формат используется для штампа даты в файлах логов, когда **log_file_path** содержит флаг ``%D``.

  **$tod_zone**
    Эта переменная содержит числовое значение локальной временной зоны, например: -0500.

  **$tod_zulu**
    Эта переменная содержит дату и время в формате “Zulu”, как задано в ISO8601, например: 20030221154023Z.

  **$value**
    Эта переменная содержит результат раскрытия поиска, операции извлечения, или внешней команды, как описано выше. Также, она используется в процессе раскрытий.

  **$version_number**
    Номер версии Exim.

  **$warn_message_delay**
    Эта переменная установлена только в течение создания предупредительного сообщения о задержке доставки. Детали по её использованию раскрыты в разделе :ref:`46.2 <ch46_02>`.

  **$warn_message_recipients**
    Эта переменная установлена только в течение создания предупредительного сообщения о задержке доставки. Детали по её использованию раскрыты в разделе :ref:`46.2 <ch46_02>`.

.. [#] нихрена толком не понял этой фразы
.. [#] ага, слова из трёх букв, например :)
.. [#] почему-то неоправданно забыта FreeBSD. Непорядок - ибо во FreeBSD PAM также доступен
.. [#] однако, документацию писали юмористы :), прим. lissyara
.. [#] странно, получается аутентифицировавшийся отправитель без имени...?
