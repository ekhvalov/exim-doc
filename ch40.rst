
.. _ch40_00:

=======================
Списки Контроля Доступа
=======================

Списки Контроля Доступа (Access Control Lists - ACL) заданы в отдельной секции рабочего конфигурационного файла, озаглавленной “begin acl”. Каждое определение ACL начинается с имени, завершённого двоеточием. Это - полная секция ACL, которая содержит лишь одну, очень маленькую ACL::

    begin acl

    small_acl:
      accept   hosts = one.host.only

Вы можете иметь так много списков, как вы хотите в секции ACL, и порядок их появления не имеет значения. Списки заканчиваются автоматически.

Большинство ACL используются для контроля поведения Exim'a, когда он получает определённые SMTP-команды. Это применяется к обоим - входящим TCP/IP соединениям, и, когда локальный процесс передаёт сообщения используя  SMTP через задание параметра командной строки **-bs**. Самое обычное использование - для контроля каких получателей принимать во входящих сообщениях. Кроме того, вы можете задать ACL которые используются для проверки не-SMTP сообщений. Конфигурационный файл по умолчанию содержит примеры реалистичных ACL для проверки команд RCPT. Это обсуждается в главе :ref:`7 <ch07_00>`.

.. _ch40_01:

Тестирование ACL
----------------

Параметр командной строки **-bh** - предоставляет способ тестирования вашей конфигурации ACL локально, путём запуска поддельной сессии SMTP, с которой вы взаимодействуете. Хост *relay-test.mail-abuse.org* предоставляет сервис для проверки вашей релейной конфигурации (для получения дополнительных деталей, смотрите раздел :ref:`40.49 <ch40_49>`).


.. _ch40_02:

Определение, когда используются ACL
-----------------------------------

Для использования ACL, вы должны назвать их в одном из соответствующих параметров, в главной части конфигурации. Эти параметры:


==================  ==============
acl_not_smtp        ACL для не-SMTP сообщений 
acl_not_smtp_mime   ACL для MIME частей не-SMTP сообщений 
acl_not_smtp_start  ACL в начале не-SMTP сообщения 
acl_smtp_auth       ACL для AUTH 
acl_smtp_connect    ACL для начала SMTP соединения 
acl_smtp_data       ACL после завершения DATA 
acl_smtp_etrn       ACL для ETRN 
acl_smtp_expn       ACL для EXPN 
acl_smtp_helo       ACL для HELO или EHLO 
acl_smtp_mail       ACL для MAIL 
acl_smtp_mailauth   ACL для параметра AUTH команды MAIL 
acl_smtp_mime       ACL для проверки контента MIME-частей 
acl_smtp_notquit    ACL для не-QUIT завершений 
acl_smtp_predata    ACL в начале команды DATA 
acl_smtp_quit       ACL для QUIT 
acl_smtp_rcpt       ACL для RCPT 
acl_smtp_starttls   ACL для STARTTLS 
acl_smtp_vrfy       ACL для VRFY
==================  ==============

Например, если вы устанавливаете

::

    acl_smtp_rcpt = small_acl

то небольшой ACL, определённый выше, используется каждый раз когда Exim получает команду RCPT в диалоге SMTP. Большинство тестов политик для входящих сообщений может быть сделано по прибытии команды RCPT. Отклонение RCPT должно вызвать ошибку адреса получателя содержащегося в команде RCPT, тогда как отклонение в другой момент времени может вызвать дальнейшие попытки MTA доставить сообщение. Поэтому, рекомендуется, чтобы вы делали как можно больше тестов во время RCPT.

.. _ch40_03:

Не-SMTP ACL'ы
-------------

Не-SMTP ACL'ы применяются ко всем входящим неинтерактивным входящим сообщениям, т.е. к пакетному SMTP он применяется также как и к не-SMTP сообщениям. (Пакетный SMTP - ненастоящий SMTP) Многие условия ACL (например, проверки хостов, и проверки состояния SMTP-соединения - типа шифрования и аутентификации) неуместны и запрещены в этих ACL. Однако, отправитель и получатели известны, таким образом, могут быть использованы условия **senders** и **sender_domains**, и переменные $sender_address и $recipients. Переменные типа $authenticated_sender также доступны. Вы можете определить строки добавления заголовков в любой из этих ACL.

ACL **acl_not_smtp_start** запускается в начале приёма не-SMTP сообщения, до прочтения сообщения. (это аналогично ACL **acl_smtp_predata** для ввода SMTP) В случае пакетного ввода SMTP, она запускается после прочтения команды DATA. Результат этой ACL игнорируется; он не может быть использован для отклонения сообщения. Если вам это действительно необходимо, вы можете в ней установить значение в переменной ACL, и отклонить сообщения основываясь на нём в ACL **acl_not_smtp**. Однако, эта ACL может быть использована для установки управления, и, в частности, она может использоваться для::

    control = suppress_local_fixups

Это не может быть использовано в других не-SMTP ACL, поскольку время когда они работают - слишком поздно.

ACL **acl_not_smtp_mime** доступна лишь когда Exim собран с расширением сканирования содержания. Для деталей смотрите главу :ref:`41 <ch41_00>`.

ACL **acl_not_smtp_mime** работает лишь до функции *local_scan()*. Любые виды отклонения сообщений рассматриваются как постоянные, поскольку нет способа послать код временной ошибки для этих видов сообщений.

.. _ch40_04:

ACL подключения SMTP
--------------------

Проверка ACL заданная путём **acl_smtp_connect** происходит в начале сессии SMTP, после теста заданного **host_reject_connection** (который, теперь, является аномалией) и любых тестов TCP Wrappers (если сконфигурированны). Если соединение принимается условием **accept** имеющим модификатор **message**, содержимое **message** переопределяет баннер, заданный в параметре **smtp_banner**.

.. _ch40_05:

EHLO/HELO ACL
-------------

ACL заданная **acl_smtp_connect** происходит когда клиент выдаёт команду EHLO или HELO, после тестов определённых путём **helo_accept_junk_hosts**, **helo_allow_chars**, **helo_verify_hosts** и **helo_try_verify_hosts**. Отметьте, что клиент может выдать более одной команды EHLO или HELO в сессии SMTP, и действительно - требуется выдать новую EHLO или HELO после успешного установления шифрования, сопровождаемого командой STARTTLS.

Если команда принимается путём условия **accept** имеющим модификатор **message**, сообщение не может содержать более одной строки (оно будет усечено по первому символу новой строки и в лог будет записана паника). Такое сообщение не может повлиять на параметры HELO которые перечислены на второй и последующей строках ответа HELO.

.. _ch40_06:

ACL'ы DATA
----------

Две ACL ассоциированны с командой DATA, поскольку это - двухэтапная команда, с двумя ответами посылаемыми клиенту. Когда получена команда DATA, обрабатывается ACL заданная путём **acl_smtp_predata**. Это даёт вам контроль после всех команд RCPT, но до получения самого сообщения. Этим даётся возможность дать отрицательный ответ на команду DATA до того, как переданы даные. Строки заголовков добавляемые путём MAIL или RCPT ACL невидимы в это время, но любые, которые тут заданы, видимы при работе ACL **acl_smtp_data**.

Вы не можете проверить содержимое сообщения, например, для проверки адресов в заголовках во время RCPT, или когда получена команда DATA. Такие тесты должны быть в ACL которая работает после получения сообщения, до посылки финального ответа на DATA.

Для обоих этих ACL, невозможно отклонить индивидуальных получателей. Ответ о ошибке отклоняет всё сообщение. К сожалению, известны MTA, которые некорректно обрабатывают жёсткий (5xx) ответ на команду DATA (до или после данных) - они пытаются оставить сообщение в своей очереди, и пробуют доставить его позже, но - это их проблема, хотя они впустую тратят ваши ресурсы.


.. _ch40_07:

The SMTP DKIM ACL
-----------------

The acl_smtp_dkim ACL is available only when Exim is compiled with DKIM support enabled (which is the default). 

The ACL test specified by acl_smtp_dkim happens after a message has been received, and is executed for each DKIM signature found in a message. If not otherwise specified, the default action is to accept. 

For details on the operation of DKIM, see chapter :ref:`54 <ch54_00>`.

.. _ch40_08:

SMTP ACL MIME
-------------

Параметр **acl_smtp_mime** доступна лишь когда Exim собран с расширением сканирования содержания. Для деталей, обратитесь к главе :ref:`41 <ch41_00>`.


.. _ch40_09:

ACL QUIT
--------

ACL для SMTP-команды QUIT, является аномальной, результат ACL не затрагивает код ответа на QUIT, который всегда 221. Таким образом, фактически, ACL не управляет каким-либо доступом. Поэтому, разрешены лишь имена команд **accept** и **warn**.

Эта ACL может быть использована для задач типа специального записи в лог конца SMTP-сессии. Например, вы можете использовать переменные ACL в другом ACL для подсчёта числа сообщений, получателей и т.п., и записывать в лог общее время QUIT используя один или более модификаторов **logwrite** в команде **warn**.

.. warning:: Для этого могут использоваться лишь переменные $acl_cx, поскольку переменные $acl_mx сбрасываются после каждого входящего сообщения.

Вам не нужно ставить в конце **accept**, но если вы так поступаете, вы можете использовать модификатор **message**, для задания собственного текста, который посылается как часть 221 ответа на QUIT.

Эта ACL запускается лишь для “нормального” QUIT. Для определённых случаев катастрофических ошибок (например, ошибки открытия лог-файла, или когда Exim падает в результате катастрофической ошибки), все SMTP команды от клиента получают ответ о временной ошибке, пока не будет передана команда QUIT, или соединение не закроется. В этих специальных случаях, ACL QUIT не запускается.

.. _ch40_10:

ACL не-QUIT
-----------

ACL не-QUIT определяется с помощью **acl_smtp_notquit**, она запускается, в большинстве случаев, когда SMTP сессия заканчивается без посылки QUIT. Однако, когда его самого Exim'a проблемы, типа - он не может записать в свои лог-файлы, эта ACL не запускается, поскольку она может попробовать начать что-то делать (например, записать в лог-файл), что лишь усугубит ситуацию.

Как и ACL QUIT, эта ACL предоставлена для возможности персонализации записи в лог или сбора статистики, и её результат игнорируется. Модификатор **delay** запрещён для этой ACL, разрешены лишь условия **accept** и **warn**.

При работе не-QUIT ACL, переменная $smtp_notquit_reason устанавливается в строку, указывающую причину завершения SMTP соединения. Возможные значения таковы:

=====================  =================
acl-drop               другая ACL выдаваемая командой drop 
bad-commands           слишком много неизвестных непочтовых команд 
command-timeout        таймаут при чтении команд SMTP 
connection-lost        SMTP соединение было потеряно 
data-timeout           таймаут при чтении данных сообщения 
local-scan-error       ошибка функции *local_scan()* 
local-scan-timeout     таймаут функции *local_scan()*
signal-exit            SIGTERM или SIGINT 
synchronization-error  ошибка синхронизации SMTP 
tls-failed             ошибка запуска TLS 
=====================  =================

В большинстве случаев, когда SMTP соединение закрывается без передачи команды QUIT, Exim посылает ответ SMTP до реального закрытия соединения. В случае исключения - acl-drop, сообщение по умолчанию может быть переопределено при помощи модификатора **message** в ACL not-QUIT. В случае условия **drop** в иной ACL, используется сообщение из неё.


.. _ch40_11:

Нахождение ACL для использования
--------------------------------

Значение параметра **acl_smtp_xxx** раскрывается перед использованием, таким образом, вы можете использовать различные ACL для разных ситуаций. Например::

    acl_smtp_rcpt = ${if ={25}{$interface_port} \
                     {acl_check_rcpt} {acl_check_rcpt_submit} }

В конфигурационном файле по-умолчанию есть примеры настроек для предоставления сервиса сообщений :rfc:`4409` на порту 587 и нестандартного smtps сервиса на порту 465. Вы можете использовать раскрытие строк подобное этому для выбора ACL для MUA на этих портах, более соответствующего ситуации нежели ACL по-умолчанию на порту 25.

Результирующая строка не должна быть именем ACL в конфигурационном файле; есть другие возможности. Раскрыв строку, Exim ищет ACL в следующим образом:

* Если строка начинается со слэша, Exim использует её как имя файла, и читает его содержимое как ACL. Строки обрабатываются таким же образом, как строки в конфигурационном файле Exim'a. В частности, поддерживается продолжение строк, пустые строки игнорируются, как и строки, чей первый символ, не являющийся пробелом - “#”. Если файл не существует, или не может быть прочитан, происходит ошибка (типично - вызывается временная ошибка любой вызываемой для запуска ACL). Например:

  ::
  
      acl_smtp_data = /etc/acls/\
        ${lookup{$sender_host_address}lsearch\
         {/etc/acllist}{$value}{default}}

  В примере ищется используемый файл ACL на основе IP-адреса хоста, в случае неудачи поиска, используется значение по умолчанию. Если ACL успешно прочитана из файла, она сохраняется в памяти при работе процесса Exim'a, таким образом, она может быть повторно использована, без необходимости перечитывать файл.
  
* Если строка не начинается со слэша, и не содержит каких-либо пробелов, Exim ищет секцию ACL в конфигурации ACL чьё имя совпадает со строкой.

* Если имя ACL не найдено, или строка содержит пробелы, Exim обрабатывает строку как ACL. Это может сэкономить ввод [#]_ в случаях, когда вы хотите сделать что-то типа этого:
  
  ::
  
      acl_smtp_vrfy = accept

  для разрешения свободного использования команды VRFY. Такая строка может содержать символы новой строки; она обрабатывается таким же способом, как и ACL читаемая из файла.

.. _ch40_12:

Коды возврата ACL
-----------------

Исключая ACL QUIT, которая не затрагивает код возврата SMTP (смотрите выше, раздел :ref:`40.8 <ch40_08>`), результат работы ACL - или **accept** или **deny**, или, если проверка не может быть завершена (например, упала БД) - **defer**. Эти результаты вызывают использование кодов ответа 2xx, 5xx, и 4xx в диалоге SMTP, соответственно. Четвёртое возвращаемое значение, **error**, происходит при ошибках, типа неправильного синтаксиса в ACL. Она также вызывает 4xx код возврата.

Для не-SMTP ACL, **defer** и **error** - рассматриваются также как и **deny**, поскольку не существует механизма для передачи временных ошибок отправителям не-SMTP сообщений.

ACL, которые имеют отношение к приёму сообщений, также могут вернуть **discard**. Это имеет тот же самый эффект что и **accept**, но, вызывает отбрасывание всего сообщения, или адреса отдельного отправителя. Другими словами - это, средство для организации чёрной дыры [#]_. Используйте это с осторожностью.

Если ACL для MAIL возвращает **discard**, и все получатели отбрасываются, и для последующих команд RCPT не запускается никаких ACL. Эффект **discard** в ACL RCPT - отбрасывание лишь одного адреса получателя. Если не осталось получателей сообщения, когда получены данные сообщения, ACL DATA не запускается. Если “discard” возвращается из DATA, или не-SMTP ACL, - отбрасываются все получатели. Не разрешается возвращать **discard** для ACL **acl_smtp_predata**.

Функция *local_scan()* запускается всегда, даже если не осталось получателей; она может создать новых получателей.

.. _ch40_13:

Не заданные параметры ACL
-------------------------

Действия по умолчанию, когда не задана любой из параметров **acl_xxx** - не одинаковы для всех.

.. note:: Эти умолчания применяются лишь когда соответствующая ACL вообще не определена. Для любых определённых ACL, действие по умолчанию, когда контроль достигает конца утверждения ACL - **deny**.

Для **acl_smtp_quit** и **acl_not_smtp_start** нет значения по умолчанию, поскольку эти две ACL используются только для их собственных эффектов. Они не могут использоваться для приёма или отклонения чего бы то ни было.

Для **acl_not_smtp**, **acl_smtp_auth**, **acl_smtp_connect**, **acl_smtp_data**, **acl_smtp_helo**, **acl_smtp_mail**, **acl_smtp_mailauth**, **acl_smtp_mime**, **acl_smtp_predata** и **acl_smtp_starttls**, действие при не заданной ACL - **accept**.

Для других (**acl_smtp_etrn**, **acl_smtp_expn**, **acl_smtp_rcpt** и **acl_smtp_vrfy**), действие, когда ACL не задана - **deny**. Это означает, что **acl_smtp_rcpt** должна быть определена, для получения любых сообщений через SMTP-соединение. Для примера, смотрите ACL в конфигурационном файле по умолчанию.

.. _ch40_14:

Данные для ACL сообщений
------------------------

Когда работают MAIL или RCPT ACL, или любые из DATA ACL, установлены переменные, которые содержат информацию о хосте и отправителе сообщения (например, $sender_host_address и $sender_address), и могут использоваться в утверждения ACL. В случае RCPT (но не MAIL или DATA), $domain и $local_part установлены из аргументов адреса. Полная команда SMTP доступна в $smtp_command.

Когда работает ACL для параметра AUTH команды MAIL, переменные, которые содержат информацию о хосте - установлены, но $sender_address ещё не установлена. Раздел :ref:`33.2 <ch33_02>` содержит обсуждение этого параметра и как его использовать.

Переменная $message_size установлена в значение параметра SIZE, команды MAIL, во время MAIL, RCPT и до данных, или в “-1”, если параметр не был задан. Значение обновляется до истинного размера сообщения во время работы финальной ACL DATA (после получения сообщения).

Переменная $rcpt_count увеличивается на единицу для каждой полученной команды RCPT. Переменная $recipients_count увеличивается на единицу для каждой принятой команды RCPT, таким образом, когда обрабатывается RCPT ACL, она содержит число предыдущих принятых получателей. Во время DATA (для обоих DATA ACL), $rcpt_count содержит общее число команд RCPT, и $recipients_count содержит общее число принятых получателей. [#]_ 

.. _ch40_15:

Данные для ACL не-сообщений
---------------------------

Когда ACL работает для AUTH, EHLO, ETRN, EXPN, HELO, STARTTLS, или VRFY, оставшаяся строка SMTP-команды помещается в $smtp_command_argument, и вся команда SMTP доступна в $smtp_command. Эти переменные могут быть протестированы используя условие **condition**. Например, вот - ACL для использования с AUTH, которая настаивает на том, чтобы сессия была или зашифрована, или использовался метод CRAM-MD5. Другими словами, она не разрешает методы аутентификации, которые используют пароль в открытом виде для соединений без шифрования.

::

    acl_check_auth:
      accept encrypted = *
      accept condition = ${if eq{${uc:$smtp_command_argument}}\
                         {CRAM-MD5}}
      deny   message   = TLS encryption or CRAM-MD5 required

(Иной способ применения этих ограничений - переделать аутентификаторы использующие пароли в открытом виде, чтобы о них не оповещалось, когда соединение не шифрованное. Для этого, вы можете использовать общую аутентификационный параметр **server_advertise_condition**.)


.. _ch40_16:

Формат ACL
----------

Индивидуальная ACL содержит множество утверждений. Каждое утверждение начинается с команды, возможно сопровождаемой множеством условий и “модификаторов” (“modifiers”). Модификаторы могут изменять работу команд, задавать сообщения о ошибках и логи, устанавливать переменные, вставлять задержки, и изменять обработку принятых сообщений.

Если выполняются все условия, выполняется команда. Одни и те же условия могут использоваться (с различными аргументами) более одного раза в одном и том же утверждении. Это предоставляет средство задания соединения “and” между условиями. Например::

    deny  dnslists = list1.example
          dnslists = list2.example

Если нет условий, команда всегда выполняется. Exim останавливает оценку условий и модификаторов когда он достигает условия которое ложно. Что происходит потом, зависит от команды (и в одном случае, от специального модификатора). Не все условия имеют смысл в каждой тестируемой точке. Например, вы не можете проверить адрес отправителя в ACL, которая запускается для команды VRFY.


.. _ch40_17:

Команды ACL
-----------

Команды ACL таковы:

* **accept**: Если все условия удовлетворяются, ACL возвращает **accept**. Если любое из условий не выполняется, происходящее зависит от того, есть ли среди условий **endpass** (синтаксис смотрите ниже). Если ложно условие до **endpass**, управление передаётся следующему утверждению ACL; если оно после **endpass**, ACL возвращает **deny**. Рассмотрим это утверждение, используемое для проверки команды RCPT:
  ::
  
      accept domains = +local_domains
      endpass
      verify = recipient

  Если домен получателя не совпадает с условием **domains**, управление передаётся следующему утверждению. Если оно совпадает, проверяется получатель, и команда принимается в случае успешной проверки. Однако, если проверка неудачна, ACL приводит к **deny**, поскольку неудачное условие после **endpass**.

  Команда **endpass** ввела многих людей в заблуждение, поэтому, в настоящее время, её использование не рекомендуется. Всегда возможно переписать ACL без использования **endpass**, и она больше не используется в конфигурационном файле по умолчанию.

  Если в в утверждении **accept** появляется модификатор **message**, его действие зависит от наличия **endpass**. При остутствии **endpass** (когда **accept** принимает или передаёт управление следующему условию) **message** может использоваться для различных сообщений посылаемых когда принимается SMTP команда. Например, в RCPT ACL у вас може быть:
  
  ::
  
      accept  <some conditions>
      message = OK, I will allow you through today

  Вы можете определить код ответа SMTP, необязательно сопровождаемый "расширенным кодом ответа" в начале сообщения, но, первая цифра должна быть такой же какая была бы послана по умолчанию, для **accept** это цифра “2”.

  Если в утверждении **accept** есть **endpass**, **message** определяет сообщение о ошибке используемое при отказе в доступе. Это поведение сохранено для обратной совместимости, но текущей хорошей практикой является избежание использования **endpass**.

* **defer**: Если все условия истинны, ACL возвращает **defer**, который вызывает в SMTP-сессии выдачу ответа 4xx. Для не-SMTP ACL, **defer** - то же самое, что и **deny**, поскольку в этом случае нет способа дать временную ошибку. Для команды RCPT, **defer** - почти также использует маршрутизатор **redirect** и :defer: при проверке, но команда **defer** может использоваться в любом ACL, и для получателя это может быть более простым подходом.

* **deny**: Если все условия удовлетворяются, ACL возвращает **deny**. Если любое из условий не выполняется, управление передаётся следующему утверждению ACL. Например:
  
  ::
  
      deny dnslists = blackholes.mail-abuse.org

  отклоняет команды от хостов, которые в чёрных списках DNS (блэк-листах).
  
* **discard**: Эта команда ведёт себя также как и **accept**, исключая, что она возвращает из ACL **discard** вместо **accept**. Это разрешается только для ACL которые имеют отношение к получению сообщений, и они вызывают отказ от получателя. Когда все условия истинны, отправляющая сторона передаёт ответ "success". Однако, отказ вынуждает отказаться от получателей. Если это используется в ACL для RCPT, будет произведён отказ лишь от одного получателя; при использовании в MAIL, DATA или в не-SMTP ACL будет отказ от всех получателей сообщения. Получатели которым отказано до DATA не фигурируют в логах, когда установлен селектор **received_recipients**

  Если модификатор **log_message** установлен при работе **discard**, его содержимое добаляется к строке, автоматически записываемой в лог. Оперирование **message** происходит точно также как и для **accept**.

* **drop**: Эта команда ведёт себя также как и **deny**, исключая, что соединения SMTP принудительно закрываются после отсылки 5xx сообщения об ошибке. Например:

  ::
  
      drop   message   = I don't take more than 20 RCPTs
             condition = ${if > {$rcpt_count}{20}}

  Нет никаких отличий между **deny** и **drop** во время выполнения ACL для соединения. Соединения всегда разрываются после посыла ответа 550.

* **require**: Если выполняются все условия, управление передаётся следующему утверждению ACL. Если любое из условий не выполняется, ACL возвращает **deny**. Например, при проверке команды RCPT    
  
  ::
  
      require message = Sender did not verify
              verify  = sender

  управление передаётся следующему утверждению только, если отправитель сообщения может быть проверен. Иначе, оно отклонит команду.

* **warn**: Если все условия выполняются, строка заданная в модификаторе **log_message** пишется в главный лог Exim'a. Управление всегда передаётся следующему утверждению ACL. Если любое условие ложно, в лог ничего не пишется. Если одинаковые строки логов несколько раз фигурируют в одном сообщение, в лог пишется лишь одна копия. Если вы хотите чтобы дубликаты были принудительно записаны, используйте модификатор **logwrite**.

  Если отсутствует **log_message**, условие **warn** просто проверяет свои условия и слушается любых "немедленных" модификаторов (типа **control**, **set**, **logwrite**, и **add_header**) появляющихся до первого неудачного условия. Дополнительная информация о добавлении строк заголовков дана в разделе :ref:`40.22 <ch40_22>`.

  Если любое условие в утверждении **warn** не может быть завершено (т.е. своего рода отсрочка), строка заданная в **log_message** не записывается. Это не включает случай принудительной ложности условия поиска, который считается успешно завершённым. После задержки, дальнейшие условия и модификаторы из утверждения **warn** не обрабатываются. Инцидент записывается в лог, но ACL продолжает обрабатываться, со следующего утверждения.

  Когда одно из условий **warn** проверка адреса, завершившаяся неудачно, текст сообщения о неудаче проверки находится в $acl_verify_message. Если вы хотите его записать в лог, вы должны указать это явно. Например:

  ::
  
      warn   !verify = sender
             log_message = sender verify failed: $acl_verify_message


В конце каждой ACL присутствует неявное, безоговорочное, **deny**.

Как вы видели из примеров выше, условия и модификаторы пишутся в одну линию, на первом месте, в той же строке - команда, и последующие на дальнейших строках. Если у вас очень длинное условие, вы можете продолжить его на нескольких строках, путём обычного механизма обратного слэша. Обычно, условия выравниваются вертикально.

.. _ch40_18:

Переменные ACL
--------------

Есть некоторые специальные переменные, которые могут быть установлены в течение обработки ACL. Они могут использоваться для передачи информации между различными ACL'ами, различными вызовами одной и той же ACL в одном и том же SMTP-соединении, и между ACL и маршрутизаторами, транспортами и фильтрами, которые используются для доставки сообщения. Имена этих переменных должны начинаться с $acl_c0 или $acl_m0, сопровождаемые цифрой или подчёркиванием, но, оставшаяся часть имени должна быть любой последовательностью цифробуквенных символов и подчёркиваний, на ваш выбор. Ограничения на число переменных остутствуют. Два набора переменных ведут себя следующим образом:

* Значения, чьи переменные начинаются с “$acl_c” сохраняются в течение SMTP-сессии. Они никогда не сбрасываются. Таким образом, значение которое установлено при получении одного сообщения, остаётся доступным при получении следующего сообщения в том же SMTP-соединении.
* Значения, чьи переменные начинаются с “$acl_m” сохраняются лишь когда сообщение получается. После этого они сбрасываются. Также, они сбрасываются MAIL, RSET, EHLO, HELO, и после начала сессии TLS.

Когда сообщение принято, текущие значения всех переменных ACL сохраняются с сообщением, и впоследствии становятся доступными во время доставки. Переменные ACL устанавливаются путём модификатора называемого **set**. Например::

    accept hosts = whatever
           set acl_m4 = some value
           accept authenticated = *
           set acl_c_auth = yes

.. note:: Начальный символ доллара не используется при именовании устанавливаемой переменной. Если вы хотите установить переменную не предпринимая каких-либо действий, вы можете использовать команду **warn** без любых других модификаторов или условий.

Что происходит в случае, если синтаксически верная, но не заданная переменная ACL используется, зависит от настроек параметра **stict_acl_vars**. Если её значение “false” (по умолчанию), используется пуская строка; если “true”, выводится ошибка.

Версия Exim до 4.64 поддерживает ограниченный набор нумерованных переменных, но их имена совместимы [#]_, т.ч. проблем с обновлением быть не должно.

.. _ch40_19:

Обработка условий и модификаторов
---------------------------------

Восклицательный знак предшествующий условию - отрицает его результат. Например::

    deny   domains = *.dom.example
           !verify  = recipient

заставляет ACL вернуть **deny**, если домен отправителя заканчивается на *dom.example* и адрес получателя  не может быть проверен. Иногда отрицание может может использоваться на правой стороне условия. Например, эти два утверждения эквивалентны::

    deny  hosts = !192.168.3.4
    deny !hosts =  192.168.3.4

Однако, для многих условий (**verify** был хорошим примером), допустимо лишь левостороннее отрицание всего условия.

Аргументы условия и модификаторы раскрываются. Принудительный отказ раскрытия вызывает игнорирование условия, т.е. оно ведёт себя как будто условие истинно. Рассмотрите эти два утверждения::

    accept  senders = ${lookup{$host_name}lsearch\
                      {/some/file}{$value}fail}
    accept  senders = ${lookup{$host_name}lsearch\
                      {/some/file}{$value}{}}

Каждое пытается искать список приемлемых отправителей. Если поиск успешен, возвращённый список просматривается, но если поиск неудачен, поведение различается в этих двух случаях. В первом случае, **fail** вызывает игнорирование условия, не разрешая никаких дальнейших условий. Поэтому, команда **accept** успешна. Однако, второе утверждение, создает пустой список, когда поиск неудачен. Никакой отправитель не может совпасть с пустым списком, следовательно - условие ложно, и поэтому **accept** также неудачен.

Модификаторы ACL кажутся смешанными с условиями в утверждениях ACL. Некоторые из них определяют действия, которые берутся как условия для проверки утверждений; другие определяют текст для сообщений, который используется при отказе в доступе, или при создании предупреждения. Модификатор **control** затрагивает способ обработки входящих сообщений.

Позиционирование модификаторов в утверждении ACL - важно, поскольку обработка команды прекращается, как только известен её результат. В силу вступят лишь те модификаторы, которые успели встретится. Например, рассмотрите использование модификатора **message**::

    require message = Can't verify sender
            verify  = sender
            message = Can't verify recipient
            verify  = recipient
            message = This message cannot be used

Если проверка отправителя неудачна, Exim знает, что результат утверждения - **deny**, следовательно, он не движется дальше. Был просмотрен первый модификатор, таким образом, его текст используется как сообщение о ошибке. Если проверка отправителя успешна, но проверка получателя - неудачна, используется второе сообщение. Если проверка получателя успешна, “текущим” становиться третье сообщение, но оно никогда не используется, поскольку больше нет условий способных вызвать отказ.

Для команды **deny**, с другой стороны, всегда используется последний модификатор **message**, поскольку все условия должны быть истины, для того, чтобы случилось отклонение получателя. Задание более чем одного модификатора **message** не имеет смысла, и сообщение может быть определено даже после всех условий. Например::

    deny   hosts = ...
           !senders = *@my.domain.example
           message = Invalid sender from client host

Результат **deny** не происходит, пока не будет достигнут конец утверждения, по достижении которого, Exim установит сообщение.

.. _ch40_20:

Модификаторы ACL
----------------

Модификаторы ACL таковы:

  **add_header = <text>**
    Этот модификатор задаёт одну или более строк заголовков которые должны быть добавлены во входящее сообщение, предполагая, разумеется, что сообщение в конечном счёте принято. Для деталей, смотрите раздел :ref:`40.22 <ch40_22>`.

  **continue = <text>**
    Этот модификатор сам по себе ничего не делает, и обработка ACL всегда переходит к следующему условию или модификатору. Значение **continue** - побочный эффект раскрытия его аргументов. Обычно, оно используется для обновления базы данных. Это очень простое условие, и постарайтесь избежать уродливых строк типа:

    ::

        condition = ${if eq{0}{<some expansion>}{true}{true}}

    Вместо этого, всё что вам необходимо:
    
    ::
    
        continue = <some expansion>


  **control = <text>**
    Этот модификатор затрагивает последующую обработку SMTP-соединения, или входящего сообщения, которое принято. Эффект первого типа управления длится для всей продолжительности соединения, тогда как эффект второго типа длится лишь пока не получено текущее соединение. Специфические для сообщения средства управления всегда применяются ко всему сообщению, не к индивидуальным получателям, даже если модификатор **control** появляется в RCPT ACL.
  
    Eсть довольно много средств управления которые могут быть применены, они описываются отдельно, в разделе :ref:`40.20 <ch40_20>`. Модификатор **control** может использоваться несколькими различными способами. Например:

      * Он может быть в конце утверждения **accept**:
      
        ::
      
            accept  ...some conditions
                    control = queue_only

        В этом случае, управление применяется когда это условие приводит к **accept**, другими словами, когда все условия верны.

      * Он может быть в середине утверждения **accept**:    
        
        ::
        
            accept  ...some conditions...
                    control = queue_only
                    ...some more conditions...

        Если первый набор условий истина, управление применяется, даже если утверждение не принимается поскольку одна из вторых установок условия - ложна. В этом случае, некоторое последующее утверждение должно уступить **accept** для релевантного управления.

      * Он может использоваться с **warn**, для применения управления, оставляя решение о приёме или отказе следующей команде. Например:
        
        ::
        
            warn    ...some conditions...
                    control = freeze
                    accept  ...

        Этот пример **warn** не содержит **message**, **log_message** или **logwrite**, таким образом, он ничего не добавляет к сообщению и не пишет логов.

      * Если вы хотите безоговорочно применить **control**, вы можете использовать его с командой **require**. Например:
        
        ::
        
            require  control = no_multiline_responses


  **delay = <time>**
    Этот модификатор может находиться в любой ACL. Он заставляет Exim ждать интервал времени до процедуры. Однако, при тестировании Exim'a с использованием параметра командной строки **-bh**, задержка не применяется (вместо этого выводится соответствующее сообщение). Временной интервал даётся в обычной нотации Exim'a, а задержка происходит как только обработан модификатор. В сессии SMTP, задержанный вывод сбрасывается до осуществления задержки.

    Как и **control**, **delay** может использоваться с **accept** или **deny**, например:

    ::
    
        deny    ...some conditions...
                delay = 30s

    Задержка происходит если все условия истинны, до возвращения **deny**. Сравните с:
    
    ::
    
        deny    delay = 30s
                ...some conditions...

    которое ждёт 30s до обработки условия. Модификатор **delay** также может быть использован с **warn** и вместе с **control**:
    
    ::
    
        warn    ...some conditions...
                delay = 2m
                control = freeze
        accept  ...

    Если **delay** встречается при использовании расширения SMTP PIPELINING, ответы на некоторые команды не буферизуются и посылаются в одном пакете (как обычно оно и происходит), поскольку весь вывод сбрасывается до осуществления задержки. Эта оптимизация - отключена, таким образом, ряд небольших задержек не выходит для клиента одной большой суммарной задержкой, которая могла бы привести к нежелательным таймаутам. Однако, вы можете отключить сброс вывода для задержки используя модификатор **control** для установки **no_delay_flush**.


  **endpass**
    Этот модификатор, у которого нет аргументов, распознаётся лишь в утверждениях **accept** и **discard**. Он отмечает границу между условием чья неудача вызывает передачу управления следующему утверждению, и условием, чья неудача заставляет ACL вернуть **deny**. Это ввело в заблуждение некоторых людей, таким образом, хорошей практикой является не использовать **endpass**. Для дополнительных деталей, смотрите описание **accept**, выше.


  **log_message = <text>**
    Этот модификатор устанавливает сообщение, которое используется как часть сообщения лога, если ACL запрещает доступ, или утверждение **warn** истинно. Например:

    ::
    
        require log_message = wrong cipher suite $tls_cipher
                encrypted   = DES-CBC3-SHA

    Также, **log_message** используется когда получатели отвергаются через **discard**. Например:

    ::

        discard <some conditions>
        log_message = Discarded $local_part@$domain because...

    Когда в доступе отказано, **log_message** добавляется к любому основному сообщению о ошибке, которое может существовать, поскольку условие - неудачно. Например, когда проверяется адрес получателя, перенаправление :fail: могло уже установить сообщение.

    Сообщение может быть задано до условия к которому оно применяется, поскольку раскрытие не происходит, пока Exim не решает, что в доступе надо отказать. Это означает, что любые переменные, которые установлены путём условия, доступны для включения в сообщение. Например, переменные $dnslist_<xxx>, установлены после того, как был успешный поиск в чёрных списках DNS. Если раскрытие **log_message** - неудачно, или если результат - пустая строка, модификатор игнорируется.

    Если вы хотите использовать утверждение **warn** для записи в лог результата проверки адреса, вы можете использовать $acl_verify_message для включения сообщения о ошибке проверки.

    Если **log_message** используется с утверждением **warn**, в начало записываемого в лог сообщения добавляется “Warning:”. Если тоже самое предупреждающее сообщение запрашивается более одного раза при получении одного почтового сообщения, лишь одна копия записывается в лог. Если вы хотите записывать в лог все копии, используйте **logwrite** вместо **log_message**. При отсутствии обоих, **log_message** и **message**, ничего не записывается в лог для успешного утверждения **warn**.

    Если отсутствует **log_message** и нет основного сообщения о ошибке (например, из неудачи проверки адреса), но присутствует **message**, текст **message** используется для записи в лог отказа. Однако, если какой-либо текст для записи в лог содержит символы новой строки, лишь первая строка записывается в лог. При отсутствии обоих, **log_message** и **message**, для записи в лог отклонения используется встроенное сообщение по умолчанию.


  **log_reject_target = <log name list>**
    Этот модификатор делает возможным задать какой лог используется для сообщения о отклонении ACL. Его аргументы - список слов разделённый двоеточиями, которые могут быть main”, “reject”, or “panic”. По умолчанию - “main:reject”. Список может быть пустым, в этом случае отклонение не записывается в никакой лог. Например, этот фрагмент ACL не записывает информацию в лог когда отказано в доступе:
    
    ::
    
        deny <some conditions>
             log_reject_target =

    Этот модификатор может использоваться в SMTP и не-SMTP ACL'ах. Он применяется и к постоянным и к временным отказам. Это действие - последнее в текущей ACL.


  **logwrite = <text>**
    Этот модификатор пишет сообщение в лог-файл, как только с ним сталкиваются при обработке ACL. (Сравните с **log_message**, который, исключая случай **warn** и **discard**, используется лишь если утверждение ACL отказывает в доступе.) Модификатор **logwrite** может использоваться для записи в лог особых инцидентов в ACL. Например:
    
    ::
    
        accept <some special conditions>
               control  = freeze
               logwrite = froze message because ...

    По умолчанию, сообщение пишется в главный лог. Однако, оно может начинаться с двоеточия, сопровождаемого списком имён логов, разделённых двоеточиями, и, затем, иным двоеточием, точно определяющим, который лог будет записан. Например:
    
    ::
    
        logwrite = :main,reject: text for main and reject logs
        logwrite = :panic: text for panic log only



  **message = <text>**
    Этот модификатор устанавливает текстовую строку, которая раскрывается, и используется как ответное сообщение, если текущее утверждение ACL завершает ACL c ответом **accept**, **deny**, или **defer**. (В случае условий **accept** и **discard** есть некоторые проблемы при использовании **endpass**; для дополнительных деталей смотрите описание **accept**.)

    Раскрытие происходит в то время, когда Exim принимает решение об отказе в доступе, не во время обработки **message**. Если раскрытие неудачно, или создает пустую строку, модификатор игнорируется. Вот пример, когда сообщение должно быть определено первым, поскольку ACL завершается с отказом, если условие **hosts** неудачно:
    
    ::
    
        require  message = Host not recognized
                 hosts = 10.0.0.0/8

    (Как только условие ложно, никакие последующие условия или модификаторы не обрабатываются)

    Для ACL, которые вызываются путём SMTP-команд, сообщение возвращается как часть SMTP ответа об ошибке. Использование **message** с **accept** (или **discard**) - это действует только для SMTP, так как нет возвратного сообщения при приёме не-SMTP сообщения. В случае ACL **connect**, приём с модификатором **message** замещает значение **smtp_banner**. Для ACL EHLO/HELO персональные сообщения о приёме не должны содержать более одной строки (иначе они будут усечены по первому символу новой строки, и в лог записана паника), и это не может действовать на параметры EHLO.

    При использовании SMPT, сообщение может начинаться с замещения кода ответа, состоящего из трёх цифр, возможно сопровождаемых "расширенным кодом ответа", в форме “n.n.n”, каждый код за которым следует пробелом. Например:    
    
    ::
    
        deny  message = 599 1.2.3 Host not welcome
              hosts = 192.168.34.0/24

    Первая цифра предоставленного кода ответа должна быть такой же как посылаемая по умолчанию. Если это не так - происходит паника. Exim использует код 550 при отказе в доступе, но заметьте, для ACL **predata**, по умолчанию, успешный код 354, а не 2xx.

    Несмотря на предыдущий параграф, для QUIT ACL, в отличие от остальных, модификатор **message** не может замещать код ответа 221.

    Текст в модификаторе **message** является буквальным; любые кавычки берутся как опечатки, но, поскольку строка раскрывается, экранирование обратным слэшом так или иначе обрабатывается. Если сообщение содержит символы новой строки, оно увеличивается до многострочного SMTP-ответа.

    Если **message** используется в утверждении которое проверяет адрес, заданное сообщение замещает любое сообщение, которое создано путём процесса проверки. Однако, оригинальное сообщение доступно в переменной $acl_verify_message, таким образом, вы можете включить его в ваше сообщение, если вы этого желаете. В частности, если вы хотите текст из элемента **:fail:** в маршрутизаторе **redirect**, для возвращения обратно как части ответа SMTP, вы не должны использовать модификатор **message**, или использовать $acl_verify_message.

    Для совместимости с предыдущими версиями Exim'a, модификатор **message**, который используется с командой **warn**, ведёт себя подобно модификатору **add_header**, но это применение сейчас устарело. Однако, **message** действует лишь когда все условия истинны, везде где он появляется в команде ACL, тогда как **add_header** действует как только с ним сталкиваются. Если **message** используется с **warn** в ACL которая не имеет отношения к получению сообщения, он не имеет эффекта.


  **message <acl_name> = <value>**
    Этот модификатор помещает значение в одну из переменных ACL (смотрите раздел :ref:`40.17 <ch40_17>`).


.. _ch40_21:

Использование модификатора **control**
--------------------------------------

Модификатор **control** поддерживает следующие установки:

  **control = allow_auth_unadvertised**
    Этот модификатор позволяет клиентскому хосту использовать команду SMTP AUTH, даже когда о ней не оповещалось в ответе на HELO. Кроме того, поскольку есть некоторые очень кривые клиенты, Exim принимает AUTH после HELO (а не EHLO), когда этот контроль установлен. Это должно использоваться лишь если вам это действительно необходимо, и вы должны ограничить его использование теми кривыми клиентами, которые без этого не работают. Например:
    
    ::
    
        warn hosts   = 192.168.34.25
        control = allow_auth_unadvertised

    Обычно, когда сервер Exim'a получает команду AUTH, он проверяет имя аутентификационного механизма который дан в команде на совпадение с механизмом о котором оповещалось. Когда эта установка установлена, проверка на оповещение о механизме обходится. Любые сконфигурированные механизмы могут быть использованы клиентом. Это управление разрешено лишь в соединениях и ACL`ах HELO.


  **control = caseful_local_part**, **control = caselower_local_part**
    Эти два средства управления разрешены лишь в ACL определённых путём **acl_smtp_rcpt** (т.е. в течение обработки RCPT). По умолчанию, содержимое $local_part приводится к нижнему регистру, до обработки ACL. Если задана **caseful_local_part**, любые заглавные буквы в оригинальной локальной части, восстановлены в $local_part для остальной ACL, или пока не столкнётся с управлением установленным в **caselower_local_part**.

    Эти средства управления применяются лишь к текущему получателю. Кроме того, они применяются лишь к обработке локальной части, которая имеет место непосредственно в ACL (например, как ключ в поисках). Если присутствует проверка получателя, регистрозависмая обработка локальной части, в процессе проверки, контролируется конфигурацией маршрутизатора (смотрите параметр маршрутизаторов **caseful_local_part**).

    Это средство могло бы использоваться, например, для добавления спамерских очков к локальной части содержащей бувы верхнего регистра. Например, используя $acl_m4 для накопления спамерских очков:
    
    ::
    
        warn  control = caseful_local_part
                        set acl_m4 = ${eval:\
                                      $acl_m4 + \
                                      ${if match{$local_part}{[A-Z]}{1}{0}}\
                                     }
                        control = caselower_local_part

    Заметьте, что мы возвращаем назад версию в нижнем регистре, предполагая, что это потребуется для последующих тестов.

  **control = debug/<options>**
    This control turns on debug logging, almost as though Exim had been invoked with -d, with the output going to a new logfile, by default called debuglog. The filename can be adjusted with the tag option, which may access any variables already defined. The logging may be adjusted with the opts option, which takes the same values as the -d command-line option. Some examples (which depend on variables that don’t exist in all contexts):

    ::

        control = debug
        control = debug/tag=.$sender_host_address
        control = debug/opts=+expand+acl
        control = debug/tag=.$message_exim_id/opts=+expand

  **control = enforce_sync**, **control = no_enforce_sync**
    Эти средства управления дают возможность селективной SMTP синхронизации. Глобальный параметр **smtp_enforce_sync** задаёт начальное состояние переключателя (оно истинно по умолчанию). Смотрите описание этого параметра в главе :ref:`14 <ch14_00>`, для дополнительной информации о проверке SMTP синхронизации.

    Эффект этих двух средств управления длится до конца SMTP соединения. Они могут появиться в любой ACL, кроме одной для не-SMTP сообщений. Самое верное место их размещения - в ACL заданной путём **acl_smtp_connect**, которая запускается после входящего SMTP соединения, до первой проверки синхронизации. Ожидаемое использование - для отключения проверок синхронизации для плохо себя ведущих хостов, с которыми вам надо работать.


  **control = fakedefer/<message>**
    Это средство управления работает точно также как и **fakereject** (описано  ниже), исключая, что оно вызывает 450 SMTP ответ после получения данных, вместо 550 ответа. При использовании **fakedefer** вы должны учесть, что она вызывает повтор сообщений, при наступлении времени повтора у отправителя. Поэтому, вы не должны использовать **fakedefer**, если сообщение нужно доставить обычным образом.


  **control = fakereject/<message>**
    Это средство управления разрешено лишь для ACL MAIL, RCPT, и DATA, другими словами, лишь когда получается SMTP сообщение. Если Exim принимает сообщение, вместо финального ответа 250, посылается 550 отклонение сообщения. Однако, Exim продолжает нормальную доставку сообщения. Средство управления применяется лишь к текущему сообщению, но не к любым последующим, которые могут быть получены в том же самом SMTP-соединении.

    Текст для 550 ответа берётся из модификатора **control**. Если сообщения не предоставлено, используется следующее:
    
    ::
    
        550-Your message has been rejected but is being
        550-kept for evaluation.
        550-If it was a legitimate message, it may still be
        550 delivered to the target recipient(s).

    Это средство должно использоваться с чрезвычайной осторожностью.

  **control = freeze**
    Это средство управления разрешено лишь для ACL MAIL, RCPT, DATA, и не-SMTP ACL, другими словами, лишь когда получается сообщение. Если сообщение принято, оно помещается очередь Exim'a и замораживается. Средство управления применяется лишь к текущему сообщению, а не к любым последующим, которые могут быть получены в том же самом SMTP соединении.

    Этот модификатор может, возможно сопровождаться “/no_tell”. Если установлена глобальный параметр **freeze_tell**, она игнорируется для текущего сообщения (т.е. никому не сообщается о заморозке), при условии, что все модификаторы “control=freeze” для текущего сообщения имеют параметр ``/no_tell``.

  **control = no_mbox_unspool**
    Это средство управления доступно когда Exim собран с поддержкой расширения контекстного сканирования. Контекстное сканирование может требовать копию текущего сообщения, или частей его, для записи в формате “mbox format” в файл спула, для передачи к сканеру на вирусы или спам. Обычно, такие копии удаляются, когда они более не нужны. Если это средство управления установлено, копии не удаляются. Средство управления применяется лишь к текущему сообщению, а не к любым последующим, которые могут быть получены в том же самом SMTP соединении. Оно предоставляет средство отладки и вряд ли будет полезно в производстве.

  **control = no_delay_flush**
    Обычно, Exim сбрасывает SMTP вывод до осуществления задержки в ACL, для предотвращения неожиданных таймаутов у клиентов при использовании расширения SMTP PIPELINING. Это средство управления, когда оно встречается до модификатора **delay**, отключает сброс вывода.


  **control = no_callout_flush**
    Обычно, Exim сбрасывает SMTP вывод до осуществления задержки в ACL, для предотвращения неожиданных таймаутов у клиентов при использовании расширения SMTP PIPELINING. Это средство управления, когда оно встречается до условия **verify**, отключает сброс вывода.

  **control = no_multiline_responses**
    Это средство управления разрешено для любых ACL, кроме одной для не-SMTP сообщений. Кажется, что существуют кривые клиенты, которые при использовании не могут обрабатывать многострочные SMTP-ответы, несмотря на то, что фактически, :rfc:`821` определил их более 20 лет назад.

    Когда эта установка установлена, подавляются многострочные SMTP ответы, о отклонении, из ACL. Один способ сделать это, состоял бы в том, чтобы сделать эти ответы одной длинной строкой. Однако, :rfc:`2821` определяет максимум - 512 байт на ответ (там сказано - “use multiline responses for more” - ха!), и некоторые из ответов могли бы перекрыть это. Так, это средство, в конечном счёте являющееся лишь подачкой для кривых клиентов, осуществляется путём дву простых вещей:

    Дополнительная информация, которая обычно выводится как часть отклонения вызванного ошибкой проверки отправителя, опускается. Посылается лишь финальная строка (обычно, “sender verification failed”).

    Если модификатор **message** предоставляет многострочный ответ, выводится лишь первая строка.

    Установка переключателя может, разумеется, быть сделанной зависимой от вызывающего хоста. Его эффект длится до конца SMTP подключения.


  **control = no_pipelining**
    Это средство управления выключает оповещение о расширении SMTP PIPELINING в текущей сессии. Чтобы оно было полезным, оно должно появиться до того как Exim посылает свой ответ в команде EHLO. Поэтому, обычно оно появляется в ACL управляемой **acl_smtp_connect** или **acl_smtp_helo**. Также смотрите **pipelining_advertise_hosts**.

  **control = queue_only**
    Это средство управления разрешено лишь для ACL MAIL, RCPT, DATA, и не-SMTP ACL, другими словами, лишь когда получается сообщение. Если сообщение принято, оно помещается очередь Exim'a и остается там для доставки обработчиком очереди. Немедленный процесс доставки не запускается. Другими словами, оно имеет эффект глобального параметра **queue_only**. Однако, средство управления применяется лишь к текущему сообщению, а не к любым последующим, которые могут быть получены в том же самом SMTP соединении.


  **control = submission/<options>**
    Это средство управления разрешено лишь для ACL MAIL, RCPT, и начального DATA ACL (последний - заданный путём **acl_smtp_predata**). Его установка говорит Exim'y, что текущее сообщение передано от локального MUA. В этом случае, Exim работает в “режиме передачи” (“submission mode”), и, при необходимости, применяет определённые исправления к сообщению. Например, он добавляет строку заголовков “Date:”, если её нет. Это средство управления не разрешено в ACL **acl_smtp_data**, поскольку она слишком поздно (сообщение уже создано).

    Глава :ref:`44 <ch44_00>` описывает обработку, которую Exim применяет к сообщениям. Раздел :ref:`44.1 <ch44_01>` охватывает обработку, которая происходит в режиме передачи; доступные для этого средства управления параметры, описаны там. Средство управления применяется лишь для текущего сообщения, а не к любым последующим, которые могут быть получены в том же самом SMTP соединении.

  **control = suppress_local_fixups**
    Это средство управления применяется к локально переданным (не TCP/IP) сообщениям, и это - дополнение к **control = submission**. Оно отменяет исправления, которые обычно применяются к локально переданным сообщениям. Конкретно:

    * Любые заголовки “Sender:” оставляются как есть (в этом отношении, это - динамическая версия **local_sender_retain**).
    * Не добавляются заголовки “Message-ID:”, “From:” и “Date:”.
    * Нет проверки, что “From:” соответствует фактическому отправителю.

    Эта особенность может быть полезной когда принято удалённо порождённое сообщение, передано какой-то сканирующей программе, и затем повторно передано для доставки.


.. _ch40_22:

Кратко о управлении исправлениями сообщений
-------------------------------------------

Все четыре возможные исправления для сообщений могут быть заданы:

* Локально переданное, применяются исправления: по умолчанию.
* Локально переданное, не применяются исправления: использование control = suppress_local_fixups
* Удалённо переданное, не применяются исправления: по умолчанию.
* Удалённо переданное, применяются исправления: control = submission.

.. _ch40_23:

Добавление строк заголовков в ACL'ах
------------------------------------

Модификатор **add_header** может быть использован для добавления одного или более дополнительных строк заголовков во входящее сообщение, как в этом примере::

    warn dnslists = sbl.spamhaus.org : \
                    dialup.mail-abuse.org
         add_header = X-blacklisted-at: $dnslist_domain

Модификатор **add_header** разрешается в MAIL, RCPT, PREDATA, DATA, MIME, и не-SMTP ACL (лругими словами, тех, которые имеют отношение к получению сообщения). Сообщение должно быть, в конечном счёте, принято, чтобы **add_header** имел какой-то существенный эффект. Вы можете использовать **add_header** с любыми ACL-командами, включая **deny** (хотя, потенциально, это полезно лишь в ACL RCPT).

Если данные для модификатора **add_header** содержат одну или более символов новой строки, которые  не сопровождаются пустым местом или табами, предполагается, что это - несколько строк заголовков. Каждый из них проверена на правильность синтаксиса; в начале каждой строки не являющейся правильной строкой заголовка добавляется “X-ACL-Warn:”.

Добавленные строки накапливаются в течение ACL MAIL, RCPT и преданных. Они добавляются в сообщение до обработки ACL DATA и MIME. Однако, если идентичные строки запрошены более одного раза, фактически, в сообщение добавляется лишь одна копия. Последующие строки заголовков мгут быть накоплены в течение ACL DATA и MIME, после которых они добавляются в сообщение, с таким же подавлением дубликатов. Таким образом, возможно добавить две идентичные строки в SMTP сообщение, но лишь если одна добавлена до DATA и одна - после. В случае не-SMTP сообщений, новые заголовки аккумулируются в течение не-SMTP ACL, и добавляются в сообщение после работы всех ACL. Если сообщение отклоняется после DATA, или путём не-SMTP ACL, все добавленные строки заголовков включаются в запись производимую в лог отклонённых.

Строки заголовков невидимы в раскрытии строк пока они не добавлены в сообщение. Из этого следует, что строки заголовков заданные в ACL MAIL, RCPT и преданных не видимы до запуска DATA ACL и MIME ACL. Таким же образом, строки заголовков которые добавлены путём DATA или MIME ACL не видимы в  этих ACL. Bp-pf этого ограничения, вы не можете использовать строки заголовков как способ передачи данных между (например) ACL MAIL и ACL RCPT. Если вы хотите это сделать, вы можете использовать переменные ACL, оно описано в разделе :ref:`40.17 <ch40_17>`.

Модификатор **add_header** действует немедленно, как тока с ним столкнулись в процессе обработки ACL. Заметьте различие между этими двумя случаями::

    accept add_header = ADDED: some text
           <some condition>

    accept <some condition>
           add_header = ADDED: some text

В первом случае, строки заголовков всегда добавляются, вне зависимости от того, истинно условие или нет. Во втором случае, строки заголовков добавляется лишь если условие истинно. Несколько **add_header** могут быть в одном утверждении ACL. Все встречающиеся до неудачного условия - выполняются.

Для совместимости с предыдущими версиями Exim'a, модификатор **message** для команды **warn** действует таким же образом как и **add_header**, исключая что он вступает в силу лишь если все условия истинны, даже если он появляется до некоторых из них. Кроме того, выполняется лишь последнее появление **message**. Это использование **message**, теперь осуждается. Если в команде **warn** представлены оба - **add_header** и **message**, оба обработаны согласно их спецификациям.

По умолчанию, новая строка заголовка добавляется в конце существующих строк. Однако, вы можете задать что любая особенная строка заголовка должна быть добавлена в начале (до всех строк “Received:”), немедленно после первого блока строк “Received:”, или немедленно до любой строки, которая не “Received:” или “Resent-something:”.

Это сделано путём определения “:at_start:”, “:after_received:”, или “:at_start_rfc:” (или, для завершения, “:at_end:”) до текста строки заголовка, соответственно. (Текст заголовка не может начинаться с двоеточия, поскольку вначале должно быть имя заголовка.) Например::

    warn add_header = \
           :after_received:X-My-Header: something or other...

Если более в одном модификаторе **add_header** предоставляется более одной строки заголовка, каждая рассматривается независимо, и может быть помещена по другому. Если вы добавляете более одной строки в начале, или после блока “Received:”, они завершаются в обратном порядке.

.. warning:: Это средство, сейчас, применяется лишь к строкам заголовков которые добавлены в ACL. Оно НЕ работает для строк заголовков которые добавлены в системном фильте, или в маршрутизаторе, или в транспорте.

.. _ch40_24:

Условия ACL
-----------

Некоторые условия, перечисленные в этой секции, доступны лишь если Exim собран с поддержкой расширения сканирования содержимого. Они кратко включены здесь, для завершённости. Более детальное описание может быть найдено в обсуждении сканирования содержания в главе :ref:`41 <ch41_00>`.

Не все условия уместны во всех обстоятельствах. Например, проверка отправителей и получателей не имеет смысла в ACL, которая запускается как результат прихода команды ETRN, и проверки заголовков сообщения могут быть сделаны лишь в ACL заданной путём **acl_smtp_data** или **acl_not_smtp**. Вы можете использовать некоторые условия (с иными параметрами) более чем в одном утверждении ACL. Этим предоставляется способ определения соединения “and” (“и”). Условия таковы:

  **acl = <name of acl or ACL string or file name>**
    Возможные значения аргумента - такие же как и для параметра **acl_smtp_xxx**. Запускается именованная или встроенная ACL. Если она возвращает “accept”, условие истинно; если она возвращает “deny”, условие ложно. Если она возвращает “defer”, текущая ACL возвращает “defer”, исключая условия в команде “warn”. В этом случае, возврат “defer” делает условие ложным. Это означает, что дальнейшая обработка команды **warn** прекращается, но обработка ACL продолжается.

    Если вложенные **acl** возвращают “drop”, и внешнее условие отказывает в доступе, соединение рвётся. Если они возвращают “discard”, команда должна быть **accept** или **discard**, и действие предпринимается немедленно - никакие дальнейшие условия не проверяются.

    ACL могут быть вложены до 20 уровней; предел существует лишь для поимки петель. Это условие разрешает вам использовать различные ACL в различных условиях. Например, различные ACL могут быть использованы для обработки команд RCPT для различных локальных пользователей, или различных локальных доменов.

  **authenticated = <string list>**
    Если SMTP соединение не аутентифицировано, условие ложно. Иначе, имя аутентификатора сверяется со списком. Для тестирования аутентификации путём любого аутентификатора, вы можете задать

    ::

        authenticated = *

  **condition = <string>**
    Эта возможность позволяет вам создавать нестандартные условия. Если результат раскрытия - пустая строка, число ноль, или одна из строка - “no” или “false”, условие ложно. Если результат - ненулевое число, или одна из строк - “yes” или “true”, условие истинно. Для любого другого значения, предполагается что произошла какая-то ошибка, и ACL возвращает “defer”. Однако, если раскрытие принудительно неудачно, условие игнорируется. Эффект рассматривается как истина, вне зависимости от того позивный он или негативный.

  **decode = <location>**
    Это условие доступно лишь если Exim собран с расширением сканирования содержания, и он разрешён лишь в ACL заданной путём **acl_smtp_mime**. Оно вызывает декодирование текущей части MIME в файл.

    Если всё проходит успешно - условие истинно. Оно ложно лишь в случае проблем типа синтаксических ошибок или нехватки памяти. Для дополнительных деталей, смотрите главу :ref:`41 <ch41_00>`.

  **demime = <extension list>**
    Это условие доступно лишь если Exim собран с расширением сканирования содержания. Его использование описано в разделе :ref:`41.6 <ch41_06>`.

  **dnslists = <list of domain names and other data>**
    Это условие проверяет записи в чёрных списках DNS. Они также известны как “RBL lists”, после оригинального Realtime Blackhole List, но отметьте, что это использование списков в *mail-abuse.org* сейчас приносит большую нагрузку. Есть очень много различных вариантов этого условия, для краткого описания. Для деталей, смотрите разделы :ref:`40.24 <ch40_24>`-:ref:`40.34 <ch40_34>`.

  **domains = <domain list>**
    Это условие уместно лишь после команды RCPT. Оно проверяет, что домен получателя - в списке доменов. Если включена обработка символа процента, она производится до этого теста. Если проверка поиском удачна, результат поиска помещается в $domain_data, до следующего теста **domains**.

    Будьте внимательны (поскольку много людей ошибалось на этом): вы не можете использовать **domains** в ACL DATA.

  **encrypted = <string list>**
    Если SMTP соединение не шифруется, условие ложно. Иначе, имя метода шифрования используется для проверки по списку. Для тестирования на шифрование без тестирования на определённый метод шифрования, установите
    
    ::
    
        encrypted = *

  **hosts = <host list>**
    Это условие проверяет, что вызывающий хост совпадает со списком хостов. Если вы производите поиски имени, или шаблонов имён хостов и IP адресов в одном и том же списке хостов, обычно, вы должны вначале поместить IP адрес. Например, у вас могло бы быть:
    
    ::
    
        accept hosts = 10.9.8.7 : dbm;/etc/friendly/hosts

    Причина этого - в обработке Exim'ом списков хостов слева направо. Он может тестировать IP адреса без поиска в DNS, но, когда он достигает пункта требующего имени хоста, он завершается с неудачей если не может найти имя хоста для сравнения с шаблоном. Если вышеупомянутый список даётся в обратном порядке, утверждение **accept** неудачно для хоста, чьё имя не может быть найдено, даже если его IP - 10.9.8.7.

    Если вам действительно нужно вначале проверять имена, и всё ещё распознавать IP адреса, даже если поиск неудачен, вы можете переписать ACL так:
    
    ::
    
        accept hosts = dbm;/etc/friendly/hosts
        accept hosts = 10.9.8.7

    Действие по умолчанию при провале попытки найти имя хоста - предположение, что хост не в списке, таким образом, первое утверждение **accept** - неудачно. Тогда, второе утверждение может проверить IP адрес.

    Если условие **hosts** удовлетворяется путём поиска, результат поиска становится доступен в переменной $host_data. Это позволяет вам, например, установить утверждение типа такого:
    
    ::
    
        deny  hosts = net-lsearch;/some/file
              message = $host_data

    которое позволяет вам сделать персональное сообщение о ошибке для каждого отказанного хоста.
    
  **local_parts = <local part list>**
    Это условие доступно лишь после команды RCPT. Оно проверяет что локальная часть адреса получателя находится в списке. Если включена обработка символа процента, она завершается до этого теста. Если проверка успешна путём поиска, результат поиска помещается в $local_part_data, которая остаётся установленной до следующего теста **local_parts**.

  **malware = <option>**
    Это условие доступно лишь когда Exim собран с поддержкой расширения сканирования содержания. Оно вызывает сканирование входящего сообщения на вирусы. Для дополнительных деталей, смотрите главу :ref:`41 <ch41_00>`.

  **mime_regex = <list of regular expressions>**
    Это условие доступно лишь когда Exim собран с поддержкой расширения сканирования содержания, и оно разрешено лишь для ACL заданной путём **acl_smtp_mime**. Она вызывает сканирование текущей MIME части на совпадение с любым регулярным выражением. Для дополнительных деталей, смотрите главу :ref:`41 <ch41_00>`.

  **ratelimit = <parameters>**
    Это условие может быть использовано для ограничения частоты, с которой пользователь или хост посылают сообщения. Детали даны в разделе :ref:`40.35 <ch40_35>`.

  **recipients = <address list>**
    Это условие уместно лишь после команды RCPT. Она проверяет входящий адрес получателя по списку получателей.

  **regex = <list of regular expressions>**
    Это условие доступно лишь когда Exim собран с поддержкой расширения сканирования содержания, и оно доступно лишь в DATA, MIME, и не-SMTP ACL. Оно вызывает сканирование входящего сообщения на совпадение с любым регулярным выражением. Для дополнительных деталей, смотрите главу :ref:`41 <ch41_00>`.

  **sender_domains = <domain list>**
    Это условие тестирует домен отправителя сообщения с заданным списком доменов. 
    
    .. note:: домен адреса отправителя - $sender_address_domain. Он не помещается в $domain в процессе тестирования этого условия. Это - исключение из общего правила тестирования списков доменов. Так сделано для того, чтобы если это условие используется в ACL для команды RCPT, домен получателя (который находится в $domain), мог влиять на проверку отправителя.

    .. warning:: Плохая идея, использовать это условие как контроль пересылки, поскольку адреса отправителя легко, и обычно, подделываются.

 
  **senders = <address list>**
    Это условие тестирует отправителя сообщения по данному списку. Для тестирования рикошетов, у которых пустой отправитель, установите:
   
    ::
   
        senders = :

    .. warning:: Плохая идея, использовать это условие как контроль пересылки, поскольку адреса отправителя легко, и обычно, подделываются.

  **spam = <username>**
    Это условие доступно лишь когда Exim собран с поддержкой расширения сканирования содержания. Оно вызывает сканирование входящего сообщения с помощью SpamAssassin. Для дополнительных деталей, смотрите главу :ref:`41 <ch41_00>`.

  **verify = certificate**
    Это условие истинно если SMTP-сессия шифрована, и клиент передал сертификат, и сертификат был проверен. Сервер запрашивает сертификат лишь если клиент совпадает с **tls_verify_hosts** или **tls_try_verify_hosts** (смотрите главу :ref:`38 <ch38_00>`).

  **verify = csa**
    Это условие проверяет, авторизован ли хост (клиент) посылать почту. Детали, как это работает, даны в разделе :ref:`40.46 <ch40_46>`.

  **verify = header_sender/<options>**
    Это условие уместно лишь в ACL, которая запускается после получения сообщения, т.е. в ACL заданной путём **acl_smtp_data** или **acl_not_smtp**. Оно проверяет наличие адреса поддающегося проверке по крайней мере в одном из заголовков “Sender:”, “Reply-To:” или “From:”. Каждый адрес предполагается адресом отправителя (следовательно, именем теста). Однако, адрес появляющийся в одном из этих заголовков, не должен быть адресом, принимающим рикошеты; лишь адрес отправителя в конверте должен принимать рикошеты. Поэтому, если вы используете параметр обратного вызова в этой проверке, вы могли бы хотеть переделать её для не пустого адреса в команде MAIL.

    Детали проверки адреса и параметров даны позднее, начиная с раздела :ref:`40.40 <ch40_40>` (обратные вызовы описаны в разделе :ref:`40.41 <ch40_41>`). Вы можете комбинировать эти условия с условием **senders**, для ограничения его лишь рикошетами:
    
    ::
    
        deny    senders = :
                message = A valid sender header is required for bounces
                !verify  = header_sender

  **verify = header_syntax**
    Это условие уместно лишь в ACL, которая запускается после приёма сообщения, т.е., в ACL заданных путём **acl_smtp_data** или **acl_not_smtp**. Она проверяет синтаксис всех строк заголовков, которые могут содержать адреса (“(Sender:”, “From:”, “Reply-To:”, “To:”, “Cc:” и “Bcc:”). Неквалифицированные адреса (локальные части без домена) разрешены лишь в локально-созданных сообщениях и от хостов, которые совпадают с **sender_unqualified_hosts** или **recipient_unqualified_hosts**, соответственно.

    .. note:: Это условие - лишь проверка синтаксиса. Однако, обычная уловка спамеров - использовать для отправки синтаксически неверные заголовки, типа

      ::
    
          To: @

      и это условие может использоваться для отклонения таких сообщений, хотя они не очень часто используются.

      
  **verify = helo**
    Это условие истинно, если команда HELO или EHLO была передана с клиентского хоста, и её содержимое было проверено. До него не было никаких попыток проверить содержимое HELO/EHLO, и оно выполняется как только встречаются с этим условием. Смотрите описание параметров **helo_verify_hosts** и **helo_try_verify_hosts**, для деталей о том, как запросить проверку незавсисмо от этого условия.

    Для SMTP ввода, не приходящего через TCP/IP (параметр **-bs** командной строки) - это условие всегда истинно.

  **verify = not_blind**
    Это условие проверяет, что в сообщении нет получателей скрытой копии (bcc). Каждый получатель конверта должен быть в строке заголовка “To:” или в “Cc:”, чтобы это условие было истинным. Локальная часть проверяется регистрозавсисмо; домен проверяется регистронезависимо. Если существуют строки “Resent-To:” или “Resent-Cc:”, они также проверяются. Это условие может использоваться лишь в DATA или не-SMTP ACL.

    Конечно, есть множество законных сообщений, использующих скрытых получателей. Эта проверка не должна самостоятельно использоваться для блокировки сообщений.

  **verify = recipient/<options>**
    Это условие уместно лишь после команды RCPT. Оно проверяет текущего получателя. Детали проверки адреса даны позднее, начиная с разделе :ref:`40.40 <ch40_40>`. После проверки получателя, значение $address_data - последнее значение установленное при маршрутизации адреса. Оно применяется даже если проверка была ложной. Когда проверенный адрес переадресован на один адрес, проверка продолжается с новым адресом, и в этом случае, последующее значение для $address_data - значение дочернего адреса.

  **verify = reverse_host_lookup**
    Это условие обеспечивает, что проверенное имя хоста было найдено из IP-адреса клиентского хоста. (Это, возможно уже случилось, если имя хоста необходимо для проверки списка хостов, или, если хост совпадает с **host_lookup**.) Проверка обеспечивает, что имя хоста, полученное из обратного поиска DNS, или один из его синонимов, когда он самостоятельно ищется в DNS, действительно приводит к оригинальному IP-адресу.

    Если это условие используется для локально созданных сообщений (т.е. когда нет клиентского хоста), оно всегда успешно.

  **verify = sender/<options>**
    Это условие уместно лишь после команды MAIL или RCPT, или после того, как сообщение было получено (ACL **acl_smtp_data** или **acl_not_smtp**). Если отправитель сообщения пустой (т.е. - это рикошет), условие истинно. Иначе, проверяется адрес отправителя.

    Если есть данные в переменной конца маршрутизации $address_data, её значение помещается в $sender_address_data в конце проверки. Это значение может использовано в последующих условиях и модификаторах в том же самом утверждении ACL. Оно не сохраняется после окончания текущего утверждения. Если вы хотите сохранить значение надолго, вы можете сохранить его в переменной ACL.

    Детали проверки адреса даны позднее, начиная с раздела :ref:`40.40 <ch40_40>`. Exim кэширует результат проверки отправителя, чтобы не делать его более одного раза на сообщение.

  **verify = sender = <address>/<options>**
    Это - вариант предыдущего параметра, в котором модифицированный адрес проверен как отправитель.


.. _ch40_25:

Использование списков DNS
-------------------------

В самой его простой форме, условие **dnslists** проверяет, находится ли вызывающий хост в по крайней мере одном из DNS списков, путём поиска инвертированного IP-адреса в одном или более DNS-домене. (отметьте, что списки доменов DNS - не почтовые домены, таким образом, синтаксис “+” для/ именованных списков не работает - вместо этого он используется для специальных параметров) Например, если IP-адрес вызывающего хоста - 192.168.62.43, и утверждение ACL

::

    deny dnslists = blackholes.mail-abuse.org : \
                    dialups.mail-abuse.org

ищется следующие записи::

    43.62.168.192.blackholes.mail-abuse.org
    43.62.168.192.dialups.mail-abuse.org


Как только Exim находит существующую запись DNS, обработка списка останавливается. таким образом, многочисленные записи в списке связаны союзом “or”. Если вы хотите тестировать хост более чем одним списком (и союзом “and”), вы можете использовать два раздельных условия::

    deny dnslists = blackholes.mail-abuse.org
    dnslists = dialups.mail-abuse.org

Если происходит таймаут поиска в DNS, или иным образом невозможно дать окончательный ответ, Exim ведёт себя, как будто хост не совпал с элементом списка, т.е., как будто запись DNS не существует. Если в списке DNS есть дальнейшие элементы, они обрабатываются.

Это - обычное необходимое действие, когда **dnslists** используется с **deny** (что является самым частым использованием), поскольку это препятствует ошибке DNS блокировать почту. Однако, вы можете изменить это поведение путём помещения одного из следующих специальных элементов в список::

    +include_unknown    behave as if the item is on the list
    +exclude_unknown    behave as if the item is not on the list (default)
    +defer_unknown      give a temporary error

Каждый из них применяется к любым последующим элементам списка. Например::

    deny dnslists = +defer_unknown : foo.bar.example

Тестирование списка доменов останавливается как только найдено соответствие.Если вы хотите предупреждать для одного списка и блокировать для другого, вы можете задать два различных утверждения::

    deny  dnslists = blackholes.mail-abuse.org
    warn  message  = X-Warn: sending host is on dialups list
          dnslists = dialups.mail-abuse.org

Поиски в списках DNS кэшируются Exim'ом на продолжительность сессии SMTP, таким образом, поиск основанный на IP адресе производится максимум один раз для любого входящего SMTP-соединения. Exim не разделяет информацию между несколькими входящими соединениями (но, ваш локальный кэширующий сервер имён должен быть активен).

.. _ch40_26:

Задание IP-адреса для поиска в списках DNS
------------------------------------------

По умолчанию, IP адрес, который используется в поиске по списку DNS - это IP-адрес вызывающего хоста. Однако, вы можете задать иной IP-адрес, путём перечисления его после доменного имени, отделённого слэшем. Например::

    deny dnslists = black.list.tld/192.168.1.2

Эта особенность не очень полезна с явными IP-адресами; она предназначена для использования с искомыми IP-адресами, например, IP-адресами MX-хостов, или серверов имён почтового адреса отправителя. Для примеров, смотрите ниже, раздел :ref:`40.27 <ch40_28>`.


.. _ch40_27:

DNS-списки основанные на именах доменов
---------------------------------------

Есть некоторые списки, которые основаны на доменных именах, вместо инвертированных IP-адресов (например, смотрите ссылку domain based zones на http://www.rfc-ignorant.org/). С этими листами реверсирования компонентов не используется. Вы можете изменить имя, которое ищется в списках DNS, путём внесения его после имени домена, отделённое слэшем. Например::

    deny  message  = Sender's domain is listed at $dnslist_domain
          dnslists = dsn.rfc-ignorant.org/$sender_address_domain

Этот специфический пример полезен лишь в ACL которые обрабатываются после команд RCPT или DATA, если доступен адрес отправителя. Если (например) отправитель сообщения - *user@tld.example*, имя искомое этим примером::

    tld.example.dsn.rfc-ignorant.org

Одиночное условие **dnslists** может содержать в себе оба вхождения - для имён и для IP-адресов. Например::

    deny dnslists = sbl.spamhaus.org : \
                    dsn.rfc-ignorant.org/$sender_address_domain

Первый элемент проверяет адрес отправляющего хоста; второй проверяет доменное имя. Всё условие верно, если успешен любой из поисков DNS.

.. _ch40_28:

Поиски в DNS основанные на нескольких ключах
--------------------------------------------

Синтаксис описанный выше, для поиска в чёрных списках DNS по явно заданным значениям (или имени, или IP-адреса) - упрощение. В DNS-списке, после доменного имени сопровождаемого слэшом, фактически, может быть список элементов. Как и во всех списках Exim'a, разделитель по умолчанию - двоеточие. Однако, поскольку это - подсписок в списке доменов чёрных списков DNS, необходимо удвоить разделители::

    dnslists = black.list.tld/name.1::name.2

или изменить символ разделителя, например так::

    dnslists = black.list.tld/<;name.1;name.2

Если элемент в списке - IP-адрес, он инвертируется до добавления области чёрного списка DNS. Если он - не IP-адрес, инверсии не происходит.Рассмотрите это условие::

    dnslists = black.list.tld/<;192.168.1.2;a.domain

Происходящие поиски в DNS::

    2.1.168.192.black.list.tld
    a.domain.black.list.tld

Как только найдена запись в DNS (которая совпадает с заданным возвращаемым IP-адресом, если задано - смотрите раздел :ref:`ch40_31`), дальнейший поиск не производится. Если происходит временная ошибка поиска в DNS, пробуется остальная часть списка доменов/IP-адресов. Временная ошибка для всего элемента списка DNS происходит лишь если безуспешны поиски по остальным DNS подспискам. Другими словами, успешный поиск для любого элемента подсписка отменяет временную ошибку для предыдущего элемента.

Способность подставлять список элементов после слэша, в некотором смысле - лишь синтаксическое удобство. Следующие два примера, имеют один и тот же эффект::

    dnslists = black.list.tld/a.domain : black.list.tld/b.domain
    dnslists = black.list.tld/a.domain::b.domain

Однако, когда данные для списка получаются путём поиска, вторая форма, обычно, намного более удобна. Рассмотрите этот пример::

   deny message  = The mail servers for the domain \
                   $sender_address_domain \
                   are listed at $dnslist_domain ($dnslist_value); \
                   see $dnslist_text.
        dnslists = sbl.spamhaus.org/<|${lookup dnsdb {>|a=<|\
                                      ${lookup dnsdb {>|mxh=\
                                      $sender_address_domain} }} }

Отметьте использование “>|” в поиске dnsdb, для задания сепаратора в нескольких DNS-записях. Внутренний поиск dnsdb производит список хостов MX, и внешний dnsdb поиск находит IP-адреса этих хостов. Результат раскрытия условия мог бы быть чем-то вроде этого::

    dnslists = sbl.spahmaus.org/<|192.168.2.3|192.168.5.6|...

Таким образом, этот пример проверяет, действительно ли IP-адрес почтового сервера отправителя находится в чёрном списке Spamhaus.

Ключ который использовался для успешного поиска в списке DNS кладётся в переменную $dnslist_matched (смотрите раздел :ref:`40.30 <ch40_30>`).

.. _ch40_29:

Данные возвращаемые списками DNS
--------------------------------

DNS списки построены с использованием записей в DNS. Оригинальный RBL использовал лишь адрес 127.0.0.1 на правой стороне каждой записи, но списки RBL+ и некоторые другие списки используют несколько значений с различными значениями. Значения используемые списками RBL+ таковы::

    127.1.0.1  RBL
    127.1.0.2  DUL
    127.1.0.3  DUL and RBL
    127.1.0.4  RSS
    127.1.0.5  RSS and RBL
    127.1.0.6  RSS and DUL
    127.1.0.7  RSS and DUL and RBL

Раздел :ref:`40.31 <ch40_31>`, ниже, описывает как вы можете различить различные значения.

Некоторые списки DNS могут возвращать более одной адресной записи; смотрите раздел :ref:`40.33 <ch40_33>` для деталей того как они проверяются.

.. _ch40_30:

Переменные устанавливаемые из списков DNS
-----------------------------------------

Когда в списке DNS найдено вхождение, переменная $dnslist_domain содержит полное имя совпавшего домена (например, *spamhaus.example*), $dnslist_matched - содержит ключ домена (например, “192.168.5.3”), и, $dnslist_text - содержимое записи DNS. Когда ключ - IP адрес, он не превращается в $dnslist_matched (хотя он в реально ищщется). В простом случае, например::

    deny dnslists = spamhaus.example

ключ, также, доступен в другой перемнной (в этом случае - $sender_host_address). В более сложных случаях, это не так. Например, используя поиск данных (как описано в разделе :ref:`40.28 <ch40_28>`) можно производить поиск в **dnslists** следующим образом::

    deny dnslists = spamhaus.example/<|192.168.1.2|192.168.6.7|...

В случае успешности этого условия, значение $dnslist_matched должно быть, например, “192.168.6.7”.

Если поиском в DNS возвращается более одной адресной записи, все IP адреса включаются в $dnslist_value, разделённые запятыми и пробелами. В переменная $dnslist_text находиться содержимое любой ассоциированной TXT записи. Для список типа RBL+ запись TXT для включенной записи - часто бессмысленна. Сморите раздел :ref:`40.34 <ch40_34>` для получения дополнительной информации.

Вы можете использовать эти переменные в модификаторах **message** и **log_message** - хотя они появляются до условия в ACL, они не раскрываются пока не произойдёт неудача. Например::

    deny    hosts = !+local_networks
            message = $sender_host_address is listed \
              at $dnslist_domain
              dnslists = rbl-plus.mail-abuse.example

.. _ch40_31:

Дополнительные совпадения условий для списков DNS
-------------------------------------------------

Вы можете добавить символ равно и IP-адрес после доменного имени **dnslists**, для ограничения его действия DNS-записями с соответствующей правой стороной. Например,

::

    deny dnslists = rblplus.mail-abuse.org=127.0.0.2

отклоняет лишь те хосты, которые приводят к 127.0.0.2. Без этих дополнительных данных, любая адресная запись предполагается совпадающей. На данный момент, мы предполагаем что поиск в DNS возвращает лишь одну запись. Раздел :ref:`40.32 <ch40_32>` описывает то, как обрабатываются несколько записей.

Для проверки можно задать более чем один IP-адрес, используя двоеточие как разделитель. Они - альтернативы, если совпадает любой из них, условие **dnslists** - истинно. Например::

   deny  dnslists = a.b.c=127.0.0.2,127.0.0.3

Если вы хотите задать ограниченный список адресов, и, также, определить имена или IP-адреса для поиска, ограниченный список адресов должен быть задан первым. Например::

    deny dnslists = dsn.rfc-ignorant.org\
                    =127.0.0.2/$sender_address_domain

Если символ “&” используется вместо “=”, сравнение для каждого перечисленного IP-адреса завершается путём поразрядного “and” вместо теста равенства. Другими словами, перечисленные адреса используются как битовые маски. Сравнение истинно, если все биты в маске представлены в тестируемом адресе. Например::

    dnslists = a.b.c&0.0.0.3

совпадает с адресом “x.x.x.3”, “x.x.x.7”, “x.x.x.11”, и т.д. Если вы хотите проверить, что представлен тот или иной бит (в противоположность представленным обоим), вы должны использовать несколько значений. Например::

    dnslists = a.b.c&0.0.0.1,0.0.0.2

совпадает, если последний компонент адреса - нечётное число, или удвоенное нечетное число.

.. _ch40_32:

Отрицательные условия сравнения DNS
-----------------------------------

Вы можете предоставлять отрицательный список IP-адресов, как часть условия **dnslists**. Тогда как

::

    deny  dnslists = a.b.c=127.0.0.2,127.0.0.3

значит “запрет, если хост в чёрном списке домена a.b.c и IP-адрес приводит к списку в котором 127.0.0.2 или 127.0.0.3”,

::

    deny  dnslists = a.b.c!=127.0.0.2,127.0.0.3

средство “запрет, если хост в чёрном списке домена a.b.c и IP-адрес не приводит к списку в котором 127.0.0.2 и 127.0.0.3”. Другими словами, результат тестирования - инвертирован, если восклицательный знак появляется перед символом “=” ( или “&”).

.. note:: Этот вид отрицания - не то же самое, что и отрицание домена, хостов, или списков адресов (почему и синтаксис различается).

Если вы используете только один список, синтаксис отрицания немного вам даст. Предыдущий пример эквивалентен::

   deny  dnslists = a.b.c
         !dnslists = a.b.c=127.0.0.2,127.0.0.3

Однако, если вы используете составные списки, синтаксис отрицания более ясен. Рассмотрите этот пример::

    deny  dnslists = sbl.spamhaus.org : \
                     list.dsbl.org : \
                     dnsbl.njabl.org!=127.0.0.3 : \
                     relays.ordb.org

Используя только позитивные списки, это было бы так::

    deny  dnslists = sbl.spamhaus.org : \
                     list.dsbl.org
    deny  dnslists = dnsbl.njabl.org
          !dnslists = dnsbl.njabl.org=127.0.0.3
    deny  dnslists = relays.ordb.org

который менее ясен, и тяжелее поддерживать.

.. _ch40_33:

Обработка нескольких записей DNS из списка DNS
----------------------------------------------

Поиск в DNS для условия **dnslists** может вернуть более чем одну запись DNS, в связи с чем, предоставляется более одного IP адреса. Когда элемент в списке **dnslists** сопровождается “=” или “&” и списком IP адресов, в порядке ограничения совпадения со специфическим результатом из поиска DNS, есть два пути для обработки проверки. Например, рассмотрим условие::

    dnslists = a.b.c=127.0.0.1

Что происходит если поиск в DNS входящего IP адреса приносит 127.0.0.1 и 127.0.0.2 посредством двух различных записей DNS. Условие истинно, поскольку одно из заданных значений найдено, или оно ложно, поскольку одно из найденных значений не в списке? И как это применяется к отрицательным условиям? Обе возможности предоставляются с помощью дополнительных разделителей - “==” и “=&”.

Если используется “=” или “&”, условие истинно если один любой искомый IP адрес совпадает с одним из перечисленных адресов. Для примера выше, условие истинно, поскольку совпал 127.0.0.1.

Если используется “==” или “=&”, условие истинно лишь когда один из искомых IP адресов совпадает с одним из перечисленных доменов. Если условие изменить на::

    dnslists = a.b.c==127.0.0.1

и поиск в DNS приносит 127.0.0.1 и 127.0.0.2, условие ложно, поскольку 127.0.0.2 не в списке. Вам необходимо иметь

::

    dnslists = a.b.c==127.0.0.1,127.0.0.2

чтобы условие было истинным.

Когда для отрицания совпадения IP адресов используется “!”, он инвертирует результат, давая точную противоположность приведённому выше. Таким образом:

* Если используется “!=” или “!&”, условие истинно если ничего не нашлось ни для одного из адресов. Рассмотрим:
  
  ::
  
      dnslists = a.b.c!&0.0.0.1
         
* Если поиск в DNS принёс оба - 127.0.0.1 и 127.0.0.2, условие ложно, поскольку совпал 127.0.0.1.

* Если используется “!==” или “!=&”, условие истинно, поскольку один найденный IP адрес не совпадает. Вам необходимо иметь:
  
  ::
  
      dnslists = a.b.c!=&0.0.0.1,0.0.0.2

  для того чтобы условие было ложным.
  
* Когда поиск в DNS приносит только один IP адрес, нет различия между “=” и “==”, и между “&” и “=&”.

.. _ch40_34:

Дополнительная информация из объединённых списков DNS
-----------------------------------------------------

Когда используется средство для ограничения совпадающих значений IP в списках DNS, текст из записи TXT, который устанавливается в переменную $dnslist_text может не отражать истинную причину отказа. Это происходит когда списки объединяются и IP адрес в A записи используется для их идентификации; к несчастью, тут только одна TXT запись. Один из путей обхода этого - не использовать объединённые списик, но это может быть неэффективным, поскольку это потребует многочисленных поисков в DNS, тогда как в большинстве случаев хост не находиться ни в одном списке.

Доступен менее эффективный способ решения этой проблемы. Если даны два доменных имени, разделённые запятыми, второе использует первое для начальной проверки, ограничивая любые значения IP этим набором. Если происходит совпадение, первый домен используется без каких-либо ограничений значений IP для получения TXT записи. Как побочный продукт этого, также тестируется что IP адрес действительно первый в списке. Первый домен - тот что помещается в $dnslist_domain. Например::

    reject message  = \
             rejected because $sender_host_address is blacklisted \
             at $dnslist_domain\n$dnslist_text
           dnslists = \
             sbl.spamhaus.org,sbl-xbl.spamhaus.org=127.0.0.2 : \
             dul.dnsbl.sorbs.net,dnsbl.sorbs.net=127.0.0.10

Для первого элемента чёрного списка, всё начинается с поиска в *sbl-xbl.spamhaus.org* и тестирования на возвращение 127.0.0.2. Если происходит совпадение, затем проверяется *sbl.spamhaus.org* без проверки возвращённого значения и как только что-то нашлось, ищется соответствующая TXT запись. Если нет совпадений для *sbl-xbl.spamhaus.org* - больше ничего не происходит. Второй элемент чёрного списка обрабатывается подобным образом.

Если вас интересует более чем один объединённый список, тот же список может быть задан несколько раз, но, поскольку результаты поиска в DNS кэшируются, вызовы DNS не повторяются. Например::

    reject dnslists = \
             http.dnsbl.sorbs.net,dnsbl.sorbs.net=127.0.0.2 : \
             socks.dnsbl.sorbs.net,dnsbl.sorbs.net=127.0.0.3 : \
             misc.dnsbl.sorbs.net,dnsbl.sorbs.net=127.0.0.4 : \
             dul.dnsbl.sorbs.net,dnsbl.sorbs.net=127.0.0.10

В этом случае происходит один поиск в *dnsbl.sorbs.net*, и, если никакое из IP значений не совпало (или если записей не найдено), - только этот поиск осуществляется. Только в случае совпадения, происходит консультация с одним или несколькими специфическими списками.

.. _ch40_35:

Списки DNS и IPv6
-----------------

Если Exim'a просят сделать поиск по списку DNS для адреса IPv6, он его инвертирует, и откусывает по кусочкам. Например, если адрес вызывающего хоста - 3ffe:ffff:836f:0a00:000a:0800:200a:c031, Exim мог бы искать

::

    1.3.0.c.a.0.0.2.0.0.8.0.a.0.0.0.0.0.a.0.f.6.3.8.
      f.f.f.f.e.f.f.3.blackholes.mail-abuse.org

(разбито на две строки, чтобы вписать в страницу). К сожалению, некоторые списки DNS содержат групповые записи, подразумевающие IPv4, плохо взаимодействующие с IPv6. Например, DNS-запись

::

    *.3.some.list.example.    A    127.0.0.1

вероятно, предназначен для помещения записи 3.0.0.0/8 сети IPv4 в список. К сожалению, это также соответствует всем сетям 3::/4, для IPv6.

Вы можете исключить адреса IPv6 из DNS-поисков используя подходящее условие **condition**, как в этом примере::

    deny   condition = ${if isip4{$sender_host_address}}
           dnslists  = some.list.example

.. _ch40_36:

Ограничение частоты входящих сообщений
--------------------------------------

Условие ACL **ratelimit** может быть использовано для измерения и контроля частоты с которой клиенты могут посылать электронную почту. Это более мощное средство, чем параметр **smtp_ratelimit_***, поскольку этот параметр управляет частотой команд лишь в одной SMTP-сессии, тогда как условие **ratelimit** работает для всех соединений (параллельных и последовательных) от того же самого хоста. Синтаксис условия **ratelimit**, таков::

    ratelimit = <m> / <p> / <options> / <key>

Если средний клиент, посылающий с частотой меньше *m* сообщений за период времени *p*, условие - ложно; иначе, оно истинно.

Как побочный эффект, условие **ratelimit** устанавливает переменную раскрытия $sender_rate в вычисленную частоту клиента, $sender_rate_limit в сконфигурированное значение *m*, и $sender_rate_period в настроеное значение *p*.

Параметр *p* - постоянная временная константа, в форме интервалов времени Exim'a, например, 8h - для восьми часов. Большее постоянное время, означает, что Exim'y требуется большее время, чтобы забыть прошлое поведение клиента. Параметр *m* - максимальное число сообщений, которые клиенту разрешено посылать в каждый интервал времени. Также, он определяет число сообщений разрешённых в быстром пакетном режиме. Путём увеличения обоих *m* и *p*, но оставляя неизменной константу *m/p*, вы позволяете клиенту посылать больше сообщений в пакетном режиме без изменения его долговременного предела посылки. Наоборот, если малы оба *m* и *p*, сообщения должны посылаться в пределах лимита.

Есть скрипт *util/ratelimit.pl*, который извлекает частоту частоту отсылки из лог-файлов, помогая выбрать соответствующие значения для *m* и *p*, при развёртывании условия ACL **ratelimit**. Скрипт выводит инструкцию по использованию, когда он запускается без аргументов.

Для поиска данных, для вычисления средней частоты клиента посылки клиентом, используется ключ. Эти данные сохраняются в директории спула Exim'a, наряду с данными повторов и другими базами подсказок. Ключ по умолчанию - $sender_host_address, который применяет ограничения к каждому IP-адресу клиентского хоста. Путём изменения ключа, вы можете изменить то, как Exim идентифицирует клиентов для ограничения частоты. Например, для ограничения частоты отправлений для каждого аутентифицированного пользователя, независимо от компьютера с которого отсылается, установите ключ в $authenticated_id. Вы должны гарантировать, что ключ является значимым; например, $authenticated_id - является значимым лишь если клиент аутентифицировался. (Который вы можете проверить с условием ACL **authenticated**)

Ключи поиска не должны идентифицировать клиентов: если вы хотите ограничить частоту с которой получатель принимает сообщения, вы можете использовать ключ *$local_part@$domain* с параметром **per_rcpt** (см. ниже) в ACL RCPT.

Внутренне, Exim добавляет сглаживание константы *p*, и параметров ключей поиска, поскольку они изменяют значение сохранённых данных. Это не истинно, для лимита *m*, таким образом, вы можете изменять сконфигурированную максимальную частоту, и Exim продолжает помнить предыдущее поведение клиента, но, если вы изменяете другие параметры частоты, Exim забывает прошлое поведение.

Каждое условие **ratelimit** может иметь до трёх параметров. Первый параметр задаёт что Exim считает мерой частоты, и второй определяет как Exim обрабатывает чрезмерно быстрых клиентов. Третий параметр, может быть **noupdate**, для отключения обновления базы данных частоты отправок (смотрите раздел :ref:`40.40 <ch40_40>`). Параметры разделены слэшами, как и другие параметры. Они могут появляться в любом порядке.

.. _ch40_37:

Параметры измерения для **ratelimit**
-------------------------------------

Параметр **per_conn** ограничивает частоту подключения клиента.

Параметр **per_mail** ограничивает частоту посылки сообщений клиентом. Это - значение по умолчанию, если на заданы параметры **per_**.

Параметр **per_byte** ограничивает полосу пропускания электронной почты отправителя. Отметьте, что её лучше использовать в DATA ACL; если это используется в более ранней ACL, она полагается на параметр SIZE определённый клиентом в команде MAIL, которая может быть неточной, или вообще отсутствовать. Вы можете сопровождать лимит “m” в конфигурации K, M, или G - для задания, соответственно, килобайт, мегабайт, или гигабайт.

Параметр **per_rcpt** заставляет Exim ограничить частоту с которой принимаются получатели. Для эффективности, её необходимо использовать в **acl_smtp_rcpt** или **acl_not_smtp** ACL. В ACL **acl_smtp_rcpt** число получателей увеличивается по одному. В случае локально переданного сообщения, в ACL **acl_not_smtp** число получателей увеличивается путём $recipients_count для всего сообщения. Отметьте, что в этом случае движок ограничения частоты будет видеть сообщения с несколькими получателями, как большой, высокоскоростной пакетный режим.

Параметр **per_cmd** заставляет Exim пересчитывать частоту при каждой обработке условия. Это может быть использовано для ограничения частоты команд SMTP. Эта команда, по существу, - синоним **per_rcpt** для очищения его от эффекта ограничения частоты индивидуальными командами, а не получателями.


.. _ch40_38:

Параметры **ratelimit** для обработки быстрых клиентов
------------------------------------------------------

Если средняя частота клиента больше чем максимум, движок ограничения частоты может воздействовать двумя возможными способами, зависящими от наличия параметров **strict** или **leaky**. Это не зависит от других контрмер (типа отклонения сообщения), которые могут быть заданы путём остальной части ACL. Режим по умолчанию - **leaky**, который избегает сверх-агрессивной частоты повтора клиента, препятствуя отправке им любой почты.

Параметр **strict** означает, что клиентские записи частоты всегда обновляются. Эффект этого - что Exim измеряет среднюю частоту клиента пытаться послать электронную почту, которая может быть значительно выше максимума. Если клиент превысит предел - он будет подвергнут контрмерам путём ACL, пока он не замедлится ниже максимальной частоты. Если клиент прекращает попытки послать почту на время определённое параметром *p*, то определяется время, которое требуется для экспоненциального снижения частоты до 37% её пикового значения. Вы можете не работать время (число периодов сглаживания), которые клиент подвергается контрмерам после резкого превышения лимита, по этой формуле::

    ln(peakrate/maxrate)

Параметр **leaky** (по умолчанию) означает, что записи клиентской частоты не обновляются, если он превысил лимит. Эффект этого - что Exim измеряет среднюю частоту успешной отправки почты клиентом, которая не может быть больше максимума. Если клиент превышает лимит, он подвергнется контрмерам, но он всё ещё будет способен посылать почту с сконфигурированной максимальной частотой, вне зависимости от частоты его попыток. Это, в общем случае, - лучший выбор, если у вас есть клиенты с автоматическими повторами.


.. _ch40_39:

Использование ограничения частоты
---------------------------------

Другие средства ACL Exim'a используются чтобы задать, какие контрмеры предпринимаются, когда превышен лимит частоты. Это может быть что-то из записи в лог предупреждений (например, когда измеряется существующая частота отсылки для задания политики), через временные задержки, для замедления быстрых отправителей, до отклонения сообщений. Например::

    # Log all senders' rates

    warn ratelimit = 0 / 1h / strict
         log_message = Sender rate $sender_rate / $sender_rate_period

    # Slow down fast senders; note the need to truncate $sender_rate
    # at the decimal point.
    warn ratelimit = 100 / 1h / per_rcpt / strict
         delay     = ${eval: ${sg{$sender_rate}{[.].*}{}} - \
                       $sender_rate_limit }s

    # Keep authenticated users under control
    deny authenticated = *
         ratelimit = 100 / 1d / strict / $authenticated_id

    # System-wide rate limit
    defer message = Sorry, too busy. Try again later.
          ratelimit = 10 / 1s / $primary_hostname

    # Restrict incoming rate from each host, with a default
    # set using a macro and special cases looked up in a table.
    defer message = Sender rate exceeds $sender_rate_limit \
          messages per $sender_rate_period
          ratelimit = ${lookup {$sender_host_address} \
                        cdb {DB/ratelimits.cdb} \
                        {$value} {RATELIMIT} }


.. warning:: Если у вас нагруженный сервер, с большим количеством тестов **ratelimit**, особенно с параметром **per_rcpt**, вы можете пострадать от узкого места производительности, вызванного путём блокировок в БД подсказок ограничений частоты. Кроме создания мере сложных ACL, вы можете уменьшить проблему, путём использования RAM диска для директории подсказок Exim'a (обычно, */var/spool/exim/db/*). Однако, это означает, что Exim потеряет все свои подсказки после перезагрузки (включая подсказки повторов, кэш обратного вызова, и данные ограничения частоты).

.. _ch40_40:

Чтение данных **ratelimit** без обновления
------------------------------------------

Если в условии ACL **ratelimit** присутствует параметр **noupdate**, Exim вычисляет частоту и проверяет что лимит - нормальный, но не обновляет сохранённые данные. Это означает, что в соответствующих ACL возможно производить поиск по специфическому (или автоматически созданному) ключу без увеличения счётчика частоты отправления для этого ключа. Для того чтобы это было полезно, иные ACL должны установить частоту для того же самого ключа (иначе, она всегда будет ноль). Например::

    acl_check_connect:
      deny ratelimit = 100 / 5m / strict / per_cmd / noupdate
      log_message = RATE: $sender_rate/$sender_rate_period \
                    (max $sender_rate_limit)

      
    ... some other logic and tests...


    acl_check_mail:
      warn ratelimit = 100 / 5m / strict / per_cmd
      condition = ${if le{$sender_rate}{$sender_rate_limit}}
      logwrite  = RATE UPDATE: $sender_rate/$sender_rate_period \
                  (max $sender_rate_limit)

В этом примере, частота проверяется и используется для отказа в доступе (когда она слишком большая) в ACL “connect”, но реальный подсчёт запомненной частоты происходит позднее, базируясь на командах, в иной ACL.


.. _ch40_41:

Проверка адресов
----------------

Несколько условий **verify**, описанных в разделе :ref:`40.24 <ch40_24>`, вызывают проверку адреса. В разделе :ref:`40.45 <ch40_45>` обсуждаются отчёты о ошибках проверки адреса отправителя. Условия проверки могут сопровождаться параметрами модифицирующими процесс проверки. Параметры отделяются от ключевых слов и друг от друга слэшами, и, некоторые из них, содержат параметры. Например::

    verify = sender/callout
    verify = recipient/defer_ok/callout=10s,defer_ok

Первая стадия проверки адреса, которая всегда происходит, - это запуск адреса через маршрутизатор, в “режиме проверки” (“verify mode”). Маршрутизаторы могут определить различие между проверкой и маршрутизацией для доставки, и их действия могут быть множеством различных общих параметров, типа **verify** и **verify_only** (смотрите раздел :ref:`15 <ch15_00>`). Если маршрутизация неудачна, проверка неудачна. Доступные параметры таковы:

* Если задан параметр **callout**, успешная маршрутизация к одному или более удалённых хостов сопровождается “обратным вызовом” (“callout”) к тем же хостам, как дополнительная проверка. Обратные вызовы и их аргументы обсуждаются в следующей секции.

* Если при проверке маршрутизации происходит ошибка отсрочки, ACL, обычно, возвращает “defer”. Однако, если вы включаете **defer_ok** в параметр, вместо этого условие становится принудительно верным. Отметьте, что это - главная проверочный параметр, также как и аргументы для обратных вызовов.

* Параметр **no_details** описан в разделе :ref:`40.45 <ch40_45>`, в которой обсуждаются отчёты о неудаче проверки адреса отправителя.

* Параметр **success_on_redirect** приводит к тому, что проверка всегда успешна, немедленно после успешного редиректа. По умолчанию, если редирект создает лишь один адрес, этот адрес также проверяется. Дальнейшее обсуждение смотрите в разделе :ref:`40.46 <ch40_46>`.

После неудачи проверки адреса, $acl_verify_message содержит сообщение о ошибке, которое ассоциировано с ошибкой. Оно может быть сохранено, путём такого кодирования::

    warn  !verify = sender
          set acl_m0 = $acl_verify_message

Если вы пишете ваше собственное сообщение о отклонении, или сообщение в логи, когда отказано в доступе, вы можете использовать эту переменную для включения информации о ошибке проверки.

В дополнение, $sender_verify_failure или $recipient_verify_failure (соответственно), содержат одно из следующих слов:

* **qualify**: Адрес был неквалифицированный (без домена), и сообщение не являлось локальным или прибывшим со свободного хоста.
             
* **route**: Ошибка маршрутизации.
           
* **mail**: Маршрутизация успешна, и была предпринята попытка обратного вызова; отклонение произошло до команды MAIL (т.е. в начале соединения, HELO или MAIL).
          
* **recipient**: В обратном вызове была отклонена команда RCPT.
               
* **postmaster**: В обратном вызове была выполнена проверка постмастера.
                
Как ожидается, основным использованием этих переменных будет различение между отклонением MAIL и RCPT в обратных вызовах.

.. _ch40_42:

Проверка обратным вызовом
-------------------------

Для нелокальных адресов маршрутизация проверяет домен, но он неспособна сделать какую-либо проверку локальной части адреса. Есть ситуации, когда желательно какое-то средство проверки локальной части. Одним из способов это сделать, может быть создание SMTP *callback*, к хосту доставки для адреса отправителя, или *callforward* к последующему хосту для адреса получателя, чтобы увидеть, принимает ли хост адрес. Мы используем термин *callback* для охвата обоих случаев. Отметьте, что для адреса отправителя, обратный вызов - не к хосту клиента, который пытается доставить сообщение, а к одному из хостов, которые принимают входящую почту для домена отправителя.

Exim, по умолчанию, не производит обратных вызовов. Если вы хотите чтобы они происходили, вы должны запросить их, путём установки соответствующих параметров, в условии **verify**, как описано ниже. Это средство должно использоваться с осторожностью, поскольку оно может добавить много затрат ресурсов на проверку адреса. Однако, Exim кэширует результаты обратных вызовов, что помогает уменьшить их стоимость. Детали о кэшировании даны в разделе :ref:`40.44 <ch40_44>`.

Обратные вызовы для получателей, обычно используются лишь между хостами, которыми управляет один и тот же администратор. Например, корпоративный шлюз может использовать обратные вызовы для проверки допустимости получателей на внутреннем почтовом сервере. Успешный обратный вызов не гарантирует, что реальная доставка на адрес была бы успешной; с другой стороны, неудачный обратный вызов гарантирует, что доставка была бы неудачной.

Если параметр **callout** представлен в условии проверяющем адрес, вторая стадия проверки происходит если адрес успешно перенаправлен к одному или более удалённым хостам. Обычный случай - маршрутизация путём маршрутизатора **dnslookup** или **manualroute**, где маршрутизатор определяет хосты. Однако, если маршрутизатор который не устанавливал маршруты хостов в транспорте **smtp** с установкой **hosts**, используются хосты транспорта. Если в транспорте **smtp** установлена **hosts_override**, всегда используются её хосты, вне зависимости, предоставлен или нет, маршрутизатором, список хостов.

Используемый порт берётся из транспорта, если он задан, и это - удалённый транспорт. (Для маршрутизаторов, которые лишь делают проверку, транспорт не нужно задавать.) Иначе, используется порт SMTP по умолчанию. Если удалённый транспорт задаёт исходящий интерфейс, используется он; иначе - интерфейс не определён. Точно также, текст используемый для команды HELO берётся из транспортного параметра **helo_data**; если транспорта нет, используется значение $smtp_active_hostname.

Для проверки обратным вызовом отправителя, Exim создаёт SMTP-соединение к удалённому хосту, для проверки, может ли быть доставлен на адрес отправителя рикошет. Посылаются следующие SMTP-команды::

    HELO <local host name>
    MAIL FROM:<>
    RCPT TO:<the address to be tested>
    QUIT

Вместо HELO используется LHLO, если транспортный параметр **protocol** установлен в **lmtp**.

Проверка обратным вызовом получателя - подобна. По умолчанию, она также использует пустой адрес для отправителя. Такое значение по умолчанию выбрано потому, что большинство хостов не используют не используют адрес отправителя при проверка получателя. Использование тех же самых адресов - средство для использования одной записи в кэше для каждого получателя. Однако, некоторые сервера используют для проверки адрес отправителя. Они обслуживаются параметрами **use_sender** и **use_postmaster**, описанными в следующей секции.

Если ответ на команду RCPT - код 2xx, проверка успешна. Если - 5xx, проверка неудачна. Для любых других обстоятельств, Exim пробует следующий хост, если он есть. Если есть проблемы со всеми удалёнными хостами, ACL вернёт “defer”, если для параметра **callout** не дан параметр **defer_ok**, в случае чего - условие принудительно успешно.

Обратный вызов может занимать некоторое время. По этой причине, Exim, обычно, сбрасывает SMTP вывод до осуществления обратного вызова в ACL, для избежания неожиданных таймаутов у клиентов, когда используется расширение SMTP PIPELINING. Сброс вывода может быть отключен использованием модификатора **control** для установки **no_callout_flush**.

.. _ch40_43:

Дополнительные параметры для обратных вызовов
---------------------------------------------

Параметр **callout** может сопровождаться символом равно и несколькими необязательными параметрами, разделёнными запятыми. Например::

    verify = recipient/callout=10s,defer_ok

Старый синтаксис, имевший **callout_defer_ok** и **check_postmaster** как отдельные параметры проверки, оставлен для обратной совместимости, но его использование не приветствуется. Дополнительный параметры для **callout** таковы:

  **<a time interval>**
    Этим определяется интервал, который применяется к попытке обратного вызова к каждому хосту. Например:
    
    ::
    
        verify = sender/callout=5s

    По умолчанию, он - 30 секунд.  Таймаут используется для каждого ответа с удалённого хоста. Также он используется для инициации связи, если не перезадан путём параметра **connect**


  **connect = <time interval>**
    Этот параметр делает возможным установить различные (обычно, меньшие) таймауты для создания SMTP соединения. Например:
    
    ::  
    
        verify = sender/callout=5s,connect=1s

    Если не задано, то по умолчанию этот таймаут равен значению общего таймаута.

  **defer_ok**
    Когда этот параметр присутствует, ошибки соединения с любым хостом, или любые другие виды временных ошибок, обрабатываются как успех ACL. Однако, при таких обстоятельствах кэш не обновляется.

  **fullpostmaster**
    Этот параметр работает как и параметр **postmaster** (смотрите ниже), но если проверка на *postmaster@domain* неудачна, она пробует просто *postmaster*, без домена, в соответствии с спецификацией :rfc:`2821`. RFC заявляет, что неквалифицированный адрес *postmaster* должен быть принят.


  **mailfrom = <email address>**
    Когда проверка адресов в строках заголовков использует проверочный параметр **header_sender**, Exim, по умолчанию, ведёт себя как будто адреса - адреса отправителя из конверта. Проверка обратным вызовом, поэтому, проверяет может ли быть доставлен рикошет, путём использования пустого адреса в команде MAIL. Однако, спорно, что эти адреса никогда бы не могли бы использоваться как отправители конверта, и поэтому рикошеты (с пустым отправителем) могли быть правомерно отклонены. Параметр обратного вызова **mailfrom** позволяет вам определить, какой адрес использовать в команде MAIL. Например:

    ::

        require  verify = header_sender/callout=mailfrom=abcd@x.y.z

    Этот параметр доступен лишь в параметре **header_sender**.


  **maxwait = <time interval>**
    Этот параметр устанавливает полный таймаут для выполнения проверки обратным вызовом. Например:
    
    ::
    
        verify = sender/callout=5s,maxwait=30s

    По умолчанию, этот таймаут равен четырём таймаутам для индивидуальных SMTP-команд. Общий таймаут применяется когда существует более одного хоста, который можно попробовать. Таймаут проверяется до того как пробуется следующий хост. Это предотвращает очень большие задержки, если существует большое количество хостов, и у всех них таймаут (например, когда сетевой таймаут).


  **no_cache**
    Когда дан этот параметр, кэш обратных вызовов не читается и не обновляется.


  **postmaster**
    Когда установлен этот параметр, успешная проверка обратным вызовом сопровождается подобной проверкой на локальную часть *postmaster*, для того же самого домена. Если этот адрес отклоняется, обратный вызов - неудачен (но, смотрите **fullpostmaster**, выше). Результат проверки постмастера записывается в кэш; если она неудачна, это используется для неудачи следующего обратного вызова для домена, без создания соединения, пока не истечёт время записи в кэше.

  **postmaster_mailfrom = <email address>**
    По умолчанию, проверка постмастера использует в команде MAIL пустой адрес отправителя. Вы можете использовать этот параметр для проверки с использованием иного адреса. Например:
    
    ::
    
        require  verify = sender/callout=postmaster_mailfrom=abc@x.y.z



    Если представлены оба параметра - **postmaster** и **postmaster_mailfrom**, отвергается самая правая. Параметр **postmaster** эквивалентен этому примеру:
    
    ::
    
        require  verify = sender/callout=postmaster_mailfrom=


        
    .. warning:: Меры кэширования для проверки постмастера не принимают во внимание адрес отправителя. Предполагается, что будет использоваться пустой или фиксированный непустой адрес. Всё что Exim запоминает - что проверка постмастера для домена успешна или неудачна.

  **random**
    Когда установлен этот параметр, до обычной проверки обратным вызовом, Exim проверяет “случайную” локальную часть того же домена. Локальная часть в реальности не совсем случайна - она задаётся путём раскрытия параметра **callout_random_local_part**, которая по умолчанию такова::
    
        $primary_host_name-$tod_epoch-testing

    Идея состоит в том, чтобы попробовать определить, принимает ли удалённый хост все локальные части, без проверки. Если этот так, нет никакого смысла в выполнении обратного вызова для определённых локальных частей. Если проверка “random” успешна, результат сохраняется в записи кэша, и используется для принудительного успеха последующих проверок обратным вызовом, без создания соединения, до тех пор, пока не истечёт время жизни записи.

  **use_postmaster**
    Этот параметр применяется лишь к обратным вызовам проверки получателя. Например:
    
    ::
    
        deny  !verify = recipient/callout=use_postmaster

    Он вызывает использование в команде MAIL непустого адреса при выполнении обратного вызова проверки получателя, и, также, для проверки “random”, если она сконфигурирована. Локальная часть адреса - *postmaster*, и, домен - содержимое $qualify_domain.

  **use_sender**
    Этот параметр применяется лишь к обратным вызовам проверки получателя. Например:
    
    ::
    
        require  verify = recipient/callout=use_sender

    Он вызывает использование фактического адреса отправителя в команде MAIL, при проверке обратным вызовом, вместо пустого адреса. Нет необходимости использовать этот параметр, если вы не знаете, что вызываемые хосты используют отправителя при проверке получателя. Если её использовать неразборчиво, она уменьшает полноценность кэширования обратных вызовов.


Если вы используете любой параметр, который устанавливает непустого отправителя для команды MAIL (**mailfrom**, **postmaster_mailfrom**, **use_postmaster** или **use_sender**), вы должны подумать о возможных петлях. Проверка получателя, обычно, производится между двумя хостами, под одним и тем же управлением, и хост который получает обратный вызов - обычно не настраивается для непосредственного проведения обратного вызова. Поэтому, обычно, безопасно использовать **use_postmaster** или **use_sender** в этих случаях.

Однако, если вы используете непустой адрес отправителя для обратного вызова к произвольному хосту, есть вероятность, что удалённый хост сам инициирует обратный вызов к вашему хосту. Поскольку он проверяет отправителя сообщения, он, вероятно, будет использовать пустой адрес в MAIL, избегая петли обратных вызовов. Однако, в целях безопасности, лучше всего было бы настроить ваши собственные ACL, чтобы они не проводили проверку отправителя когда адрес получателя - адрес который вы используете для отправителя заголовка или проверки постмастера обратным вызовом.

Другая проблема, при использовании непустых отправителей для обратных вызовов - кэширование. Когда вы устанавливаете **mailfrom** или **use_sender**, в записях кэша в качестве ключа используется комбинация отправитель/получатель; таким образом, для любого данного получателя выполняется намного больше обратных вызовов, чем когда используется пустой отправитель, или постмастер.

.. _ch40_44:

Кэширование обратных вызовов
----------------------------

Exim кэширует результаты обратных вызовов с целью уменьшить количество используемых ресурсов, если не задан параметр **no_cache** с параметром **callout**. База данных подсказок, называемая “callout”, используется для кэша. Используются два различных типа записей: первые типы записей - результат проверок обратным вызовом для специфических адресов, и другие информационные записи - которые применяются ко всему домену (например, что он принимает локальную часть *postmaster*).

Когда оригинальный обратный вызов неудачен, дайтся детальное SMTP-сообщение о ошибке. Однако, для последующих ошибок, используются кэшированные данные, и это сообщение недоступно.

Время жизни для негативных и позитивных записей адресного кэша - независимы, и может быть установлено путём глобального параметра **callout_negative_expire** (значение по умолчанию - 2 часа) и **callout_positive_expire** (значение по умолчанию - 24 часа), соответственно.

Если хост даёт отрицательный ответ в SMTP-соединении, или отклоняет любую команду до и включительно

::

    MAIL FROM:<>

(но не включая команду MAIL с непустым адресом), любая попытка обратного вызова обязана стать неудачной. Exim помнит такие ошибки в записях кэша доменов, который используется для для неудачи обратных вызовов для домена, без создания нового соединения, пока не кончиться время жизни записи. Есть два отдельных времени окончания записей для кэша доменов: **callout_domain_negative_expire** (значение по умолчанию - три часа) и **callout_domain_positive_expire** (значение по умолчанию - семь дней).

Записи доменов истекают, когда достигается негативное время жизни, если обратный вызов не может быть сделан для домена, или если неудачна проверка постмастера. Иначе, они истекают по достижении времени истечения. Это гарантирует, например, что хост остановивший приём “случайных” локальных частей, в конечном счёте будет замечен.

Механизм кэширования обратных вызовов основан на домене проверяемого адреса. Если домен маршрутизируется к нескольким хостам, предполагается, что их поведение будет одинаковым.

.. _ch40_45:

Отчёты проверки адресов отправителя
-----------------------------------

Смотрите раздел :ref:`40.41 <ch40_41>` для общего обсуждения проверки. Когда проверка отправителя неудачна в ACL, детали о ошибке даются как дополнительные строки до 550-го ответа на релевантную SMTP-команду (RCPT или DATA). Например, если используется обратный вызов отправителя, вы могли бы видеть::

    MAIL FROM:<xyz@abc.example>
    250 OK
    RCPT TO:<pqr@def.example>
    550-Verification failed for <xyz@abc.example>
    550-Called:   192.168.34.43
    550-Sent:     RCPT TO:<xyz@abc.example>
    550-Response: 550 Unknown local part xyz in <xyz@abc.example>
    550 Sender verification failed

Если таким же образом была неудачна более чем одна команда RCPT, делали даются лишь для первой из них. Однако, некоторые администраторы не хотят отсылать об этом слишком много информации. Вы можете подавить детализацию путём добавления “/no_details” к утверждению ACL которое запрашивает проверку отправителя. Например::

    verify = sender/no_details

.. _ch40_46:

Проверка при переадресации
--------------------------

Возникает дилемма, когда локальный адрес переадресуется путём перенаправления или подстановки синонима во время проверки: должны ли быть проверены созданные адреса, или успешного раскрытия оригинального адреса достаточно, для подтверждения? По умолчанию, Exim выбирает следующий прагматический подход:

* Когда входящий адрес переадресован лишь к одному дочернему адресу, проверка продолжается с дочерним адресом, и если проверка неудачна, оригинальная проверка также неудачна.

* Когда входящий адрес переадресован более чем к одному дочернему адресу, проверка не продолжается. Возвращается успешный результат.

Это кажется наиболее разумным поведением для общего использования подстановки синонима, как способ переадресации различных локальных частей к тому же самому почтовому ящику. Это означает, например, что пара записей синонимов вида
  
  ::
  
      A.Wol:   aw123
      aw123:   :fail: Gone away, no forwarding address
  
работает как ожидается, вызывая ошибку с обоими локальными частями. Когда переадресация создает более одного адреса, поведение больше походит список рассылки, где существования синонима достаточно для успешности проверки.

Однако, возможно изменить поведение по умолчанию так, что все успешные переадресации считаются как успешная проверка, однако создается много новых адресов. Это определено путём проверочного параметра **success_on_redirect**. Например::

    require verify = recipient/success_on_redirect/callout=10s

В этом примере, проверка успешна, если маршрутизатор создает новый адрес, и обратный вызов не происходит, поскольку никакой адрес не маршрутизируется на удалённый хост.

Когда проверка тестируется параметром **-bv**, обработка переалресация производится также, за исключением случаев когда также задан параметр **-v** командной строки или иной параметр отладки. В этом случае, происходит полная проверка для каждого порождённого адреса и выводится отчёт для каждого из них.

.. _ch40_47:

Клиентская SMTP-авторизация (CSA)
---------------------------------

Клиентская SMTP-авторизация - система, которая позволяет сайту давать объявление, каким машинам можно, и каким нельзя посылать электронную почту. Это делается путём помещения специальной SRV записи в DNS; она ищется используя домен из HELO клиента. Во время записи (видимо - когда писался этот текст) - всё ещё черновик интернета. Клиентская SMTP-авторизация выполняется в Exim'e путём условия ACL::

    verify = csa

Оно неудачно, если клиент неавторизован. Если существует проблема в DNS, или не найдена действительная CSA SRV запись, или если клиент - авторизован, условие успешно. Эти три случая можно различить используя переменную раскрытия $csa_status, которая может принимать одно из значений “fail”, “defer”, “unknown”, или “ok”. Условие, самостоятельно, не отсрочивает доставку, поскольку, вероятно, это вызвало бы проблемы для законной почты.

Сообщения о ошибках производимые кодом CSA включают немного больше деталей. Если $csa_status - “defer”, это может быть потому, что проблемы при поиске записи CSA SRV, или проблемы поиска целевой записи CSA. Есть четыре причины, чтобы $csa_status был “fail”:

* Клиентское имя хоста явно не авторизовано.
* IP адрес клиента не совпадает с какими-либо целевыми IP-адресами CSA.
* Клиентское имя хоста авторизовано, но у него нет допустимых IP-адресов (например, целевые адреса - IPv6 и клиент использует IPv4).
* Клиентское имя хоста не имеет записи CSA SRV, но родительский домен явно утверждает, что все поддомены должны быть явно разрешены.

Условие проверки CSA может принимать аргумент, являющейся доменом для использования в запроса DNS. Значение по умолчанию::

    verify = csa/$sender_helo_name

Это воплощение включает расширение к CSA. Если запрос домена - буквальный адрес, типа [192.0.2.95], или если это голый IP-адрес, Exim ищет записи записи  в обратных DNS, как будто домен HELO был (например) *95.2.0.192.in-addr.arpa*. Поэтому, это значит сказать::

    verify = csa/$sender_host_address

Фактически, это проверка, выполняемая Exim'ом если клиент не сказал HELO. Это расширение может быть отключено путём установки параметра, в главной конфигурации, **dns_csa_use_reverse**, в ложь.

Если непосредственно для домена не найдена запись CSA SRV, поиск выполняется через его родительские домены для записи, которая могла бы сделать утверждение о субдоменах. Максимальная глубина этого поиска ограничена используя параметр главной конфигурации **dns_csa_search_limit**, которая по умолчанию равна 5. Exim не ищет CSA SRV в домене верхнего уровня, таким образом, установка по умолчанию обработки домена HELO - семь (*hostname.five.four.three.two.one.com*). Это охватывает большинство легитимных доменов HELO.

Поиск *dnsdb* также имеет поддержку для CSA. Хотя *dnsdb*, также, поддерживает прямые поиски SRV, этого недостаточно из-за поведения высшего домена для для поиска CSA, и (как с поисками PTR) *dnsdb* также превращает IP-адреса в поиске в обратном пространстве DNS. Результат успешного поиска, типа::

    ${lookup dnsdb {csa=$sender_helo_name}}

имеет два поля разделённых пробелами: Код авторизации, и имя целевого хоста. Авторизационный код может быть “Y” - для yes, “N” - для no, “X” - для явно требуемого разрешения, но отсутствия, или “?” - для неизвестного.

.. _ch40_48:

Проверка тега адреса рикошета
-----------------------------

Проверка тега адреса рикошета (Bounce address tag validation - BATV), это схема, посредством которой отправители конверта исходящего сообщения имеют добавленный к ним “tag” - шифрованный, с меткой времени. Подлинные входящие рикошеты всегда должны быть адресованы получателям,, которые имеют действительный тег. Эта схема - способ детектировать нежелательные рикошеты, вызванные подделкой адреса (часто называемые “сопутствующий спам”), поскольку получатели таких сообщений не содержат в себе действительный тег.

Есть два элемента раскрытия для помощи в реализации схемы BATV “prvs” (частная подпись - private signature) в конфигурации Exim'a. Эта схема подписывает оригинальный адрес отправителя конверта путём использования простого ключа для добавления хэша адреса и некоторой, основанной на времени случайной информации. Элемент раскрытия **prvs** создаёт подписанный адрес, и элемент раскрытия **prvscheck** проверяет его. Синтаксис этих пунктов описан в разделе :ref:`11.5 <ch11_05>`.

Как пример, предположим, что секретные ключи (по ключу на адрес) были сохранены в БД MySQL. Запрос для поиска ключа для адреса мог быть определён макросом типа этого::

    PRVSCHECK_SQL = ${lookup mysql{SELECT secret FROM batv_prvs \
                    WHERE sender='${quote_mysql:$prvscheck_address}'\
                    }{$value}}

Предположим, также, что отправители использующие BATV заданы списком адресов называемым **batv_senders**. Тогда, в ACL для команд RCPT вы могли бы использовать это::

    # Bounces: drop unsigned addresses for BATV senders
    deny message = This address does not send an unsigned reverse path
         senders = :
         recipients = +batv_senders

    # Bounces: In case of prvs-signed address, check signature.
    deny message = Invalid reverse path signature.
         senders = :
         condition  = ${prvscheck {$local_part@$domain}\
                      {PRVSCHECK_SQL}{1}}
         !condition = $prvscheck_result


Первое утверждение отклоняет получателей для рикошетов, которые адресованы простым адресам отправителей BATV, поскольку известно, что отправители  BATV не отсылают сообщения с открытым адресом отправителя. Второе утверждение отклоняет получателей которые подписаны prvs, но с неверными сигнатурами (или потому что неверный ключ, или произошёл таймаут сигнатуры).

Адреса, не подписанные prvs, не отклоняются вторым утверждением, поскольку раскрытие **prvscheck** приносит пустую строку, если его первый аргумент не prvs-подписанный адрес, вызывая, таким образом, что условие **condition** становится ложным. Если первый аргумент - синтаксически верный prvs-подписанный адрес, возвращается третья строка (в этом случае - “1”), независимо от успеха проверок шифрования и таймаута. Переменная $prvscheck_result содержит результат проверок (пустая - для ошибки, “1” - для успеха).

Есть ещё одна проблема, которую вы должны рассмотреть при осуществлении prvs-подписей: вы должны гарантировать, что маршрутизаторы примут prvs-подписанный адрес и корректно его доставят. Простой способ обработки этого - использование маршрутизатора **redirect** для удаления сигнатуры с конфигурацией типа такой::

    batv_redirect:
      driver = redirect
      data = ${prvscheck {$local_part@$domain}{PRVSCHECK_SQL}}

Это работает потому, что если третий аргумент **prvscheck** - пустой, результат раскрытия prvs-подписанного адреса - декодированное значение оригинального адреса. Этот маршрутизатор, вероятно, должен быть первым в ваших маршрутизаторах, которые обрабатывают локальные адреса.

Для создания BATV-подписанного адреса в первом месте, может использоваться транспорт такой формы::

    external_smtp_batv:
      driver = smtp
      return_path = ${prvs {$return_path} \
                    {${lookup mysql{SELECT \
                    secret FROM batv_prvs WHERE \
                    sender='${quote_mysql:$sender_address}'} \
                    {$value}fail}}}

Если для существующего пути возврата ключ не может быть найден, подписывания не происходит.

.. _ch40_49:

Использование ACL для управления передачей
------------------------------------------

MTA, как говорят, передает (relay) сообщение, если оно передаётся с некоторого хоста, и непосредственно доставляется на другой хост, как результат удалённого адреса содержавшегося в нём. Переадресация локальных частей через файл перенаправлений и синонимов, и, затем, передача сообщения на другой хост - не передача, но редирект в результате обработки символа процента (“percent hack”).

Существует два вида передачи, которые называют “incoming” и “outgoing”. Хост, действующий как шлюз, или резервный MX - имеет отношение ко входящей передаче, от произвольных хостов к специфически установленным доменам. С другой стороны, хост, выступающий в роли умного хоста для множества клиентов, имеет отношение к исходящей передаче от этих клиентов ко всему интернету. Часто, некоторые хосты выполняют обе функции, но, в принципе, эти два вида передачи полностью независимы. То, что не требуется - передача почты с произвольного удалённого хоста через вашу систему к произвольным доменам.

Вы можете осуществить контроль передачи путём подходящих утверждений ACL, которые выполняются для каждой команды RCPT. Для удобства, часто, самое лёгкое, использовать средство именованного списка Exim'a, для задания вовлечённых доменов и хостов. Например, предположим, что вы хотите следующее:

* Доставлять множество доменов в почтовые ящики локального хоста (или локально обрабатывать их каким-то другим способом). Скажем, они - *my.dom1.example* и *my.dom2.example*.
* Передача почты для множества других доменов, для которых вы являетесь вторичным MX. Это могли бы быть *friend1.example* и *friend2.example*.
* Передавать почту от хостов в вашей локальной LAN, к любым вовлечённым доменам. Предположим, ваша LAN - 192.168.45.0/24.

В главной части конфигурации, вы помещаете следующие определения::

    domainlist local_domains = my.dom1.example : my.dom2.example
    domainlist relay_domains = friend1.example : friend2.example
    hostlist   relay_hosts   = 192.168.45.0/24

    Теперь вы можете использовать эти определения в ACL, работающих для каждой команды RCPT::
    
        acl_check_rcpt:
          accept domains = +local_domains : +relay_domains
          accept hosts   = +relay_hosts



Первое утверждение принимает любую команду RCPT, которая содержит адрес в локальном или релейном домене. Для любых других доменов, управление передаётся второму утверждению, которое принимает команды, лишь если они приходят с релейных хостов. Практически, вы, вероятно, захотите создать свою, более сложную ACL чем эта, например, путём включения отправителя и проверки получателя. Конфигурация по умолчанию включает более всесторонний пример, который описан в главе :ref:`7 <ch07_00>`.

.. _ch40_50:

Проверка конфигурации передачи
------------------------------

Вы можете проверить характеристики передачи вашей конфигурации таким же образом, как и проверяете поведение любой ACL для входящих SMTP-подключений, путём использования параметра **-bh** командной строки, для запуска поддельной SMTP-сессии, с которой вы взаимодействуете.

Для особого тестирования на нежелательную передачу, хост *relay-test.mail-abuse.org* предоставляет полезный сервис. Если вы подключитесь по telnet на этот хост с хоста на котором запущен Exim, используя обычный порт telnet, вы увидите обычное сообщение о соединении telnet, и, затем, довольно долгая задержка. Будьте терпеливы. Удалённый хост создаёт SMTP-соединение обратно на ваш хост, и пробует множество обычных исследований на тестирование уязвимости - открытая передача. Результаты тестов, в конечном счёте, появятся на вашем терминале.


.. [#] в смысле - меньше букавок набирать - прим. lissyara
.. [#] имеется ввиду - сообщения уходят вникуда - прим. lissyara
.. [#] в данном абзаце - есть разница между числом принятых команд и числом принятых получателей, поскольку получатель может не существовать - тогда команда RCPT принята, а вот получатель - нет. - прим. lissyara
.. [#] с последними версиями Exim'a - прим. переводчика
