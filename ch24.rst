
.. _ch24_00:

Общие параметры для транспортов
===============================

Следующие общие параметры применяются ко всем транспортам:

.. index::
   pair: transports; body_only 

=============  ===============  =============  ==============
**body_only**  Use: transports  Type: boolean  Default: false
=============  ===============  =============  ==============

Если этот параметр установлена, заголовки сообщения не транспортируются. Этот параметр взаимоисключающая с **headers_only**. Если она используется с транспортом **appendfile** или **pipe**, должны быть проверены установки **message_prefix** и **message_suffix**, поскольку этот параметр не подавляет их автоматически.

.. index::
   pair: transports; current_directory

=====================  ===============  =============  ==============
**current_directory**  Use: transports  Type: string†  Default: unset
=====================  ===============  =============  ==============

Этот параметр определяет текущую директорию, которая должна быть установлена при работе транспорта, замещая любое значение, которое могло быть установлено маршрутизатором. Если раскрытие неудачно по какой-либо причине, включая принудительную неудачу, ошибка записывается в лог и доставка задерживается.

.. index::
   pair: transports; disable_logging

===================  ===============  =============  ==============
**disable_logging**  Use: transports  Type: boolean  Default: false
===================  ===============  =============  ==============

Если этот параметр установлен в истину, ничего не записывается в лог ни для каких доставок транспортом, и никакие ошибки в логи не пишутся. Вы не должны устанавливать этот параметр, если не понимаете что делаете.

.. index::
   pair: transports; debug_print

===============  ===============  =============  ==============
**debug_print**  Use: transports  Type: string†  Default: unset
===============  ===============  =============  ==============

Если этот параметр установлен и отладка включена (смотрите параметр командной строки **-d**), строка раскрывается и включается в отладочный вывод, при работе транспорта. Если раскрытие строки неудачно, сообщение о ошибке пишется в отладочный вывод, и Exim продолжает обработку. Это средство предоставлено для помощи при проверке значений переменных и т.п. при отладке конфигурации драйвера. Например, если некорректно работает параметр **headers_add**, **debug_print** может быть использована для вывода зависимых переменных. В текст добавляется символ новой строки, если он им не заканчивается.

.. index::
   pair: transports; delivery_date_add

=====================  ===============  =============  ==============
**delivery_date_add**  Use: transports  Type: boolean  Default: false
=====================  ===============  =============  ==============

Если этот параметр истинна, в сообщение добавляется заголовок “Delivery-date:”. Это даёт актуальное время, когда произошла доставка. Это не стандартный заголовок, у Exim'a есть параметр конфигурации (**delivery_date_remove**), запрашивающая его удаление из из входящих сообщений, таким образом, доставленные сообщения можно безопасно пересылать другим получателям.

.. index::
   pair: transports; driver

==========  ===============  ============  ==============
**driver**  Use: transports  Type: string  Default: unset
==========  ===============  ============  ==============

Этим определяется, который из доступных транспортных драйверов будет использоваться. Тут нет значения по умолчанию, и этот параметр должен быть установлен для каждого транспорта.

.. index::
   pair: transports; envelope_to_add

===================  ===============  =============  ==============
**envelope_to_add**  Use: transports  Type: boolean  Default: false
===================  ===============  =============  ==============

Если этот параметр истинна, в сообщение добавляется заголовок “Envelope-to:”. Этим даётся оригинальный адрес (или адреса) во входящем конверте, который вызвал эту доставку. Может быть представлено более одного адреса, если транспорт сконфигурирован для обработки сразу нескольких адресов, или к одному финальному адресу было переадресовано более одного адреса. Это не стандартный заголовок, у Exim'a есть параметр конфигурации (**envelope_to_remove**), запрашивающая его удаление из из входящих сообщений, таким образом, доставленные сообщения можно безопасно пересылать другим получателям.

.. index::
   pair: transports; group 

=========  ===============  =============  ===================
**group**  Use: transports  Type: string†  Default: Exim group
=========  ===============  =============  ===================

Этот параметр задаёт gid для выполнения транспортного процесса, замещая любое значение переданное из маршрутизатора, и, также, замещая любое значение ассоциированное с **user** (смотрите ниже).

.. index::
   pair: transports; headers_add

===============  ===============  =============  ==============
**headers_add**  Use: transports  Type: string†  Default: unset
===============  ===============  =============  ==============

Этот параметр определяет строку текста, который раскрывается и добавляется в заголовочную часть сообщения при транспортировке, как описано в разделе :ref:`44.17 <ch44_17>`. Также, дополнительные строки заголовков, могут быть заданы маршрутизаторами. Если результат раскрытия - пустая строка, или раскрытие принудительно неудачно - никаких действий не предпринимается. Другие ошибки раскрытия обрабатываются как ошибки, и вызывают задержку доставки.

.. index::
   pair: transports; headers_only

================  ===============  =============  ==============
**headers_only**  Use: transports  Type: boolean  Default: false
================  ===============  =============  ==============

Если этот параметр установлен, тело сообщения не транспортируется. Этот параметр взаимоисключаем с **body_only**. Если она используется с транспортом **appendfile** или **pipe**, должны быть проверены установки **message_prefix** и **message_suffix**, поскольку этот параметр не подавляет их автоматически.

.. index::
   pair: transports; headers_remove

==================  ===============  =============  ==============
**headers_remove**  Use: transports  Type: string†  Default: unset
==================  ===============  =============  ==============

Этот параметр определяет строку текста, который раскрывается в список имён заголовков; эти заголовки опускаются [#]_ из сообщения при транспортировке, как описано в разделе :ref:`44.17 <ch44_17>`. Также, удаление заголовка, может быть задано маршрутизатором. Если результат раскрытия - пустая строка, или раскрытие принудительно неудачно - никаких действий не предпринимается. Другие ошибки раскрытия обрабатываются как ошибки, и вызывают задержку доставки.

.. index::
   pair: transports; headers_rewrite

===================  ===============  ============  ==============
**headers_rewrite**  Use: transports  Type: string  Default: unset
===================  ===============  ============  ==============

Этот параметр позволяет перезаписывать адреса в строках заголовков во время транспортировки, т.е. когда сообщение копируется в его место назначения. Содержимое параметра - список правил перезаписи, разделённых двоеточиями. Каждое правило - в той же самое форме, что и общие правила перезаписи применяемые при передаче сообщения. Они описаны в главе :ref:`31 <ch31_00>`. Например,

::
 
    headers_rewrite = a@b c@d f : \
                      x@y w@z

заменит “a@b” на “c@d” в строке заголовка “From:”, и “x@y” на “w@z” - во всех строках заголовков содержащих адрес. Правила применяются к строкам заголовков сразу перед их передачей при транспортировке, таким образом, они затрагивают лишь те копии сообщений, которые проходят через транспорт. Однако, перезаписываются лишь оригинальные строки заголовков, и те, которые были добавлены системным фильтром. Если маршрутизатор или транспорт добавляет строки заголовков, они не затрагиваются этим параметром. Эти правила перезаписи не применяются к конверту. Вы можете изменить обратный путь используя параметр **return_path**, но в этот момент обработки сообщения вы не можете изменить получателей конверта.

.. index::
   pair: transports; home_directory

==================  ===============  =============  ==============
**home_directory**  Use: transports  Type: string†  Default: unset
==================  ===============  =============  ==============

Этот параметр определяет установку домашней директории для локального транспорта, замещая любое значение, которое может быть установлено маршрутизатором. Домашняя директория помещается в $home, при раскрытии частных параметров транспорта. Она также используется как текущая директория, если текущая директория не установлена в транспорте параметром **current_directory**, или параметром маршрутизатора **transport_current_directory**. Если раскрытие неудачно по какой-либо причине, включая принудительную неудачу, ошибка записывается в лог, и доставка задерживается.

.. index::
   pair: transports; initgroups

==============  ===============  =============  ==============
**initgroups**  Use: transports  Type: boolean  Default: false
==============  ===============  =============  ==============

Если этот параметр истинна, и uid процесса доставки предоставлен транспортом, при работе транспорта вызывается функция *initgroups()*, для гарантии, что любые группы, связанные с uid установлены.

.. index::
   pair: transports; message_size_limit

======================  ===============  =============  ==========
**message_size_limit**  Use: transports  Type: string†  Default: 0
======================  ===============  =============  ==========

Этот параметр контролирует размер сообщений, проходящих через транспорт. Она раскрывается до использования; результат раскрытия должен быть последовательностью десятичных цифр, необязательно сопровождаемых “K” или “M”. Если раскрытие неудачно по какой-либо причине, включая принудительную неудачу, или результат не имеет необходимую форму [#]_, доставка задерживается. Если значение больше нуля, и размер сообщения больше этого значения, адрес неудачен. Если есть какой-то шанс, что результирующий рикошет будет маршрутизирован на тот же самый транспорт, вы должны гарантировать, что **return_size_limit** меньше чем **message_size_limit** транспорта, иначе будет невозможно доставить рикошет.

.. index::
   pair: transports; rcpt_include_affixes

========================  ===============  =============  ==============
**rcpt_include_affixes**  Use: transports  Type: boolean  Default: false
========================  ===============  =============  ==============

Когда этот параметр ложь (по умолчанию), и адрес, имевший любые аффиксы (префиксы или суффиксы) удалённые из локальной части, доставляется любой формой SMTP или LMTP, аффиксы не включаются. Например, если маршрутизатор содержит

::

    local_part_prefix = *-

маршрутизирует адрес “abc-xyz@some.domain” на SMTP-транспорт, конверт доставляется с

::

    RCPT TO:<xyz@some.domain>

Это также происходит, когда во время ACL для проверки адреса получателя используется обратный вызов. Однако, если **rcpt_include_affixes** установлена в истину, в команду RCPT включается полная локальная часть. Этот параметр применяется к доставкам BSMTP через транспорты **appendfile** и **pipe**, также как и к транспортам **lmtp** и **smtp**.

.. index::
   pair: transports; retry_use_local_part

========================  ===============  =============  ==================
**retry_use_local_part**  Use: transports  Type: boolean  Default: see below
========================  ===============  =============  ==================

Когда происходит временная ошибка доставки, в БД подсказок Exim'a создаётся отчёт повтора. Для удалённых доставок, ключ для записи повтора основан на имени и/или IP-адресе хоста вызывающего ошибку. Для локальных доставок, ключ, обычно, - весь адрес, включая локальную часть и домен. Это подходит для большинства общих случаев временных ошибок локальной доставки - например, превышение квоты почтового ящика, должно вызывать задержку доставки лишь в почтовый ящик с превышением, а не на весь домен.

Однако, в некоторых специальных случаях, у вас может возникнуть необходимость обработать локальную ошибку доставки как ассоциированную с доменом, а не со специфической локальной частью. (Например, если вы храните всю почту какого-то домена в файлах.) Вы можете это сделать путём установки **retry_use_local_part** в ложь.

Для всех локальных транспортов, его значение по умолчанию - истина. Для удалённых транспортов, значение по умолчанию - ложь, в целях опрятности, но изменение значения не оказывает никакого эффекта на удалённый транспорт, в текущей реализации [#]_ .

.. index::
   pair: transports; return_path

===============  ===============  =============  ==============
**return_path**  Use: transports  Type: string†  Default: unset
===============  ===============  =============  ==============

Если этот параметр задан, строка раскрывается во время транспортировки, и заменяет значение существующего обратного пути (отправителя конверта), в копии доставляемого сообщения. Пустой путь возврата допускается. Эта возможность спроектирована для удалённых доставок, где значение этого параметра используется в команде SMTP MAIL. Если вы установите “return_path” для локального транспорта, будет единственный эффект - измениться адрес, помещаемый в строку заголовка “Return-path:”, если она добавляется к сообщению (смотрите следующий параметр).

.. note:: Изменение пути возврата не записывается в лог, за исключением случая что вы добавили **return_path_on_delivery** в список записываемых в лог объектов.

Раскрытие может обратиться к существующему значению через $return_path. Оно является отправителем конверта сообщения, или адресом, установленным параметром маршрутизатора **errors_to**. Если раскрытие принудительно неудачно, замена не происходит; если неудача по другой причине, доставка задерживается. Этот параметр может использоваться для поддержки VERP (Variable Envelope Return Paths) (переменные пути возврата конверта) - смотрите раздел :ref:`47.6 <ch47_06>`.

.. note:: Если ошибка доставки детектируется локально, включая случай, когда удалённый сервер отклоняет сообщение во время SMTP диалога, рикошет не посылается по значению этого параметра. Он шлётся по ранее установленному адресу для ошибок. Это значение по умолчанию для входящих адресов отправителя, но оно может быть изменено путём установки параметра **errors_to** в маршрутизаторе.

.. index::
   pair: transports; return_path_add

===================  ===============  =============  ==============
**return_path_add**  Use: transports  Type: boolean  Default: false
===================  ===============  =============  ==============

Если этот параметр истинна, к сообщению добавляется заголовок “Return-path:”. Хотя пути возврата, обычно, доступны в строке префикса BSD-майлбокса, обычно они не отображаются MUA, и таким образом, пользователь не имеет к ним лёгкого доступа.

:rfc:`2821` заявляет, что строка заголовка “Return-path:” добавляется к сообщению “когда доставляющий SMTP-сервер делает финальную доставку”. Это подразумевает, что этот заголовок не должен содержаться во входящих сообщениях. У Exim'a есть параметр конфигурации, **return_path_remove**, которая запрашивает удаление этого заголовка из входящих сообщений, таким образом, доставленные сообщения, могут быть безопасно пересланы другим получателям.

.. index::
   pair: transports; shadow_condition

====================  ===============  =============  ==============
**shadow_condition**  Use: transports  Type: string†  Default: unset
====================  ===============  =============  ==============

Смотрите ниже, параметр **shadow_transport**.

.. index::
   pair: transports; shadow_transport

====================  ===============  ============  ==============
**shadow_transport**  Use: transports  Type: string  Default: unset
====================  ===============  ============  ==============

Локальный транспорт может установить параметр **shadow_transport** в имя иного локального транспорта. Удалённые теневые доставки не поддерживаются.

Каждый раз, когда доставка на главный транспорт успешна, и или не задан параметр **shadow_transport**, или его раскрытие не приводит к пустой строке, или одной из строк “0” или “no” или “false”, сообщение, также передаётся теневому транспорту, с тем же самым адресом для доставки. Если раскрытие неудачно, никаких действий не предпринимается, исключая принудительное раскрытие, вызывающее запись в лог файл.

Результат теневого транспорта отбрасывается, и не затрагивает последующую обработку сообщения. Предоставлен лишь один теневой уровень; параметр **shadow_transport** игнорируется в любом транспорте, выполняемом как теневой. Параметры, связанные с выводом из труб (pipe) также игнорируются. Строки логов для успешной доставки имеют в конце добавленный элемент, вида

::

    ST=<shadow transport name>

Если теневой транспорт неуспешен, сообщение об ошибке помещается в конце, в круглых скобках. Теневой транспорт может использоваться для множества различных целей, включая сохранение более детализированной лог-информации, чем обычно предоставляет Exim, и осуществления автоматической политики подтверждения, основанной на заголовках, требуемой некотрыми серверами.

.. index::
   pair: transports; transport_filter

====================  ===============  =============  ==============
**transport_filter**  Use: transports  Type: string†  Default: unset
====================  ===============  =============  ==============

Этот параметр устанавливает процесс фильтрации (в смысле UNIX-шелла) для сообщений, во время транспортировки. Это не должно быть спутано с почтовой фильтрацией устанавливаемой пользователями индивидуально, или через системный фильтр.

Перед выходом сообщения из транспорта, команда, заданная в **transport_filter** запускается в отдельном, параллельном процессе, и всё сообщение целиком, включая строки заголовков, передаётся ему на стандартный ввод (фактически, это делается от третьего процесса, во избежание тупиков). Команда должна быть задана как абсолютный путь.

Строки сообщения, записываемые в транспортный фильтр, завершаются символом новой строки (“\n”). Сообщение передаётся фильтру до любых SMTP-специфичных обработок, типа преобразования “\n” в “\r\n” и экранирования строк начинающихся с точки, и, также, до любой обработки подразумеваемой параметрами **check_string** и **escape_string** в транспортах **appendfile** или **pipe**.

Стандартные ошибки для процесса фильтра устанавливается в то же самое место назначение, что и стандартный вывод; они читаются и пишутся в окончательное место назначение сообщения. Процесс, который пишет сообщение в фильтр, сам фильтр, и оригинальный процесс, читающий результат и доставляющий его, работают параллельно, как передача через трубы (pipeline) шелла.

Фильтр может выполнить любые преобразования, какие захочет, но, разумеется, необходимо позаботится о том, чтобы не нарушить синтаксис :rfc:`2822`. Exim не проверяет результат, кроме проверки заключительного символа новой строки, когда используется SMTP. Все сообщения, передаваемые через SMTP, должны завершаться символом новой строки, таким образом, Exim подставляет его, при его отсутствии.

Транспортный фильтр может использоваться для проведения сканирования содержания на основе пользователей [#]_ во время доставки, если единственный эффект от сканирования - модификация сообщения. Например, сканирование содержания может вставлять новую строку заголовка, содержащую очки насчитанные за спам. Это могло бы быть интерпретировано фильтром в пользовательском MUA. На данном этапе, невозможно отказаться от сообщения.

Могут возникнуть проблемы, если фильтр увеличивает размер сообщения, пересылаемого по SMTP соединению. Если принимающий SMTP-сервер указал поддержку параметра SIZE, Exim пошлёт размер сообщения в начале SMTP-сессии. Если то, что фактически посылается, значительно больше, сервер может отклонить сообщение. Этого можно избежать путём установки параметра **size_addition** в транспорте **smtp**, или разрешить дополнения к сообщению, или вообще отключив использование SIZE.

Значение параметра **transport_filter** - строка команды для запуска фильтра, выполняемого непосредственно из Exim'a, а не из шелла. Строка обрабатывается Exim`ом точно таким же образом, как командная строка для транспорта **pipe**: Exim разбирает её на аргументы, а затем раскрывает каждый параметр отдельно (смотрите раздел :ref:`29.3 <ch29_03>`). Любой вид ошибки раскрытия, вызывает задержку доставки. Специальный параметр - $pipe_addresses заменяется аргументами, по одному на каждый доставляемый адрес. (Это не идеальное название для этой особенности, но, поскольку оно уже было реализовано для транспорта **pipe**, показалось разумным не изменять этого.)

Когда хост удалённый, доступны переменные раскрытия $host и $host_address. Они содержат имя и IP-адрес хоста, на который посылается сообщение. например::

    transport_filter = /some/directory/transport-filter.pl \
      $host $host_address $sender_address $pipe_addresses

Если вы хотите использовать более сложные элементы раскрытия для создания команд транспортного фильтра, возникают две проблемы, обе - вследствие того, что команда разделяется *до* раскрытия.

* Если раскрытие элемента содержит пробелы, вы должны экранировать их кавычками, что это вся команда. Если весь параметр - один элемент раскрытия, вы должны учесть, какие кавычки вы используете. Например::
  
      transport_filter = '/bin/cmd${if eq{$host}{a.b.c}{1}{2}}'
      
  Этим выполняется команда */bin/cmd1*, если имя хоста “a.b.c”, и */bin/cmd2* в ином случае. Если бы использовались двойные кавычки, то они бы удалились Exim`ом при чтении значения параметра. Когда используется значение, если бы отсутствовали одиночные кавычки, строка была бы разбита на два пункта - ``/bin/cmd${if`` и ``eq{$host}{a.b.c}{1}{2}``, и произошла бы ошибка при попытке Exim'a раскрыть первый элемент.

* За исключением специального случая - $pipe_addresses, упомянутого выше, раскрытие не может создавать несколько параметров, или имя команды сопровождаемое параметрами. Рассмотрите этот пример::
  
      transport_filter = ${lookup{$host}lsearch{/a/file}\
                          {$value}{/bin/cat}}

  Результат поиска интерпретируется как имя команды, даже если он содержит пустое пространство. Самый простой путь для обхода этого состоит в использовании shell::
  
      transport_filter = /bin/sh -c ${lookup{$host}lsearch{/a/file}\
                                     {$value}{/bin/cat}}


Процесс фильтра работает под теми же gid и uid что и нормальный процесс доставки. Для удалённых доставок, по умолчанию, это - gid/uid пользователя Exim'a. Обычно, команда должна приводить к нулевому коду возврата. Ожидается, что транспортные фильтры всегда успешны. Код, отличный от нуля, означает, что транспортный фильтр столкнулся с какой-то серьёзной проблемой. Доставка сообщения задерживается; сообщение остаётся в очереди и пробуется позже. Невозможно вызывать рикошет из транспортного фильтра.

Если транспортный фильтр установлен на транспорте **autoreply**, оригинальное сообщение передаётся через фильтр, поскольку оно копируется в новое созданное сообщение, что случается, если установлен параметр **return_message**.

.. index::
   pair: transports; transport_filter_timeout

============================  ===============  ==========  ===========
**transport_filter_timeout**  Use: transports  Type: time  Default: 5m
============================  ===============  ==========  ===========

Когда Exim читает вывод транспортного фильтра, он применяет таймаут, который может быть установлен этого параметра. Превышение таймаута обрабатывается как временная ошибка доставки. Однако, если транспортный фильтр используется с транспортом **pipe**, таймаут транспортного фильтра обрабатывается таким же образом как и таймаут непосредственно в трубе (pipe). По умолчанию, таймаут - жёсткая ошибка, но если параметр **timeout_defer**  транспорта **pipe** истина, то она становиться временной ошибкой.

.. index::
   pair: transports; user

========  ===============  =============  ==================
**user**  Use: transports  Type: string†  Default: Exim user
========  ===============  =============  ==================

Этот параметр определяет пользователя, под чьим uid работает процесс доставки, замещая любой uid, который мог быть задан маршрутизатором. Если пользователь даётся в виде имени, uid ищется из данный пароля, и ассоциированная группа берётся как значение gid, для использования если параметр **group** не задан.

Для доставок использующих локальные транспорты, пользователь и группа обычно определяются явно, или неявно (например, как результат **check_local_user**) маршрутизатором или транспортом.

Для удалённых транспортов, вы должны оставить этот параметр незаданным, кроме случаев, когда вы действительно понимаете, что делаете. Когда выполняется удалённый транспорт Exim'a, ему необходима возможность доступа к базе данных подсказок Exim'a, поскольку каждый хост может может иметь собственные данные повторов.


.. [#] они в нём остаются, но при передаче сообщения далее они не передаются - прим. lissyara
.. [#] не цифры, или вообще левая строка текста - прим. lissyara
.. [#] имеется ввиду, что в будущих релизах Exim'a, она чё-то будет делать - прим. lissyara
.. [#] имеется ввиду, что в зависмости от пользователя можно делать разные действия - прим. lissyara
